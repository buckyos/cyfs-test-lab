// Generated by dts-bundle v0.7.3
// Dependencies for this module:
//   ../../jsbi
//   ../../@ethersproject/bignumber
//   ../../@ethersproject/bytes
//   ../../@ethersproject/properties
//   ../../node-fetch
//   ../../ts-results
//   ../../node-rsa
//   ../../long
//   ../../google-protobuf

import JSBI from 'jsbi';
import JSBI from "jsbi";
import { BigNumber } from "@ethersproject/bignumber";
import { BytesLike } from "@ethersproject/bytes";
import { BigNumber, BigNumberish } from "@ethersproject/bignumber";
import { Description } from "@ethersproject/properties";
import { Response } from 'node-fetch';
import { Result } from "ts-results";
import { Result } from 'ts-results';
export { Ok, Err, Result } from 'ts-results';
import NodeRSA from 'node-rsa';
import Long from 'long';
import * as jspb from "google-protobuf";

export { JSBI };

export { ConstructorFragment, ErrorFragment, EventFragment, Fragment, FunctionFragment, ParamType, FormatTypes, AbiCoder, defaultAbiCoder, Interface, Indexed, CoerceFunc, JsonFragment, JsonFragmentType, EthAbiResult, checkResultErrors, LogDescription, TransactionDescription };
export function encode_input(abi: string, name_or_signature: string, values: string[]): Uint8Array;
export function encode_constructor(abi: string, code: Uint8Array, values: string[]): Uint8Array;
export function decode_call_output(abi: string, name_or_signature: string, data: Uint8Array): EthAbiResult;
export function decode_log(abi: string, name_or_signature: string, topics: Uint8Array[], data: Uint8Array): EthAbiResult;
export function encode_topic(abi: string, name_or_signature: string, params: (string | null)[]): (Uint8Array | null)[];

export function ensureDirSync(dir: string): void;

export const DataViewJSBIHelper: typeof DataViewJSBIHelperNoBigInt;

export interface LogFileOptions {
    name: string;
    dir?: string;
    file_max_size?: number;
    file_max_count?: number;
}
export const clog: any;

export enum CyfsChannel {
    Nightly = "nightly",
    Beta = "beta",
    Stable = "stable"
}
export function get_channel(): CyfsChannel;

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class BlockDescTypeInfo extends DescTypeInfo {
    obj_type(): number;
    sub_desc_type(): SubDescType;
}
export class BlockDescContent extends DescContent {
    number: JSBI;
    coinbase: ObjectId;
    state_hash: HashValue;
    pre_block_hash: ObjectId;
    transactions_hash: HashValue;
    receipts_hash: HashValue;
    constructor(number: JSBI, coinbase: ObjectId, state_hash: HashValue, pre_block_hash: ObjectId, transactions_hash: HashValue, receipts_hash: HashValue);
    type_info(): DescTypeInfo;
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
}
export class BlockDescContentDecoder extends DescContentDecoder<BlockDescContent> {
    type_info(): DescTypeInfo;
    raw_decode(buf: Uint8Array): BuckyResult<[BlockDescContent, Uint8Array]>;
}
export class BlockBodyContent extends BodyContent {
    transactions: MetaTx[];
    receipts: Receipt[];
    constructor(transactions: MetaTx[], receipts: Receipt[]);
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
}
export class BlockBodyContentDecoder extends BodyContentDecoder<BlockBodyContent> {
    raw_decode(buf: Uint8Array): BuckyResult<[BlockBodyContent, Uint8Array]>;
}
export class BlockDesc extends NamedObjectDesc<BlockDescContent> {
}
export class BlockDescDecoder extends NamedObjectDescDecoder<BlockDescContent> {
    constructor();
}
export class BlockBuilder extends NamedObjectBuilder<BlockDescContent, BlockBodyContent> {
}
export class BlockId extends NamedObjectId<BlockDescContent, BlockBodyContent> {
    constructor(id: ObjectId);
    static default(): BlockId;
    static from_base_58(s: string): BuckyResult<BlockId>;
    static try_from_object_id(id: ObjectId): BuckyResult<BlockId>;
}
export class BlockIdDecoder extends NamedObjectIdDecoder<BlockDescContent, BlockBodyContent> {
    constructor();
}
export class Block extends NamedObject<BlockDescContent, BlockBodyContent> {
    static create(number: JSBI, coinbase: ObjectId, state_hash: HashValue, pre_block_hash: ObjectId, transactions_hash: HashValue, receipts_hash: HashValue, transactions: MetaTx[], receipts: Receipt[]): Block;
    ext(): BlockExt;
}
export class BlockDecoder extends NamedObjectDecoder<BlockDescContent, BlockBodyContent, Block> {
    constructor();
}

export class BlockExt {
    obj: Block;
    constructor(obj: Block);
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class GenesisCoinConfig implements RawEncode {
    coin_id: number;
    pre_balance: PreBalance[];
    constructor(coin_id: number, pre_balance: PreBalance[]);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class GenesisCoinConfigDecoder implements RawDecode<GenesisCoinConfig> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[GenesisCoinConfig, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class GenesisConfig implements RawEncode {
    chain_type: Option<string>;
    coinbase: ObjectId;
    interval: number;
    bfc_spv_node: string;
    coins: GenesisCoinConfig[];
    price: GenesisPriceConfig;
    miner_key_path: Option<string>;
    mg_path: Option<string>;
    miner_desc_path: Option<string>;
    sub_chain_tx: Option<string>;
    constructor(chain_type: Option<string>, coinbase: ObjectId, interval: number, bfc_spv_node: string, coins: GenesisCoinConfig[], price: GenesisPriceConfig, miner_key_path: Option<string>, mg_path: Option<string>, miner_desc_path: Option<string>, sub_chain_tx: Option<string>);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class GenesisConfigDecoder implements RawDecode<GenesisConfig> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[GenesisConfig, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class GenesisPriceConfig implements RawEncode {
    constructor();
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class GenesisPriceConfigDecoder implements RawDecode<GenesisPriceConfig> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[GenesisPriceConfig, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class PreBalance implements RawEncode {
    id: ObjectId;
    balance: JSBI;
    constructor(id: ObjectId, balance: JSBI);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class PreBalanceDecoder implements RawDecode<PreBalance> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[PreBalance, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class BidName implements RawEncode {
    name: string;
    price: JSBI;
    bid_id: ObjectId;
    coin_id: number;
    take_effect_block: JSBI;
    rent_price: JSBI;
    constructor(name: string, price: JSBI, bid_id: ObjectId, coin_id: number, take_effect_block: JSBI, rent_price: JSBI);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class BidNameDecoder implements RawDecode<BidName> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[BidName, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class ChangeNameParam implements RawEncode {
    name: string;
    to: NameState;
    constructor(name: string, to: NameState);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class ChangeNameParamDecoder implements RawDecode<ChangeNameParam> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[ChangeNameParam, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class Event implements RawEncode {
    static Rent(rent: RentParam): Event;
    static NameRent(namerent: NameRentParam): Event;
    static ChangeNameEvent(changenameevent: ChangeNameParam): Event;
    static BidName(bidname: BidName): Event;
    static StopAuction(stopauction: StopAuctionParam): Event;
    static UnionWithdraw(unionwithdraw: UnionWithdraw): Event;
    static Extension(extension: ExtensionEvent): Event;
    match<T>(visitor: {
        Rent?: (rent: RentParam) => T;
        NameRent?: (namerent: NameRentParam) => T;
        ChangeNameEvent?: (changenameevent: ChangeNameParam) => T;
        BidName?: (bidname: BidName) => T;
        StopAuction?: (stopauction: StopAuctionParam) => T;
        UnionWithdraw?: (unionwithdraw: UnionWithdraw) => T;
        Extension?: (extension: ExtensionEvent) => T;
    }): T | undefined;
    eq_type(rhs: Event): boolean;
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class EventDecoder implements RawDecode<Event> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[Event, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export enum EventType {
    Rent = 0,
    ChangeName = 1,
    NameRent = 2,
    BidName = 3,
    StopAuction = 4,
    UnionWithdraw = 5,
    Extension = 6
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class ExtensionEvent implements RawEncode {
    extension_type: MetaExtensionType;
    data: Uint8Array;
    constructor(extension_type: MetaExtensionType, data: Uint8Array);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class ExtensionEventDecoder implements RawDecode<ExtensionEvent> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[ExtensionEvent, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class NameRentParam implements RawEncode {
    name_id: string;
    constructor(name_id: string);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class NameRentParamDecoder implements RawDecode<NameRentParam> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[NameRentParam, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class RentParam implements RawEncode {
    id: ObjectId;
    constructor(id: ObjectId);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class RentParamDecoder implements RawDecode<RentParam> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[RentParam, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class StopAuctionParam implements RawEncode {
    name: string;
    stop_block: JSBI;
    starting_price: JSBI;
    constructor(name: string, stop_block: JSBI, starting_price: JSBI);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class StopAuctionParamDecoder implements RawDecode<StopAuctionParam> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[StopAuctionParam, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class UnionWithdraw implements RawEncode {
    union_id: ObjectId;
    account_id: ObjectId;
    ctid: CoinTokenId;
    value: JSBI;
    height: JSBI;
    constructor(union_id: ObjectId, account_id: ObjectId, ctid: CoinTokenId, value: JSBI, height: JSBI);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class UnionWithdrawDecoder implements RawDecode<UnionWithdraw> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[UnionWithdraw, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class MetaExtensionTx implements RawEncode {
    extension_id: MetaExtensionType;
    tx_data: Uint8Array;
    constructor(extension_id: MetaExtensionType, tx_data: Uint8Array);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class MetaExtensionTxDecoder implements RawDecode<MetaExtensionTx> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[MetaExtensionTx, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class MetaExtensionType implements RawEncode {
    static DSG(): MetaExtensionType;
    match<T>(visitor: {
        DSG?: () => T;
    }): T | undefined;
    eq_type(rhs: MetaExtensionType): boolean;
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class MetaExtensionTypeDecoder implements RawDecode<MetaExtensionType> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[MetaExtensionType, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class ServiceAuthType implements RawEncode {
    static Any(): ServiceAuthType;
    static WhiteList(): ServiceAuthType;
    static BlackList(): ServiceAuthType;
    match<T>(visitor: {
        Any?: () => T;
        WhiteList?: () => T;
        BlackList?: () => T;
    }): T | undefined;
    eq_type(rhs: ServiceAuthType): boolean;
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class ServiceAuthTypeDecoder implements RawDecode<ServiceAuthType> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[ServiceAuthType, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class SNContractBodyContent implements RawEncode {
    auth_type: ServiceAuthType;
    list: ObjectId[];
    constructor(auth_type: ServiceAuthType, list: ObjectId[]);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class SNContractBodyContentDecoder implements RawDecode<SNContractBodyContent> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[SNContractBodyContent, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class SNPurchase implements RawEncode {
    service_id: ObjectId;
    start_time: JSBI;
    stop_time: JSBI;
    auth_type: ServiceAuthType;
    auth_list: ObjectId[];
    constructor(service_id: ObjectId, start_time: JSBI, stop_time: JSBI, auth_type: ServiceAuthType, auth_list: ObjectId[]);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class SNPurchaseDecoder implements RawDecode<SNPurchase> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[SNPurchase, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class SNServiceDescTypeInfo extends DescTypeInfo {
    obj_type(): number;
    sub_desc_type(): SubDescType;
}
export class SNServiceDescContent extends DescContent {
    service_type: number;
    price: JSBI;
    constructor(service_type: number, price: JSBI);
    type_info(): DescTypeInfo;
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
}
export class SNServiceDescContentDecoder extends DescContentDecoder<SNServiceDescContent> {
    type_info(): DescTypeInfo;
    raw_decode(buf: Uint8Array): BuckyResult<[SNServiceDescContent, Uint8Array]>;
}
export class SNServiceBodyContent extends BodyContent {
    constructor();
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
}
export class SNServiceBodyContentDecoder extends BodyContentDecoder<SNServiceBodyContent> {
    raw_decode(buf: Uint8Array): BuckyResult<[SNServiceBodyContent, Uint8Array]>;
}
export class SNServiceDesc extends NamedObjectDesc<SNServiceDescContent> {
}
export class SNServiceDescDecoder extends NamedObjectDescDecoder<SNServiceDescContent> {
    constructor();
}
export class SNServiceBuilder extends NamedObjectBuilder<SNServiceDescContent, SNServiceBodyContent> {
}
export class SNServiceId extends NamedObjectId<SNServiceDescContent, SNServiceBodyContent> {
    constructor(id: ObjectId);
    static default(): SNServiceId;
    static from_base_58(s: string): BuckyResult<SNServiceId>;
    static try_from_object_id(id: ObjectId): BuckyResult<SNServiceId>;
}
export class SNServiceIdDecoder extends NamedObjectIdDecoder<SNServiceDescContent, SNServiceBodyContent> {
    constructor();
}
export class SNService extends NamedObject<SNServiceDescContent, SNServiceBodyContent> {
    static create(owner: ObjectId, service_type: number, price: JSBI): SNService;
}
export class SNServiceDecoder extends NamedObjectDecoder<SNServiceDescContent, SNServiceBodyContent, SNService> {
    constructor();
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class BlockInfo {
    height: JSBI;
    block_hash: string;
    create_time: JSBI;
    tx_list: TxInfo[];
    constructor(height: JSBI, block_hash: string, create_time: JSBI, tx_list: TxInfo[]);
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class BlockSection {
    start: JSBI;
    end: JSBI;
    constructor(start: JSBI, end: JSBI);
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class GetBlocksRequest {
    start_block: JSBI;
    end_block: JSBI;
    constructor(start_block: JSBI, end_block: JSBI);
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class GetTxListRequest {
    address_list: string[];
    block_section: Option<BlockSection>;
    offset: JSBI;
    length: JSBI;
    constructor(address_list: string[], block_section: Option<BlockSection>, offset: JSBI, length: JSBI);
}

export const TX_STATUS_PENDING: number;
export const TX_STATUS_BLOCKED: number;

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class SPVTx implements RawEncode {
    hash: string;
    number: JSBI;
    from: string;
    to: string;
    coin_id: number;
    value: JSBI;
    desc: string;
    create_time: JSBI;
    result: number;
    use_fee: number;
    nonce: JSBI;
    gas_coin_id: number;
    gas_price: number;
    max_fee: number;
    constructor(hash: string, number: JSBI, from: string, to: string, coin_id: number, value: JSBI, desc: string, create_time: JSBI, result: number, use_fee: number, nonce: JSBI, gas_coin_id: number, gas_price: number, max_fee: number);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class SPVTxDecoder implements RawDecode<SPVTx> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[SPVTx, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class TxInfo {
    status: number;
    tx: TxMetaData;
    block_number: Option<string>;
    block_hash: Option<string>;
    block_create_time: Option<string>;
    constructor(status: number, tx: TxMetaData, block_number: Option<string>, block_hash: Option<string>, block_create_time: Option<string>);
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class TxMetaData {
    tx_hash: string;
    create_time: string;
    nonce: string;
    caller: string;
    gas_coin_id: number;
    gas_price: number;
    max_fee: number;
    result: number;
    use_fee: number;
    to: TxMetaItem[];
    constructor(tx_hash: string, create_time: string, nonce: string, caller: string, gas_coin_id: number, gas_price: number, max_fee: number, result: number, use_fee: number, to: TxMetaItem[]);
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class TxMetaItem {
    field_0: string;
    field_1: number;
    field_2: string;
    constructor(field_0: string, field_1: number, field_2: string);
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class AuctionNameTx implements RawEncode {
    name: string;
    price: JSBI;
    constructor(name: string, price: JSBI);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class AuctionNameTxDecoder implements RawDecode<AuctionNameTx> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[AuctionNameTx, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class BidNameTx implements RawEncode {
    name: string;
    owner: Option<ObjectId>;
    name_price: JSBI;
    price: number;
    constructor(name: string, owner: Option<ObjectId>, name_price: JSBI, price: number);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class BidNameTxDecoder implements RawDecode<BidNameTx> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[BidNameTx, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class BTCCoinageRecordTx implements RawEncode {
    height: JSBI;
    list: BTCTxRecord[];
    constructor(height: JSBI, list: BTCTxRecord[]);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class BTCCoinageRecordTxDecoder implements RawDecode<BTCCoinageRecordTx> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[BTCCoinageRecordTx, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class BTCTxRecord implements RawEncode {
    txid: string;
    blockHash: string;
    blockNumber: JSBI;
    confirmed: JSBI;
    received: JSBI;
    exodusAddress: string;
    btcValue: JSBI;
    version: number;
    propertyID: number;
    op: number;
    address: string;
    constructor(txid: string, blockHash: string, blockNumber: JSBI, confirmed: JSBI, received: JSBI, exodusAddress: string, btcValue: JSBI, version: number, propertyID: number, op: number, address: string);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class BTCTxRecordDecoder implements RawDecode<BTCTxRecord> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[BTCTxRecord, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class BuyBackNameTx implements RawEncode {
    name: string;
    constructor(name: string);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class BuyBackNameTxDecoder implements RawDecode<BuyBackNameTx> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[BuyBackNameTx, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class CancelAuctionNameTx implements RawEncode {
    name: string;
    constructor(name: string);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class CancelAuctionNameTxDecoder implements RawDecode<CancelAuctionNameTx> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[CancelAuctionNameTx, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class CoinTokenId implements RawEncode {
    static Coin(coin: number): CoinTokenId;
    static Token(token: ObjectId): CoinTokenId;
    match<T>(visitor: {
        Coin?: (coin: number) => T;
        Token?: (token: ObjectId) => T;
    }): T | undefined;
    eq_type(rhs: CoinTokenId): boolean;
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class CoinTokenIdDecoder implements RawDecode<CoinTokenId> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[CoinTokenId, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class ContractTx implements RawEncode {
    instance_id: ObjectId;
    func_name: string;
    parm_body: Uint8Array;
    constructor(instance_id: ObjectId, func_name: string, parm_body: Uint8Array);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class ContractTxDecoder implements RawDecode<ContractTx> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[ContractTx, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class CreateDescTx implements RawEncode {
    coin_id: number;
    from: Option<ObjectId>;
    value: JSBI;
    desc_hash: HashValue;
    price: number;
    constructor(coin_id: number, from: Option<ObjectId>, value: JSBI, desc_hash: HashValue, price: number);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class CreateDescTxDecoder implements RawDecode<CreateDescTx> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[CreateDescTx, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class CreateUnionBody implements RawEncode {
    account: UnionAccount;
    ctid: CoinTokenId;
    left_balance: JSBI;
    right_balance: JSBI;
    constructor(account: UnionAccount, ctid: CoinTokenId, left_balance: JSBI, right_balance: JSBI);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class CreateUnionBodyDecoder implements RawDecode<CreateUnionBody> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[CreateUnionBody, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class CreateUnionTx implements RawEncode {
    body: CreateUnionBody;
    signs: Signature[];
    constructor(body: CreateUnionBody, signs: Signature[]);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class CreateUnionTxDecoder implements RawDecode<CreateUnionTx> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[CreateUnionTx, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class Data implements RawEncode {
    id: ObjectId;
    data: Uint8Array;
    constructor(id: ObjectId, data: Uint8Array);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class DataDecoder implements RawDecode<Data> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[Data, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class DeviateUnionTx implements RawEncode {
    body: DeviateUnionBody;
    signs: Signature[];
    constructor(body: DeviateUnionBody, signs: Signature[]);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class DeviateUnionTxDecoder implements RawDecode<DeviateUnionTx> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[DeviateUnionTx, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class DeviateUnionBody implements RawEncode {
    ctid: CoinTokenId;
    seq: JSBI;
    deviation: JSBI;
    union: ObjectId;
    constructor(ctid: CoinTokenId, seq: JSBI, deviation: JSBI, union: ObjectId);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class DeviateUnionBodyDecoder implements RawDecode<DeviateUnionBody> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[DeviateUnionBody, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class FlowServiceDescTypeInfo extends DescTypeInfo {
    obj_type(): number;
    sub_desc_type(): SubDescType;
}
export class FlowServiceDescContent extends DescContent {
    constructor();
    type_info(): DescTypeInfo;
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
}
export class FlowServiceDescContentDecoder extends DescContentDecoder<FlowServiceDescContent> {
    type_info(): DescTypeInfo;
    raw_decode(buf: Uint8Array): BuckyResult<[FlowServiceDescContent, Uint8Array]>;
}
export class FlowServiceBodyContent extends BodyContent {
    price: JSBI;
    constructor(price: JSBI);
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
}
export class FlowServiceBodyContentDecoder extends BodyContentDecoder<FlowServiceBodyContent> {
    raw_decode(buf: Uint8Array): BuckyResult<[FlowServiceBodyContent, Uint8Array]>;
}
export class FlowServiceDesc extends NamedObjectDesc<FlowServiceDescContent> {
}
export class FlowServiceDescDecoder extends NamedObjectDescDecoder<FlowServiceDescContent> {
    constructor();
}
export class FlowServiceBuilder extends NamedObjectBuilder<FlowServiceDescContent, FlowServiceBodyContent> {
}
export class FlowServiceId extends NamedObjectId<FlowServiceDescContent, FlowServiceBodyContent> {
    constructor(id: ObjectId);
    static default(): FlowServiceId;
    static from_base_58(s: string): BuckyResult<FlowServiceId>;
    static try_from_object_id(id: ObjectId): BuckyResult<FlowServiceId>;
}
export class FlowServiceIdDecoder extends NamedObjectIdDecoder<FlowServiceDescContent, FlowServiceBodyContent> {
    constructor();
}
export class FlowService extends NamedObject<FlowServiceDescContent, FlowServiceBodyContent> {
    static create(owner: ObjectId, price: JSBI): FlowService;
}
export class FlowServiceDecoder extends NamedObjectDecoder<FlowServiceDescContent, FlowServiceBodyContent, FlowService> {
    constructor();
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class FlowServiceTx implements RawEncode {
    static Create(create: FlowService): FlowServiceTx;
    static Purchase(purchase: number): FlowServiceTx;
    static Settle(): FlowServiceTx;
    match<T>(visitor: {
        Create?: (create: FlowService) => T;
        Purchase?: (purchase: number) => T;
        Settle?: () => T;
    }): T | undefined;
    eq_type(rhs: FlowServiceTx): boolean;
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class FlowServiceTxDecoder implements RawDecode<FlowServiceTx> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[FlowServiceTx, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class InstanceContractTx implements RawEncode {
    contract_id: ObjectId;
    template_parms: Uint8Array;
    constructor(contract_id: ObjectId, template_parms: Uint8Array);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class InstanceContractTxDecoder implements RawDecode<InstanceContractTx> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[InstanceContractTx, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class MetaPrice implements RawEncode {
    coin_id: number;
    price: number;
    constructor(coin_id: number, price: number);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class MetaPriceDecoder implements RawDecode<MetaPrice> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[MetaPrice, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class MetaTxDescTypeInfo extends DescTypeInfo {
    obj_type(): number;
    sub_desc_type(): SubDescType;
}
export class MetaTxDescContent extends DescContent {
    nonce: JSBI;
    caller: TxCaller;
    gas_coin_id: number;
    gas_price: number;
    max_fee: number;
    condition: Option<TxCondition>;
    body: MetaTxBody[];
    constructor(nonce: JSBI, caller: TxCaller, gas_coin_id: number, gas_price: number, max_fee: number, condition: Option<TxCondition>, body: MetaTxBody[]);
    type_info(): DescTypeInfo;
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
}
export class MetaTxDescContentDecoder extends DescContentDecoder<MetaTxDescContent> {
    type_info(): DescTypeInfo;
    raw_decode(buf: Uint8Array): BuckyResult<[MetaTxDescContent, Uint8Array]>;
}
export class MetaTxDesc extends NamedObjectDesc<MetaTxDescContent> {
}
export class MetaTxDescDecoder extends NamedObjectDescDecoder<MetaTxDescContent> {
    constructor();
}
export class MetaTxBuilder extends NamedObjectBuilder<MetaTxDescContent, TxBodyContent> {
}
export class MetaTxId extends NamedObjectId<MetaTxDescContent, TxBodyContent> {
    constructor(id: ObjectId);
    static default(): MetaTxId;
    static from_base_58(s: string): BuckyResult<MetaTxId>;
    static try_from_object_id(id: ObjectId): BuckyResult<MetaTxId>;
}
export class MetaTxIdDecoder extends NamedObjectIdDecoder<MetaTxDescContent, TxBodyContent> {
    constructor();
}
export class MetaTx extends NamedObject<MetaTxDescContent, TxBodyContent> {
    static create(nonce: JSBI, caller: TxCaller, gas_coin_id: number, gas_price: number, max_fee: number, condition: Option<TxCondition>, body: MetaTxBody[], data: Uint8Array): MetaTx;
    ext(): MetaTxExt;
}
export class MetaTxDecoder extends NamedObjectDecoder<MetaTxDescContent, TxBodyContent, MetaTx> {
    constructor();
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class MetaTxBody implements RawEncode {
    static TransBalance(transbalance: TransBalanceTx): MetaTxBody;
    static CreateUnion(createunion: CreateUnionTx): MetaTxBody;
    static DeviateUnion(deviateunion: DeviateUnionTx): MetaTxBody;
    static WithdrawFromUnion(withdrawfromunion: WithdrawFromUnionTx): MetaTxBody;
    static CreateDesc(createdesc: CreateDescTx): MetaTxBody;
    static UpdateDesc(updatedesc: UpdateDescTx): MetaTxBody;
    static RemoveDesc(removedesc: RemoveDescTx): MetaTxBody;
    static BidName(bidname: BidNameTx): MetaTxBody;
    static UpdateName(updatename: UpdateNameTx): MetaTxBody;
    static TransName(transname: TransNameTx): MetaTxBody;
    static Contract(contract: ContractTx): MetaTxBody;
    static SetConfig(setconfig: SetConfigTx): MetaTxBody;
    static AuctionName(auctionname: AuctionNameTx): MetaTxBody;
    static CancelAuctionName(cancelauctionname: CancelAuctionNameTx): MetaTxBody;
    static BuyBackName(buybackname: BuyBackNameTx): MetaTxBody;
    static BTCCoinageRecord(btccoinagerecord: BTCCoinageRecordTx): MetaTxBody;
    static WithdrawToOwner(withdrawtoowner: WithdrawToOwner): MetaTxBody;
    static CreateMinerGroup(createminergroup: MinerGroup): MetaTxBody;
    static UpdateMinerGroup(updateminergroup: MinerGroup): MetaTxBody;
    static CreateSubChainAccount(createsubchainaccount: MinerGroup): MetaTxBody;
    static UpdateSubChainAccount(updatesubchainaccount: MinerGroup): MetaTxBody;
    static SubChainWithdraw(subchainwithdraw: SubChainWithdrawTx): MetaTxBody;
    static WithdrawFromSubChain(withdrawfromsubchain: WithdrawFromSubChainTx): MetaTxBody;
    static SubChainCoinageRecord(subchaincoinagerecord: SubChainCoinageRecordTx): MetaTxBody;
    static Extension(extension: MetaExtensionTx): MetaTxBody;
    static CreateContract(createcontract: CreateContractTx): MetaTxBody;
    static CreateContract2(createcontract2: CreateContract2Tx): MetaTxBody;
    static CallContract(callcontract: CallContractTx): MetaTxBody;
    match<T>(visitor: {
        TransBalance?: (transbalance: TransBalanceTx) => T;
        CreateUnion?: (createunion: CreateUnionTx) => T;
        DeviateUnion?: (deviateunion: DeviateUnionTx) => T;
        WithdrawFromUnion?: (withdrawfromunion: WithdrawFromUnionTx) => T;
        CreateDesc?: (createdesc: CreateDescTx) => T;
        UpdateDesc?: (updatedesc: UpdateDescTx) => T;
        RemoveDesc?: (removedesc: RemoveDescTx) => T;
        BidName?: (bidname: BidNameTx) => T;
        UpdateName?: (updatename: UpdateNameTx) => T;
        TransName?: (transname: TransNameTx) => T;
        Contract?: (contract: ContractTx) => T;
        SetConfig?: (setconfig: SetConfigTx) => T;
        AuctionName?: (auctionname: AuctionNameTx) => T;
        CancelAuctionName?: (cancelauctionname: CancelAuctionNameTx) => T;
        BuyBackName?: (buybackname: BuyBackNameTx) => T;
        BTCCoinageRecord?: (btccoinagerecord: BTCCoinageRecordTx) => T;
        WithdrawToOwner?: (withdrawtoowner: WithdrawToOwner) => T;
        CreateMinerGroup?: (createminergroup: MinerGroup) => T;
        UpdateMinerGroup?: (updateminergroup: MinerGroup) => T;
        CreateSubChainAccount?: (createsubchainaccount: MinerGroup) => T;
        UpdateSubChainAccount?: (updatesubchainaccount: MinerGroup) => T;
        SubChainWithdraw?: (subchainwithdraw: SubChainWithdrawTx) => T;
        WithdrawFromSubChain?: (withdrawfromsubchain: WithdrawFromSubChainTx) => T;
        SubChainCoinageRecord?: (subchaincoinagerecord: SubChainCoinageRecordTx) => T;
        Extension?: (extension: MetaExtensionTx) => T;
        CreateContract?: (tx: CreateContractTx) => T;
        CreateContract2?: (tx: CreateContract2Tx) => T;
        CallContract?: (tx: CallContractTx) => T;
    }): T | undefined;
    eq_type(rhs: MetaTxBody): boolean;
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class MetaTxBodyDecoder implements RawDecode<MetaTxBody> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[MetaTxBody, Uint8Array]>;
}

export class MetaTxExt {
    obj: MetaTx;
    constructor(obj: MetaTx);
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class MinerGroupDescTypeInfo extends DescTypeInfo {
    obj_type(): number;
    sub_desc_type(): SubDescType;
}
export class MinerGroupDescContent extends DescContent {
    constructor();
    type_info(): DescTypeInfo;
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
}
export class MinerGroupDescContentDecoder extends DescContentDecoder<MinerGroupDescContent> {
    type_info(): DescTypeInfo;
    raw_decode(buf: Uint8Array): BuckyResult<[MinerGroupDescContent, Uint8Array]>;
}
export class MinerGroupBodyContent extends BodyContent {
    members: DeviceDesc[];
    constructor(members: DeviceDesc[]);
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
}
export class MinerGroupBodyContentDecoder extends BodyContentDecoder<MinerGroupBodyContent> {
    raw_decode(buf: Uint8Array): BuckyResult<[MinerGroupBodyContent, Uint8Array]>;
}
export class MinerGroupDesc extends NamedObjectDesc<MinerGroupDescContent> {
}
export class MinerGroupDescDecoder extends NamedObjectDescDecoder<MinerGroupDescContent> {
    constructor();
}
export class MinerGroupBuilder extends NamedObjectBuilder<MinerGroupDescContent, MinerGroupBodyContent> {
}
export class MinerGroupId extends NamedObjectId<MinerGroupDescContent, MinerGroupBodyContent> {
    constructor(id: ObjectId);
    static default(): MinerGroupId;
    static from_base_58(s: string): BuckyResult<MinerGroupId>;
    static try_from_object_id(id: ObjectId): BuckyResult<MinerGroupId>;
}
export class MinerGroupIdDecoder extends NamedObjectIdDecoder<MinerGroupDescContent, MinerGroupBodyContent> {
    constructor();
}
export class MinerGroup extends NamedObject<MinerGroupDescContent, MinerGroupBodyContent> {
    static create(members: DeviceDesc[]): MinerGroup;
    ext(): MinerGroupExt;
}
export class MinerGroupDecoder extends NamedObjectDecoder<MinerGroupDescContent, MinerGroupBodyContent, MinerGroup> {
    constructor();
}

export class MinerGroupExt {
    obj: MinerGroup;
    constructor(obj: MinerGroup);
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class ContractLog implements RawEncode {
    address: ObjectId;
    topics: Uint8Array[];
    data: Uint8Array;
    constructor(address: ObjectId, topics: Uint8Array[], data: Uint8Array);
    raw_measure(ctx?: any, purpose?: RawEncodePurpose): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any, purpose?: RawEncodePurpose): BuckyResult<Uint8Array>;
}
export class ContractLogDecoder implements RawDecode<ContractLog> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[ContractLog, Uint8Array]>;
}
export class TxLog implements RawEncode {
    static ContractLog(contractLog: ContractLog): TxLog;
    match<T>(visitor: {
        ContractLog?: (contractLog: ContractLog) => T;
    }): T | undefined;
    eq_type(rhs: TxLog): boolean;
    raw_measure(ctx?: any, purpose?: RawEncodePurpose): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any, purpose?: RawEncodePurpose): BuckyResult<Uint8Array>;
}
export class TxLogDecoder implements RawDecode<TxLog> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[TxLog, Uint8Array]>;
}
export class Receipt implements RawEncode {
    result: number;
    fee_used: number;
    logs: TxLog[];
    address: Option<ObjectId>;
    return_value: Option<Uint8Array>;
    constructor(result: number, fee_used: number, logs: TxLog[], address: Option<ObjectId>, return_value: Option<Uint8Array>);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class ReceiptDecoder implements RawDecode<Receipt> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[Receipt, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class RemoveDescTx implements RawEncode {
    id: ObjectId;
    constructor(id: ObjectId);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class RemoveDescTxDecoder implements RawDecode<RemoveDescTx> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[RemoveDescTx, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class SavedMetaObject implements RawEncode {
    static try_from(object: StandardObject): BuckyResult<SavedMetaObject>;
    static Device(device: Device): SavedMetaObject;
    static People(people: People): SavedMetaObject;
    static UnionAccount(unionaccount: UnionAccount): SavedMetaObject;
    static Group(group: SimpleGroup): SavedMetaObject;
    static File(file: File): SavedMetaObject;
    static Data(data: Data): SavedMetaObject;
    static Org(org: Org): SavedMetaObject;
    static MinerGroup(minergroup: MinerGroup): SavedMetaObject;
    static SNService(snservice: SNService): SavedMetaObject;
    static Contract(contract: Contract): SavedMetaObject;
    match<T>(visitor: {
        Device?: (device: Device) => T;
        People?: (people: People) => T;
        UnionAccount?: (unionaccount: UnionAccount) => T;
        Group?: (group: SimpleGroup) => T;
        File?: (file: File) => T;
        Data?: (data: Data) => T;
        Org?: (org: Org) => T;
        MinerGroup?: (minergroup: MinerGroup) => T;
        SNService?: (snservice: SNService) => T;
        Contract?: (contract: Contract) => T;
    }): T | undefined;
    eq_type(rhs: SavedMetaObject): boolean;
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
    hash(): BuckyResult<HashValue>;
}
export class SavedMetaObjectDecoder implements RawDecode<SavedMetaObject> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[SavedMetaObject, Uint8Array]>;
}

export class SavedMetaObjectExt {
    obj: SavedMetaObject;
    constructor(obj: SavedMetaObject);
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class SetConfigTx implements RawEncode {
    key: string;
    value: string;
    constructor(key: string, value: string);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class SetConfigTxDecoder implements RawDecode<SetConfigTx> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[SetConfigTx, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class SNServiceTx implements RawEncode {
    static Publish(publish: SNService): SNServiceTx;
    static Remove(remove: ObjectId): SNServiceTx;
    static Purchase(purchase: Contract): SNServiceTx;
    static Settle(settle: ProofOfService): SNServiceTx;
    match<T>(visitor: {
        Publish?: (publish: SNService) => T;
        Remove?: (remove: ObjectId) => T;
        Purchase?: (purchase: Contract) => T;
        Settle?: (settle: ProofOfService) => T;
    }): T | undefined;
    eq_type(rhs: SNServiceTx): boolean;
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class SNServiceTxDecoder implements RawDecode<SNServiceTx> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[SNServiceTx, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class SubChainCoinageRecordTx implements RawEncode {
    height: JSBI;
    list: SPVTx[];
    constructor(height: JSBI, list: SPVTx[]);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class SubChainCoinageRecordTxDecoder implements RawDecode<SubChainCoinageRecordTx> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[SubChainCoinageRecordTx, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class SubChainWithdrawTx implements RawEncode {
    subchain_id: ObjectId;
    withdraw_tx: Uint8Array;
    constructor(subchain_id: ObjectId, withdraw_tx: Uint8Array);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class SubChainWithdrawTxDecoder implements RawDecode<SubChainWithdrawTx> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[SubChainWithdrawTx, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class TransBalanceTx implements RawEncode {
    ctid: CoinTokenId;
    to: TransBalanceTxItem[];
    constructor(ctid: CoinTokenId, to: TransBalanceTxItem[]);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class TransBalanceTxDecoder implements RawDecode<TransBalanceTx> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[TransBalanceTx, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class TransBalanceTxItem implements RawEncode {
    id: ObjectId;
    balance: JSBI;
    constructor(id: ObjectId, balance: JSBI);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class TransBalanceTxItemDecoder implements RawDecode<TransBalanceTxItem> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[TransBalanceTxItem, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class TransNameTx implements RawEncode {
    sub_name: Option<string>;
    new_owner: ObjectId;
    constructor(sub_name: Option<string>, new_owner: ObjectId);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class TransNameTxDecoder implements RawDecode<TransNameTx> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[TransNameTx, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class TxDescTypeInfo extends DescTypeInfo {
    obj_type(): number;
    sub_desc_type(): SubDescType;
}
export class TxDescContent<T extends RawEncode> extends DescContent {
    nonce: JSBI;
    caller: TxCaller;
    gas_coin_id: number;
    gas_price: number;
    max_fee: number;
    condition: Option<TxCondition>;
    body: T;
    constructor(nonce: JSBI, caller: TxCaller, gas_coin_id: number, gas_price: number, max_fee: number, condition: Option<TxCondition>, body: T);
    type_info(): DescTypeInfo;
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
}
export class TxDescContentDecoder<T extends RawEncode, D extends RawDecode<T>> extends DescContentDecoder<TxDescContent<T>> {
    constructor(inner_decoder: D);
    type_info(): DescTypeInfo;
    raw_decode(buf: Uint8Array): BuckyResult<[TxDescContent<T>, Uint8Array]>;
}
export class TxBodyContent extends ProtobufBodyContent {
    data: Uint8Array;
    try_to_proto(): BuckyResult<protos.TxBodyContent>;
    constructor(data: Uint8Array);
}
export class TxBodyContentDecoder extends BodyContentDecoder<TxBodyContent> {
    raw_decode(buf: Uint8Array): BuckyResult<[TxBodyContent, Uint8Array]>;
}
export type MetaTxDescContentType = TxDescContent<TypeBuffer<Vec<MetaTxBody>>>;
export class TxDesc extends NamedObjectDesc<MetaTxDescContentType> {
}
export class TxBuilder extends NamedObjectBuilder<MetaTxDescContentType, TxBodyContent> {
}
export class TxId extends NamedObjectId<MetaTxDescContentType, TxBodyContent> {
    constructor(id: ObjectId);
    static default(): TxId;
    static from_base_58(s: string): BuckyResult<TxId>;
    static try_from_object_id(id: ObjectId): BuckyResult<TxId>;
}
export class TxIdDecoder extends NamedObjectIdDecoder<MetaTxDescContentType, TxBodyContent> {
    constructor();
}
export class Tx extends NamedObject<MetaTxDescContentType, TxBodyContent> {
    static create(nonce: JSBI, caller: TxCaller, gas_coin_id: number, gas_price: number, max_fee: number, condition: Option<TxCondition>, body: MetaTxBody, data: Uint8Array): Tx;
    ext(): TxExt;
}
export class TxDecoder extends NamedObjectDecoder<MetaTxDescContentType, TxBodyContent, Tx> {
    constructor();
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class TxBody implements RawEncode {
    body: Uint8Array;
    constructor(body: Uint8Array);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class TxBodyDecoder implements RawDecode<TxBody> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[TxBody, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class TxCaller implements RawEncode {
    static try_from(object: StandardObject): BuckyResult<TxCaller>;
    static People(people: PeopleDesc): TxCaller;
    static Device(device: DeviceDesc): TxCaller;
    static Group(group: SimpleGroupDesc): TxCaller;
    static Union(union: UnionAccountDesc): TxCaller;
    static Miner(miner: ObjectId): TxCaller;
    static Id(id: ObjectId): TxCaller;
    match<T>(visitor: {
        People?: (people: PeopleDesc) => T;
        Device?: (device: DeviceDesc) => T;
        Group?: (group: SimpleGroupDesc) => T;
        Union?: (union: UnionAccountDesc) => T;
        Miner?: (miner: ObjectId) => T;
        Id?: (id: ObjectId) => T;
    }): T | undefined;
    eq_type(rhs: TxCaller): boolean;
    ext(): TxCallerExt;
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class TxCallerDecoder implements RawDecode<TxCaller> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[TxCaller, Uint8Array]>;
}

export class TxCallerExt {
    obj: TxCaller;
    constructor(obj: TxCaller);
    id(): BuckyResult<ObjectId>;
    get_public_key(): BuckyResult<PublicKey>;
    is_miner(): boolean;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class TxCondition implements RawEncode {
    static Empty(): TxCondition;
    match<T>(visitor: {
        Empty?: () => T;
    }): T | undefined;
    eq_type(rhs: TxCondition): boolean;
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class TxConditionDecoder implements RawDecode<TxCondition> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[TxCondition, Uint8Array]>;
}

export class TxExt {
    obj: Tx;
    constructor(obj: Tx);
    tx_id(): TxId;
    connect_info(): TxBodyContent;
    verify_signature(public_key: PublicKey): Promise<BuckyResult<boolean>>;
    sign(): Promise<BuckyResult<number>>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class UpdateDescTx implements RawEncode {
    write_flag: number;
    price: Option<MetaPrice>;
    desc_hash: HashValue;
    constructor(write_flag: number, price: Option<MetaPrice>, desc_hash: HashValue);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class UpdateDescTxDecoder implements RawDecode<UpdateDescTx> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[UpdateDescTx, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class UpdateNameTx implements RawEncode {
    name: string;
    info: NameInfo;
    write_flag: number;
    constructor(name: string, info: NameInfo, write_flag: number);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class UpdateNameTxDecoder implements RawDecode<UpdateNameTx> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[UpdateNameTx, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class WithdrawToOwner implements RawEncode {
    ctid: CoinTokenId;
    id: ObjectId;
    value: JSBI;
    constructor(ctid: CoinTokenId, id: ObjectId, value: JSBI);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class WithdrawToOwnerDecoder implements RawDecode<WithdrawToOwner> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[WithdrawToOwner, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class WithdrawFromSubChainTx implements RawEncode {
    coin_id: CoinTokenId;
    value: JSBI;
    constructor(coin_id: CoinTokenId, value: JSBI);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class WithdrawFromSubChainTxDecoder implements RawDecode<WithdrawFromSubChainTx> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[WithdrawFromSubChainTx, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class WithdrawFromUnionTx implements RawEncode {
    ctid: CoinTokenId;
    union: ObjectId;
    value: JSBI;
    constructor(ctid: CoinTokenId, union: ObjectId, value: JSBI);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class WithdrawFromUnionTxDecoder implements RawDecode<WithdrawFromUnionTx> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[WithdrawFromUnionTx, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export enum FFSObjectState {
    Normal = 0,
    Expire = 1
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export enum PeerOfUnion {
    Left = 0,
    Right = 1
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class UnionBalance implements RawEncode {
    total: JSBI;
    left: JSBI;
    right: JSBI;
    deviation: JSBI;
    constructor(total: JSBI, left: JSBI, right: JSBI, deviation: JSBI);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class UnionBalanceDecoder implements RawDecode<UnionBalance> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[UnionBalance, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class ChainStatus implements RawEncode {
    version: number;
    height: JSBI;
    gas_price: GasPrice;
    constructor(version: number, height: JSBI, gas_price: GasPrice);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class ChainStatusDecoder implements RawDecode<ChainStatus> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[ChainStatus, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class GasPrice implements RawEncode {
    low: JSBI;
    medium: JSBI;
    high: JSBI;
    constructor(low: JSBI, medium: JSBI, high: JSBI);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class GasPriceDecoder implements RawDecode<GasPrice> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[GasPrice, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class TxFullInfo implements RawEncode {
    status: number;
    block_number: JSBI;
    tx: MetaTx;
    receipt: Option<Receipt>;
    constructor(status: number, block_number: JSBI, tx: MetaTx, receipt: Option<Receipt>);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class TxFullInfoDecoder implements RawDecode<TxFullInfo> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[TxFullInfo, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class ViewBlockEnum implements RawEncode {
    static Tip(): ViewBlockEnum;
    static Number(number: JSBI): ViewBlockEnum;
    static Hash(hash: ObjectId): ViewBlockEnum;
    match<T>(visitor: {
        Tip?: () => T;
        Number?: (number: JSBI) => T;
        Hash?: (hash: ObjectId) => T;
    }): T | undefined;
    eq_type(rhs: ViewBlockEnum): boolean;
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class ViewBlockEnumDecoder implements RawDecode<ViewBlockEnum> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[ViewBlockEnum, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class ViewMethodEnum implements RawEncode {
    static ViewBalance(viewbalance: ViewBalanceMethod): ViewMethodEnum;
    static ViewName(viewname: ViewNameMethod): ViewMethodEnum;
    static ViewDesc(viewdesc: ViewDescMethod): ViewMethodEnum;
    static ViewRaw(viewraw: ViewRawMethod): ViewMethodEnum;
    static ViewStatus(): ViewMethodEnum;
    static ViewBlock(): ViewMethodEnum;
    static ViewTx(viewtx: ObjectId): ViewMethodEnum;
    static ViewContract(viewtx: ViewContract): ViewMethodEnum;
    static ViewBenefi(viewBenefi: ViewBenefi): ViewMethodEnum;
    static ViewLog(viewtx: ViewLog): ViewMethodEnum;
    static ViewNFTApplyBuyList(viewtx: ViewNFTBuyList): ViewMethodEnum;
    static ViewNFTBidList(viewtx: ViewNFTBuyList): ViewMethodEnum;
    static ViewNFTLargestBuy(viewtx: ObjectId): ViewMethodEnum;
    match<T>(visitor: {
        ViewBalance?: (viewbalance: ViewBalanceMethod) => T;
        ViewName?: (viewname: ViewNameMethod) => T;
        ViewDesc?: (viewdesc: ViewDescMethod) => T;
        ViewRaw?: (viewraw: ViewRawMethod) => T;
        ViewStatus?: () => T;
        ViewBlock?: () => T;
        ViewTx?: (viewtx: ObjectId) => T;
        ViewContract?: (tx: ViewContract) => T;
        ViewBenefi?: (tx: ViewBenefi) => T;
        ViewLog?: (tx: ViewLog) => T;
        ViewNFTApplyBuyList?: (tx: ViewNFTBuyList) => T;
        ViewNFTBidList?: (tx: ViewNFTBuyList) => T;
        ViewLargestBuy?: (tx: ObjectId) => T;
    }): T | undefined;
    eq_type(rhs: ViewMethodEnum): boolean;
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class ViewMethodEnumDecoder implements RawDecode<ViewMethodEnum> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[ViewMethodEnum, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class ViewRequest implements RawEncode {
    block: ViewBlockEnum;
    method: ViewMethodEnum;
    constructor(block: ViewBlockEnum, method: ViewMethodEnum);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class ViewRequestDecoder implements RawDecode<ViewRequest> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[ViewRequest, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class ViewResponse implements RawEncode {
    static ViewBalance(viewbalance: ViewBalanceResult): ViewResponse;
    static ViewName(viewname: ViewNameResult): ViewResponse;
    static ViewDesc(viewdesc: SavedMetaObject): ViewResponse;
    static ViewRaw(viewraw: Uint8Array): ViewResponse;
    static ViewStatus(viewstatus: ChainStatus): ViewResponse;
    static ViewBlock(viewblock: Block): ViewResponse;
    static ViewTx(viewtx: TxFullInfo): ViewResponse;
    static ViewContract(viewtx: ViewContractResult): ViewResponse;
    static ViewBenefi(viewtx: ViewBenefiResult): ViewResponse;
    static ViewLog(viewtx: ViewLogResult): ViewResponse;
    static ViewNFTApplyBuyList(viewtx: ViewNFTBuyListResult): ViewResponse;
    static ViewNFTBidList(viewtx: ViewNFTBuyListResult): ViewResponse;
    static ViewNFTLargestBuy(viewtx: NFTLargestBuyValue): ViewResponse;
    match<T>(visitor: {
        ViewBalance?: (viewbalance: ViewBalanceResult) => T;
        ViewName?: (viewname: ViewNameResult) => T;
        ViewDesc?: (viewdesc: SavedMetaObject) => T;
        ViewRaw?: (viewraw: Uint8Array) => T;
        ViewStatus?: (viewstatus: ChainStatus) => T;
        ViewBlock?: (viewblock: Block) => T;
        ViewTx?: (viewtx: TxFullInfo) => T;
        ViewContract?: (viewtx: ViewContractResult) => T;
        ViewBenefi?: (viewtx: ViewBenefiResult) => T;
        ViewLog?: (viewtx: ViewLogResult) => T;
        ViewApplyBuyList?: (viewtx: ViewNFTBuyListResult) => T;
        ViewBidList?: (viewtx: ViewNFTBuyListResult) => T;
        ViewLargestBuy?: (viewtx: NFTLargestBuyValue) => T;
    }): T | undefined;
    eq_type(rhs: ViewResponse): boolean;
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class ViewResponseDecoder implements RawDecode<ViewResponse> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[ViewResponse, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class ViewBalanceMethod implements RawEncode {
    account: ObjectId;
    ctid: CoinTokenId[];
    constructor(account: ObjectId, ctid: CoinTokenId[]);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class ViewBalanceMethodDecoder implements RawDecode<ViewBalanceMethod> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[ViewBalanceMethod, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class ViewDescMethod implements RawEncode {
    id: ObjectId;
    constructor(id: ObjectId);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class ViewDescMethodDecoder implements RawDecode<ViewDescMethod> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[ViewDescMethod, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class ViewNameMethod implements RawEncode {
    name: string;
    constructor(name: string);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class ViewNameMethodDecoder implements RawDecode<ViewNameMethod> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[ViewNameMethod, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class ViewRawMethod implements RawEncode {
    id: ObjectId;
    constructor(id: ObjectId);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class ViewRawMethodDecoder implements RawDecode<ViewRawMethod> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[ViewRawMethod, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class ViewBalanceResult implements RawEncode {
    static Single(single: ViewSingleBalanceResult): ViewBalanceResult;
    static Union(union: ViewUnionBalanceResult): ViewBalanceResult;
    match<T>(visitor: {
        Single?: (single: ViewSingleBalanceResult) => T;
        Union?: (union: ViewUnionBalanceResult) => T;
    }): T | undefined;
    eq_type(rhs: ViewBalanceResult): boolean;
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class ViewBalanceResultDecoder implements RawDecode<ViewBalanceResult> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[ViewBalanceResult, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class ViewNameResult implements RawEncode {
    results: Option<ViewNameResultItem>;
    constructor(results: Option<ViewNameResultItem>);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class ViewNameResultDecoder implements RawDecode<ViewNameResult> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[ViewNameResult, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class ViewNameResultItem implements RawEncode {
    name_info: NameInfo;
    name_state: NameState;
    constructor(name_info: NameInfo, name_state: NameState);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class ViewNameResultItemDecoder implements RawDecode<ViewNameResultItem> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[ViewNameResultItem, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class ViewSingleBalanceResult implements RawEncode {
    results: ViewSingleBalanceResultItem[];
    constructor(results: ViewSingleBalanceResultItem[]);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class ViewSingleBalanceResultDecoder implements RawDecode<ViewSingleBalanceResult> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[ViewSingleBalanceResult, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class ViewSingleBalanceResultItem implements RawEncode {
    id: CoinTokenId;
    result: JSBI;
    constructor(id: CoinTokenId, result: JSBI);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class ViewSingleBalanceResultItemDecoder implements RawDecode<ViewSingleBalanceResultItem> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[ViewSingleBalanceResultItem, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class ViewUnionBalanceResult implements RawEncode {
    results: ViewUnionBalanceResultItem[];
    constructor(results: ViewUnionBalanceResultItem[]);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class ViewUnionBalanceResultDecoder implements RawDecode<ViewUnionBalanceResult> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[ViewUnionBalanceResult, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class ViewUnionBalanceResultItem implements RawEncode {
    id: CoinTokenId;
    union_balance: UnionBalance;
    result: JSBI;
    constructor(id: CoinTokenId, union_balance: UnionBalance, result: JSBI);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class ViewUnionBalanceResultItemDecoder implements RawDecode<ViewUnionBalanceResultItem> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[ViewUnionBalanceResultItem, Uint8Array]>;
}

export class TextObjectDescTypeInfo extends DescTypeInfo {
    obj_type(): number;
    sub_desc_type(): SubDescType;
}
export class TextObjectDescContent extends ProtobufDescContent {
    id: string;
    header: string;
    constructor(id: string, header: string);
    type_info(): DescTypeInfo;
    set_id(id: string): void;
    set_header(header: string): void;
    try_to_proto(): BuckyResult<protos.TextDescContent>;
}
export class TextObjectDescContentDecoder extends ProtobufDescContentDecoder<TextObjectDescContent, protos.TextDescContent> {
    constructor();
    type_info(): DescTypeInfo;
    try_from_proto(value: protos.TextDescContent): BuckyResult<TextObjectDescContent>;
}
export class TextObjectBodyContent extends ProtobufBodyContent {
    value: string;
    constructor(value: string);
    set_value(value: string): void;
    try_to_proto(): BuckyResult<protos.TextContent>;
}
export class TextObjectBodyContentDecoder extends ProtobufBodyContentDecoder<TextObjectBodyContent, protos.TextContent> {
    constructor();
    try_from_proto(value: protos.TextContent): BuckyResult<TextObjectBodyContent>;
}
export class TextObjectDesc extends NamedObjectDesc<TextObjectDescContent> {
}
export class TextObjectDescDecoder extends NamedObjectDescDecoder<TextObjectDescContent> {
}
export class TextObjectBuilder extends NamedObjectBuilder<TextObjectDescContent, TextObjectBodyContent> {
}
export class TextObjectId extends NamedObjectId<TextObjectDescContent, TextObjectBodyContent> {
    constructor(id: ObjectId);
    static default(): TextObjectId;
    static from_base_58(s: string): BuckyResult<TextObjectId>;
    static try_from_object_id(id: ObjectId): BuckyResult<TextObjectId>;
}
export class TextObjectIdDecoder extends NamedObjectIdDecoder<TextObjectDescContent, TextObjectBodyContent> {
    constructor();
}
export class TextObject extends NamedObject<TextObjectDescContent, TextObjectBodyContent> {
    static build(owner: Option<ObjectId>, id: string, header: string, value: string): TextObjectBuilder;
    static create(owner: Option<ObjectId>, id: string, header: string, value: string): TextObject;
    get id(): string;
    get header(): string;
    get value(): string;
    set value(value: string);
}
export class TextObjectDecoder extends NamedObjectDecoder<TextObjectDescContent, TextObjectBodyContent, TextObject> {
    constructor();
    static create(): TextObjectDecoder;
}

export class FriendListDescTypeInfo extends DescTypeInfo {
    obj_type(): number;
    sub_desc_type(): SubDescType;
}
export class FriendListDescContent extends ProtobufDescContent {
    try_to_proto(): BuckyResult<base_proto.EmptyContent>;
    constructor();
    type_info(): DescTypeInfo;
}
export class FriendListDescContentDecoder extends ProtobufDescContentDecoder<FriendListDescContent, base_proto.EmptyContent> {
    try_from_proto(value: base_proto.EmptyContent): BuckyResult<FriendListDescContent>;
    type_info(): DescTypeInfo;
    constructor();
}
export class FriendContent implements RawEncode {
    raw_measure(ctx?: any, purpose?: RawEncodePurpose): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any, purpose?: RawEncodePurpose): BuckyResult<Uint8Array>;
}
export class FriendListBodyContent extends ProtobufBodyContent {
    friends: BuckyHashMap<ObjectId, FriendContent>;
    auto_confirm: boolean;
    auto_msg: string;
    try_to_proto(): BuckyResult<protos.FriendListContent>;
    constructor(friends: BuckyHashMap<ObjectId, FriendContent>, auto_confirm: boolean, auto_msg: string);
}
export class FriendListBodyContentDecoder extends ProtobufBodyContentDecoder<FriendListBodyContent, protos.FriendListContent> {
    try_from_proto(value: protos.FriendListContent): BuckyResult<FriendListBodyContent>;
    constructor();
}
export class FriendListDesc extends NamedObjectDesc<FriendListDescContent> {
}
export class FriendListDescDecoder extends NamedObjectDescDecoder<FriendListDescContent> {
}
export class FriendListBuilder extends NamedObjectBuilder<FriendListDescContent, FriendListBodyContent> {
}
export class FriendListId extends NamedObjectId<FriendListDescContent, FriendListBodyContent> {
    constructor(id: ObjectId);
    static default(): FriendListId;
    static from_base_58(s: string): BuckyResult<FriendListId>;
    static try_from_object_id(id: ObjectId): BuckyResult<FriendListId>;
}
export class FriendListIdDecoder extends NamedObjectIdDecoder<FriendListDescContent, FriendListBodyContent> {
    constructor();
}
export class FriendList extends NamedObject<FriendListDescContent, FriendListBodyContent> {
    static create(owner: PeopleId, auto_confirm: boolean): FriendList;
    friend_list(): BuckyHashMap<ObjectId, FriendContent>;
    auto_confirm(): boolean;
    auto_msg(): string;
    set_auto_confirm(auto_confirm: boolean): void;
    set_auto_msg(auto_msg: string): void;
}
export class FriendListDecoder extends NamedObjectDecoder<FriendListDescContent, FriendListBodyContent, FriendList> {
    constructor();
}

export class StorageDescTypeInfo extends DescTypeInfo {
    obj_type(): number;
    sub_desc_type(): SubDescType;
}
export class StorageDescContent extends ProtobufDescContent {
    constructor(id: string);
    id(): string;
    type_info(): DescTypeInfo;
    try_to_proto(): BuckyResult<protos.StorageDescContent>;
}
export class StorageDescContentDecoder extends ProtobufDescContentDecoder<StorageDescContent, protos.StorageDescContent> {
    constructor();
    type_info(): DescTypeInfo;
    try_from_proto(value: protos.StorageDescContent): BuckyResult<StorageDescContent>;
}
export class StorageBodyContent extends ProtobufBodyContent {
    constructor(value: Uint8Array);
    value(): Uint8Array;
    try_to_proto(): BuckyResult<protos.StorageBodyContent>;
}
export class StorageBodyContentDecoder extends ProtobufBodyContentDecoder<StorageBodyContent, protos.StorageBodyContent> {
    constructor();
    try_from_proto(value: protos.StorageBodyContent): BuckyResult<StorageBodyContent>;
}
export class StorageDesc extends NamedObjectDesc<StorageDescContent> {
}
export class StorageDescDecoder extends NamedObjectDescDecoder<StorageDescContent> {
}
export class StorageBuilder extends NamedObjectBuilder<StorageDescContent, StorageBodyContent> {
}
export class StorageId extends NamedObjectId<StorageDescContent, StorageBodyContent> {
    constructor(id: ObjectId);
    static default(): DeviceId;
    static from_base_58(s: string): BuckyResult<DeviceId>;
    static try_from_object_id(id: ObjectId): BuckyResult<DeviceId>;
}
export class StorageIdDecoder extends NamedObjectIdDecoder<StorageDescContent, StorageBodyContent> {
    constructor();
}
export class Storage extends NamedObject<StorageDescContent, StorageBodyContent> {
    static create(id: string, value: Uint8Array): Storage;
    id(): string;
    value(): Uint8Array;
    storage_id(): StorageId;
}
export class StorageDecoder extends NamedObjectDecoder<StorageDescContent, StorageBodyContent, Storage> {
    constructor();
}

export class ZoneDescTypeInfo extends DescTypeInfo {
    obj_type(): number;
    sub_desc_type(): SubDescType;
}
export class ZoneDescContent extends ProtobufDescContent {
    constructor(owner: ObjectId);
    type_info(): DescTypeInfo;
    try_to_proto(): BuckyResult<protos.ZoneDescContent>;
    owner(): ObjectId;
}
export class ZoneDescContentDecoder extends ProtobufDescContentDecoder<ZoneDescContent, protos.ZoneDescContent> {
    constructor();
    type_info(): DescTypeInfo;
    try_from_proto(value: protos.ZoneDescContent): BuckyResult<ZoneDescContent>;
}
export class ZoneBodyContent extends ProtobufBodyContent {
    constructor(ood_work_mode: OODWorkMode, ood_list: DeviceId[], known_device_list: DeviceId[]);
    ood_work_mode(): OODWorkMode;
    ood_list(): DeviceId[];
    known_device_list(): DeviceId[];
    try_to_proto(): BuckyResult<protos.ZoneBodyContent>;
}
export class ZoneBodyContentDecoder extends ProtobufBodyContentDecoder<ZoneBodyContent, protos.ZoneBodyContent> {
    constructor();
    try_from_proto(value: protos.ZoneBodyContent): BuckyResult<ZoneBodyContent>;
}
export class ZoneDesc extends NamedObjectDesc<ZoneDescContent> {
}
export class ZoneDescDecoder extends NamedObjectDescDecoder<ZoneDescContent> {
}
export class ZoneBuilder extends NamedObjectBuilder<ZoneDescContent, ZoneBodyContent> {
}
export class ZoneId extends NamedObjectId<ZoneDescContent, ZoneBodyContent> {
    constructor(id: ObjectId);
    static default(): DeviceId;
    static from_base_58(s: string): BuckyResult<DeviceId>;
    static try_from_object_id(id: ObjectId): BuckyResult<DeviceId>;
}
export class ZoneIdDecoder extends NamedObjectIdDecoder<ZoneDescContent, ZoneBodyContent> {
    constructor();
}
export class Zone extends NamedObject<ZoneDescContent, ZoneBodyContent> {
    static create(owner: ObjectId, ood_work_mode: OODWorkMode, ood_list: DeviceId[], known_device_list: DeviceId[]): Zone;
    ood_work_mode(): OODWorkMode;
    owner(): ObjectId;
    ood_list(): DeviceId[];
    known_device_list(): DeviceId[];
    zone_id(): ZoneId;
}
export class ZoneDecoder extends NamedObjectDecoder<ZoneDescContent, ZoneBodyContent, Zone> {
    constructor();
}

export const APPLIST_APP_CATEGORY = "app";
export const APPLIST_SERVICE_CATEGORY = "service";
export class AppListDescTypeInfo extends DescTypeInfo {
    obj_type(): number;
    sub_desc_type(): SubDescType;
}
export class AppListDescContent extends ProtobufDescContent {
    id: string;
    category: string;
    constructor(id: string, category: string);
    type_info(): DescTypeInfo;
    try_to_proto(): BuckyResult<protos.AppListDescContent>;
}
export class AppListDescContentDecoder extends ProtobufDescContentDecoder<AppListDescContent, protos.AppListDescContent> {
    constructor();
    type_info(): DescTypeInfo;
    try_from_proto(value: protos.AppListDescContent): BuckyResult<AppListDescContent>;
}
export class AppListBodyContent extends ProtobufBodyContent {
    app_list: BuckyHashMap<DecAppId, AppStatus>;
    constructor(apps: BuckyHashMap<DecAppId, AppStatus>);
    try_to_proto(): BuckyResult<protos.AppListContent>;
}
export class AppListBodyContentDecoder extends ProtobufBodyContentDecoder<AppListBodyContent, protos.AppListContent> {
    constructor();
    try_from_proto(value: protos.AppListContent): BuckyResult<AppListBodyContent>;
}
export class AppListDesc extends NamedObjectDesc<AppListDescContent> {
}
export class AppListDescDecoder extends NamedObjectDescDecoder<AppListDescContent> {
}
export class AppListBuilder extends NamedObjectBuilder<AppListDescContent, AppListBodyContent> {
}
export class AppListId extends NamedObjectId<AppListDescContent, AppListBodyContent> {
    constructor(id: ObjectId);
    static default(): AppListId;
    static from_base_58(s: string): BuckyResult<AppListId>;
    static try_from_object_id(id: ObjectId): BuckyResult<AppListId>;
}
export class AppListIdDecoder extends NamedObjectIdDecoder<AppListDescContent, AppListBodyContent> {
    constructor();
}
export class AppList extends NamedObject<AppListDescContent, AppListBodyContent> {
    static create(owner: ObjectId, id: string, category: string): AppList;
    put(app: AppStatus): void;
    remove(id: DecAppId): void;
    clear(): void;
    app_list(): Map<DecAppId, AppStatus>;
    exists(id: DecAppId): boolean;
}
export class AppListDecoder extends NamedObjectDecoder<AppListDescContent, AppListBodyContent, AppList> {
    constructor();
    static create(): AppListDecoder;
}

export const APP_LOCAL_LIST_CATEGORY_APP = "app";
export const APP_LOCAL_LIST_PATH = "/app_local_list";
export class AppLocalListDescTypeInfo extends DescTypeInfo {
    obj_type(): number;
    sub_desc_type(): SubDescType;
}
export class AppLocalListDescContent extends ProtobufDescContent {
    id: string;
    app_list: BuckyHashSet<DecAppId>;
    constructor(id: string, app_list: BuckyHashSet<DecAppId>);
    type_info(): DescTypeInfo;
    try_to_proto(): BuckyResult<protos.AppLocalListDesc>;
}
export class AppLocalListDescContentDecoder extends ProtobufDescContentDecoder<AppLocalListDescContent, protos.AppLocalListDesc> {
    constructor();
    type_info(): DescTypeInfo;
    try_from_proto(value: protos.AppLocalListDesc): BuckyResult<AppLocalListDescContent>;
}
export class AppLocalListBuilder extends NamedObjectBuilder<AppLocalListDescContent, EmptyProtobufBodyContent> {
}
export class AppLocalListId extends NamedObjectId<AppLocalListDescContent, EmptyProtobufBodyContent> {
    constructor(id: ObjectId);
    static default(): AppLocalListId;
    static from_base_58(s: string): BuckyResult<AppLocalListId>;
    static try_from_object_id(id: ObjectId): BuckyResult<AppLocalListId>;
}
export class AppLocalListIdDecoder extends NamedObjectIdDecoder<AppLocalListDescContent, EmptyProtobufBodyContent> {
    constructor();
}
export class AppLocalList extends NamedObject<AppLocalListDescContent, EmptyProtobufBodyContent> {
    static create(owner: ObjectId, id: string): AppLocalList;
    insert(id: DecAppId): void;
    remove(id: DecAppId): void;
    clear(): void;
    app_list(): BuckyHashSet<DecAppId>;
    id(): string;
    exists(id: DecAppId): boolean;
}
export class AppLocalListDecoder extends NamedObjectDecoder<AppLocalListDescContent, EmptyProtobufBodyContent, AppLocalList> {
    constructor();
    static create(): AppLocalListDecoder;
}

export class AppSettingDescTypeInfo extends DescTypeInfo {
    obj_type(): number;
    sub_desc_type(): SubDescType;
}
export class AppSettingDesc extends ProtobufDescContent {
    id: DecAppId;
    auto_update: boolean;
    constructor(id: DecAppId, auto_update: boolean);
    type_info(): DescTypeInfo;
    try_to_proto(): BuckyResult<protos.AppSettingDesc>;
}
export class AppSettingDescDecoder extends ProtobufDescContentDecoder<AppSettingDesc, protos.AppSettingDesc> {
    constructor();
    type_info(): DescTypeInfo;
    try_from_proto(value: protos.AppSettingDesc): BuckyResult<AppSettingDesc>;
}
export class AppSettingBuilder extends NamedObjectBuilder<AppSettingDesc, EmptyProtobufBodyContent> {
}
export class AppSettingId extends NamedObjectId<AppSettingDesc, EmptyProtobufBodyContent> {
    constructor(id: ObjectId);
    static default(): AppSettingId;
    static from_base_58(s: string): BuckyResult<AppSettingId>;
    static try_from_object_id(id: ObjectId): BuckyResult<AppSettingId>;
}
export class AppSettingIdDecoder extends NamedObjectIdDecoder<AppSettingDesc, EmptyProtobufBodyContent> {
    constructor();
}
export class AppSetting extends NamedObject<AppSettingDesc, EmptyProtobufBodyContent> {
    static create(owner: ObjectId, id: DecAppId): AppSetting;
    app_id(): DecAppId;
    auto_update(): boolean;
    set_auto_update(auto_update: boolean): void;
}
export class AppSettingDecoder extends NamedObjectDecoder<AppSettingDesc, EmptyProtobufBodyContent, AppSetting> {
    constructor();
    static create(): AppSettingDecoder;
}

export class AppStatusDescTypeInfo extends DescTypeInfo {
    obj_type(): number;
    sub_desc_type(): SubDescType;
}
export class AppStatusDescContent extends ProtobufDescContent {
    id: DecAppId;
    constructor(id: DecAppId);
    type_info(): DescTypeInfo;
    try_to_proto(): BuckyResult<protos.AppStatusDescContent>;
}
export class AppStatusDescContentDecoder extends ProtobufDescContentDecoder<AppStatusDescContent, protos.AppStatusDescContent> {
    constructor();
    type_info(): DescTypeInfo;
    try_from_proto(value: protos.AppStatusDescContent): BuckyResult<AppStatusDescContent>;
}
export class AppStatusBodyContent extends ProtobufBodyContent {
    version: string;
    status: number;
    constructor(version: string, status: number);
    try_to_proto(): BuckyResult<protos.AppStatusContent>;
}
export class AppStatusBodyContentDecoder extends ProtobufBodyContentDecoder<AppStatusBodyContent, protos.AppStatusContent> {
    constructor();
    try_from_proto(value: protos.AppStatusContent): BuckyResult<AppStatusBodyContent>;
}
export class AppStatusDesc extends NamedObjectDesc<AppStatusDescContent> {
}
export class AppStatusDescDecoder extends NamedObjectDescDecoder<AppStatusDescContent> {
}
export class AppStatusBuilder extends NamedObjectBuilder<AppStatusDescContent, AppStatusBodyContent> {
}
export class AppStatusId extends NamedObjectId<AppStatusDescContent, AppStatusBodyContent> {
    constructor(id: ObjectId);
    static default(): AppStatusId;
    static from_base_58(s: string): BuckyResult<AppStatusId>;
    static try_from_object_id(id: ObjectId): BuckyResult<AppStatusId>;
}
export class AppStatusIdDecoder extends NamedObjectIdDecoder<AppStatusDescContent, AppStatusBodyContent> {
    constructor();
}
export class AppStatus extends NamedObject<AppStatusDescContent, AppStatusBodyContent> {
    static create(owner: ObjectId, id: DecAppId, version: string, status: boolean): AppStatus;
    app_id(): DecAppId;
    version(): string;
    status(): boolean;
}
export class AppStatusDecoder extends NamedObjectDecoder<AppStatusDescContent, AppStatusBodyContent, AppStatus> {
    constructor();
    static create(): AppStatusDecoder;
}

export const APP_LOCAL_STATUS_MAIN_PATH = "/app_local_status";
export class AppLocalStatusDescTypeInfo extends DescTypeInfo {
    obj_type(): number;
    sub_desc_type(): SubDescType;
}
export enum AppLocalStatusCode {
    Init = 0,
    Installing = 1,
    InstallFailed = 3,
    NoService = 4,
    Stopping = 5,
    Stop = 6,
    StopFailed = 7,
    Starting = 8,
    Running = 9,
    StartFailed = 10,
    Uninstalling = 11,
    UninstallFailed = 12,
    Uninstalled = 13,
    RunException = 15,
    ErrStatus = 255
}
export enum SubErrorCode {
    None = 0,
    Incompatible = 1,
    NoVersion = 2,
    DownloadFailed = 3,
    DockerFailed = 4,
    CommondFailed = 5,
    AppNotFound = 6,
    QueryPermissionError = 7,
    LoadFailed = 8,
    RemoveFailed = 9,
    AssignContainerIpFailed = 10,
    RegisterAppFailed = 11,
    PubDirFailed = 12,
    Unknown = 255
}
export enum PermissionState {
    Unhandled = 0,
    Blocked = 1,
    Granted = 2
}
export class PermissionNode implements RawEncode {
    reason: BuckyString;
    state: PermissionState;
    constructor(reason: BuckyString, /*allow: number,*/ state: PermissionState);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class AppLocalStatusDesc extends ProtobufDescContent {
    id: DecAppId;
    status: AppLocalStatusCode;
    last_status_update_time: JSBI;
    permissions: BuckyHashMap<BuckyString, PermissionNode>;
    quota: AppQuota;
    version?: string;
    web_dir?: ObjectId;
    sub_error: SubErrorCode;
    constructor(id: DecAppId, status: AppLocalStatusCode, permissions: BuckyHashMap<BuckyString, PermissionNode>, quota: AppQuota, last_status_update_time?: JSBI, version?: string, web_dir?: ObjectId, sub_error?: SubErrorCode);
    type_info(): DescTypeInfo;
    try_to_proto(): BuckyResult<protos.AppLocalStatusDesc>;
}
export class AppLocalStatusDescDecoder extends ProtobufDescContentDecoder<AppLocalStatusDesc, protos.AppLocalStatusDesc> {
    constructor();
    type_info(): DescTypeInfo;
    try_from_proto(value: protos.AppLocalStatusDesc): BuckyResult<AppLocalStatusDesc>;
}
export class AppLocalStatusBuilder extends NamedObjectBuilder<AppLocalStatusDesc, EmptyProtobufBodyContent> {
}
export class AppLocalStatusId extends NamedObjectId<AppLocalStatusDesc, EmptyProtobufBodyContent> {
    constructor(id: ObjectId);
    static default(): AppLocalStatusId;
    static from_base_58(s: string): BuckyResult<AppLocalStatusId>;
    static try_from_object_id(id: ObjectId): BuckyResult<AppLocalStatusId>;
}
export class AppLocalStatusIdDecoder extends NamedObjectIdDecoder<AppLocalStatusDesc, EmptyProtobufBodyContent> {
    constructor();
}
export class AppLocalStatus extends NamedObject<AppLocalStatusDesc, EmptyProtobufBodyContent> {
    static create(owner: ObjectId, id: DecAppId): AppLocalStatus;
    app_id(): DecAppId;
    webdir(): ObjectId | undefined;
    status(): AppLocalStatusCode;
    version(): string | undefined;
    permissions(): BuckyHashMap<BuckyString, PermissionNode>;
    permission_unhandled(): BuckyHashMap<BuckyString, PermissionNode>;
    sub_error(): SubErrorCode;
    quota(): AppQuota;
    last_status_update_time(): JSBI;
    static generate_id(owner: ObjectId, id: DecAppId): ObjectId;
}
export class AppLocalStatusDecoder extends NamedObjectDecoder<AppLocalStatusDesc, EmptyProtobufBodyContent, AppLocalStatus> {
    constructor();
    static create(): AppLocalStatusDecoder;
}

export class AppStoreListDescTypeInfo extends DescTypeInfo {
    obj_type(): number;
    sub_desc_type(): SubDescType;
}
export class AppStoreListDescContent extends DescContent {
    constructor();
    type_info(): DescTypeInfo;
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
}
export class AppStoreListDescContentDecoder extends DescContentDecoder<AppStoreListDescContent> {
    type_info(): DescTypeInfo;
    raw_decode(buf: Uint8Array): BuckyResult<[AppStoreListDescContent, Uint8Array]>;
}
export class AppStoreListBodyContent extends ProtobufBodyContent {
    app_store_list: BuckyHashSet<DecAppId>;
    constructor(list: BuckyHashSet<DecAppId>);
    try_to_proto(): BuckyResult<protos.AppStoreListBodyContent>;
}
export class AppStoreListBodyContentDecoder extends ProtobufBodyContentDecoder<AppStoreListBodyContent, protos.AppStoreListBodyContent> {
    constructor();
    try_from_proto(value: protos.AppStoreListBodyContent): BuckyResult<AppStoreListBodyContent>;
}
export class AppStoreListDesc extends NamedObjectDesc<AppStoreListDescContent> {
}
export class AppStoreListDescDecoder extends NamedObjectDescDecoder<AppStoreListDescContent> {
}
export class AppStoreListBuilder extends NamedObjectBuilder<AppStoreListDescContent, AppStoreListBodyContent> {
}
export class AppStoreListId extends NamedObjectId<AppStoreListDescContent, AppStoreListBodyContent> {
    constructor(id: ObjectId);
    static default(): AppStoreListId;
    static from_base_58(s: string): BuckyResult<AppStoreListId>;
    static try_from_object_id(id: ObjectId): BuckyResult<AppStoreListId>;
}
export class AppStoreListIdDecoder extends NamedObjectIdDecoder<AppStoreListDescContent, AppStoreListBodyContent> {
    constructor();
}
export class AppStoreList extends NamedObject<AppStoreListDescContent, AppStoreListBodyContent> {
    static create(owner: ObjectId): AppStoreList;
    put(id: DecAppId): void;
    remove(id: DecAppId): void;
    clear(): void;
    app_list(): DecAppId[];
}
export class AppStoreListDecoder extends NamedObjectDecoder<AppStoreListDescContent, AppStoreListBodyContent, AppStoreList> {
    constructor();
    static create(): AppStoreListDecoder;
}

export class AppCmdDescTypeInfo extends DescTypeInfo {
    obj_type(): number;
    sub_desc_type(): SubDescType;
}
class AddApp {
    app_owner_id?: ObjectId | undefined;
    constructor(app_owner_id?: ObjectId | undefined);
    try_to_proto(): BuckyResult<protos.AddApp>;
    static try_from_proto(value: protos.AddApp): BuckyResult<AddApp>;
}
class InstallApp {
    ver: string;
    run_after_install: boolean;
    constructor(ver: string, run_after_install: boolean);
    try_to_proto(): BuckyResult<protos.InstallApp>;
    static try_from_proto(value: protos.InstallApp): BuckyResult<InstallApp>;
}
class ModifyAppPermission {
    permission: Map<string, boolean>;
    constructor(permission: Map<string, boolean>);
    try_to_proto(): BuckyResult<protos.ModifyAppPermission>;
    static try_from_proto(value: protos.ModifyAppPermission): BuckyResult<ModifyAppPermission>;
}
export enum AppQuotaType {
    Mem = 0,
    DiskSpace = 1,
    Cpu = 2,
    Unknown = 255
}
export class AppQuota {
    mem: JSBI;
    disk_space: JSBI;
    cpu: JSBI;
    constructor(mem: JSBI, disk_space: JSBI, cpu: JSBI);
    static from(quotas: Map<AppQuotaType, JSBI>): AppQuota;
    to(): Map<AppQuotaType, JSBI>;
    try_to_proto(): BuckyResult<protos.AppQuota>;
    static try_from_proto(value: protos.AppQuota): BuckyResult<AppQuota>;
}
class CmdCode {
    code: AppCmdCode;
    add?: AddApp | undefined;
    install?: InstallApp | undefined;
    permission?: ModifyAppPermission | undefined;
    qupta?: AppQuota | undefined;
    constructor(code: AppCmdCode, add?: AddApp | undefined, install?: InstallApp | undefined, permission?: ModifyAppPermission | undefined, qupta?: AppQuota | undefined);
    try_to_proto(): BuckyResult<protos.CmdCode>;
    static try_from_proto(value: protos.CmdCode): BuckyResult<CmdCode>;
}
export class AppCmdDesc extends ProtobufDescContent {
    app_id: DecAppId;
    cmd_code: CmdCode;
    constructor(app_id: DecAppId, cmd_code: CmdCode);
    type_info(): DescTypeInfo;
    try_to_proto(): BuckyResult<protos.AppCmdDesc>;
}
export class AppCmdDescDecoder extends ProtobufDescContentDecoder<AppCmdDesc, protos.AppCmdDesc> {
    constructor();
    type_info(): DescTypeInfo;
    try_from_proto(value: protos.AppCmdDesc): BuckyResult<AppCmdDesc>;
}
export enum AppCmdCode {
    Add = 0,
    Remove = 1,
    Install = 2,
    Uninstall = 3,
    Start = 4,
    Stop = 5,
    SetPermission = 6,
    SetQuota = 7,
    Unknown = 255
}
export class AppCmdBuilder extends NamedObjectBuilder<AppCmdDesc, EmptyProtobufBodyContent> {
}
export class AppCmdId extends NamedObjectId<AppCmdDesc, EmptyProtobufBodyContent> {
    constructor(id: ObjectId);
    static default(): AppCmdId;
    static from_base_58(s: string): BuckyResult<AppCmdId>;
    static try_from_object_id(id: ObjectId): BuckyResult<AppCmdId>;
}
export class AppCmdIdDecoder extends NamedObjectIdDecoder<AppCmdDesc, EmptyProtobufBodyContent> {
    constructor();
}
export class AppCmd extends NamedObject<AppCmdDesc, EmptyProtobufBodyContent> {
    static create(owner: ObjectId, id: DecAppId, code: CmdCode): AppCmd;
    static add(owner: ObjectId, id: DecAppId, app_owner?: ObjectId): AppCmd;
    static remove(owner: ObjectId, id: DecAppId): AppCmd;
    static install(owner: ObjectId, id: DecAppId, version: string, run_after_install: boolean): AppCmd;
    static uninstall(owner: ObjectId, id: DecAppId): AppCmd;
    static start(owner: ObjectId, id: DecAppId): AppCmd;
    static stop(owner: ObjectId, id: DecAppId): AppCmd;
    static set_permission(owner: ObjectId, id: DecAppId, permission: Map<string, boolean>): AppCmd;
    static set_quota(owner: ObjectId, id: DecAppId, quota: Map<AppQuotaType, JSBI>): AppCmd;
    app_id(): DecAppId;
    cmd(): AppCmdCode;
}
export class AppCmdDecoder extends NamedObjectDecoder<AppCmdDesc, EmptyProtobufBodyContent, AppCmd> {
    constructor();
    static create(): AppCmdDecoder;
}
export {};

export class DecAppDescTypeInfo extends DescTypeInfo {
    obj_type(): number;
    sub_desc_type(): SubDescType;
}
export class DecAppDescContent extends ProtobufDescContent {
    id: string;
    constructor(id: string);
    type_info(): DescTypeInfo;
    try_to_proto(): BuckyResult<protos.DecAppDescContent>;
}
export class DecAppDescContentDecoder extends ProtobufDescContentDecoder<DecAppDescContent, protos.DecAppDescContent> {
    constructor();
    type_info(): DescTypeInfo;
    try_from_proto(value: protos.DecAppDescContent): BuckyResult<DecAppDescContent>;
}
export class DecAppBodyContent extends ProtobufBodyContent {
    source: BuckyHashMap<BuckyString, ObjectId>;
    icon: Option<BuckyString>;
    desc: Option<BuckyString>;
    source_desc: BuckyHashMap<BuckyString, BuckyString>;
    tags: BuckyHashMap<BuckyString, BuckyString>;
    constructor(source: BuckyHashMap<BuckyString, ObjectId>, icon: Option<BuckyString>, desc: Option<BuckyString>, source_desc: BuckyHashMap<BuckyString, BuckyString>, tags: BuckyHashMap<BuckyString, BuckyString>);
    try_to_proto(): BuckyResult<protos.DecAppContent>;
}
export class DecAppBodyContentDecoder extends ProtobufBodyContentDecoder<DecAppBodyContent, protos.DecAppContent> {
    constructor();
    try_from_proto(value: protos.DecAppContent): BuckyResult<DecAppBodyContent>;
}
export class DecAppDesc extends NamedObjectDesc<DecAppDescContent> {
}
export class DecAppDescDecoder extends NamedObjectDescDecoder<DecAppDescContent> {
}
export class DecAppBuilder extends NamedObjectBuilder<DecAppDescContent, DecAppBodyContent> {
}
export class DecAppId extends NamedObjectId<DecAppDescContent, DecAppBodyContent> {
    constructor(id: ObjectId);
    static default(): DecAppId;
    static from_base_58(s: string): BuckyResult<DecAppId>;
    static try_from_object_id(id: ObjectId): BuckyResult<DecAppId>;
}
export class DecAppIdDecoder extends NamedObjectIdDecoder<DecAppDescContent, DecAppBodyContent> {
    constructor();
}
export class DecApp extends NamedObject<DecAppDescContent, DecAppBodyContent> {
    static create(owner: ObjectId, id: string): DecApp;
    name(): string;
    set_icon(icon: string | undefined): void;
    icon(): string | undefined;
    set_app_desc(desc: string | undefined): void;
    app_desc(): string | undefined;
    find_source_desc(version: string): BuckyResult<string>;
    find_source(version: string): BuckyResult<ObjectId>;
    remove_source(version: string): void;
    set_source(version: string, source: ObjectId, desc: Option<string>): void;
    source(): BuckyHashMap<BuckyString, ObjectId>;
    find_tag(tag: string): BuckyResult<string>;
    remove_tag(tag: string): void;
    set_tag(tag: string, version: string): void;
    tags(): BuckyHashMap<BuckyString, BuckyString>;
    static generate_id(owner: ObjectId, id: string): ObjectId;
}
export class DecAppDecoder extends NamedObjectDecoder<DecAppDescContent, DecAppBodyContent, DecApp> {
    constructor();
    static create(): DecAppDecoder;
}

export class AppExtInfoDescTypeInfo extends DescTypeInfo {
    obj_type(): number;
    sub_desc_type(): SubDescType;
}
export class AppExtInfoDescContent extends ProtobufDescContent {
    id: string;
    constructor(id: string);
    type_info(): DescTypeInfo;
    try_to_proto(): BuckyResult<protos.AppExtInfoDescContent>;
}
export class AppExtInfoDescContentDecoder extends ProtobufDescContentDecoder<AppExtInfoDescContent, protos.AppExtInfoDescContent> {
    constructor();
    type_info(): DescTypeInfo;
    try_from_proto(value: protos.AppExtInfoDescContent): BuckyResult<AppExtInfoDescContent>;
}
export class AppExtInfoBodyContent extends ProtobufBodyContent {
    info: string;
    constructor(info: string);
    try_to_proto(): BuckyResult<protos.AppExtInfoBodyContent>;
}
export class AppExtInfoBodyContentDecoder extends ProtobufBodyContentDecoder<AppExtInfoBodyContent, protos.AppExtInfoBodyContent> {
    constructor();
    try_from_proto(value: protos.AppExtInfoBodyContent): BuckyResult<AppExtInfoBodyContent>;
}
export class AppExtInfoDesc extends NamedObjectDesc<AppExtInfoDescContent> {
}
export class AppExtInfoDescDecoder extends NamedObjectDescDecoder<AppExtInfoDescContent> {
}
export class AppExtInfoBuilder extends NamedObjectBuilder<AppExtInfoDescContent, AppExtInfoBodyContent> {
}
export class AppExtInfoId extends NamedObjectId<AppExtInfoDescContent, AppExtInfoBodyContent> {
    constructor(id: ObjectId);
    static default(): AppExtInfoId;
    static from_base_58(s: string): BuckyResult<AppExtInfoId>;
    static try_from_object_id(id: ObjectId): BuckyResult<AppExtInfoId>;
}
export class AppExtInfoIdDecoder extends NamedObjectIdDecoder<AppExtInfoDescContent, AppExtInfoBodyContent> {
    constructor();
}
export class AppExtInfo extends NamedObject<AppExtInfoDescContent, AppExtInfoBodyContent> {
    static create(owner: ObjectId, id: string): AppExtInfo;
    static getExtId(app: DecApp): ObjectId;
    info(): string;
    set_info(info: string): void;
}
export class AppExtInfoDecoder extends NamedObjectDecoder<AppExtInfoDescContent, AppExtInfoBodyContent, AppExtInfo> {
    constructor();
    static create(): AppExtInfoDecoder;
}

export const SYSTEM_DEC_APP: DecAppId;
export function get_system_dec_app(): DecAppId;

export class NFTListDescTypeInfo extends DescTypeInfo {
    obj_type(): number;
    sub_desc_type(): SubDescType;
}
export class NFTListDescContent extends DescContent {
    constructor();
    type_info(): DescTypeInfo;
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
}
export class NFTListDescContentDecoder extends DescContentDecoder<NFTListDescContent> {
    type_info(): DescTypeInfo;
    raw_decode(buf: Uint8Array): BuckyResult<[NFTListDescContent, Uint8Array]>;
}
export class NFTListBodyContent extends BodyContent {
    obj_list: BuckyHashMap<ObjectId, BuckyString>;
    constructor(list: BuckyHashMap<ObjectId, BuckyString>);
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
}
export class NFTListBodyContentDecoder extends BodyContentDecoder<NFTListBodyContent> {
    raw_decode(buf: Uint8Array): BuckyResult<[NFTListBodyContent, Uint8Array]>;
}
export class NFTListDesc extends NamedObjectDesc<NFTListDescContent> {
}
export class NFTListDescDecoder extends NamedObjectDescDecoder<NFTListDescContent> {
}
export class NFTListBuilder extends NamedObjectBuilder<NFTListDescContent, NFTListBodyContent> {
}
export class NFTListId extends NamedObjectId<NFTListDescContent, NFTListBodyContent> {
    constructor(id: ObjectId);
    static default(): NFTListId;
    static from_base_58(s: string): BuckyResult<NFTListId>;
    static try_from_object_id(id: ObjectId): BuckyResult<NFTListId>;
}
export class NFTListIdDecoder extends NamedObjectIdDecoder<NFTListDescContent, NFTListBodyContent> {
    constructor();
}
export class NFTList extends NamedObject<NFTListDescContent, NFTListBodyContent> {
    static create(owner: ObjectId): NFTList;
    put(id: ObjectId, comment: BuckyString): void;
    remove(id: ObjectId): void;
    clear(): void;
    obj_list(): Map<ObjectId, BuckyString>;
}
export class NFTListDecoder extends NamedObjectDecoder<NFTListDescContent, NFTListBodyContent, NFTList> {
    constructor();
    static create(): NFTListDecoder;
}

export class AddFriendDescTypeInfo extends DescTypeInfo {
    obj_type(): number;
    sub_desc_type(): SubDescType;
}
export class AddFriendDescContent extends ProtobufDescContent {
    to: PeopleId;
    try_to_proto(): BuckyResult<protos.AddFriendDescContent>;
    constructor(to: PeopleId);
    type_info(): DescTypeInfo;
}
export class AddFriendDescContentDecoder extends ProtobufDescContentDecoder<AddFriendDescContent, protos.AddFriendDescContent> {
    constructor();
    try_from_proto(value: protos.AddFriendDescContent): BuckyResult<AddFriendDescContent>;
    type_info(): DescTypeInfo;
}
export class AddFriendDesc extends NamedObjectDesc<AddFriendDescContent> {
}
export class AddFriendDescDecoder extends NamedObjectDescDecoder<AddFriendDescContent> {
}
export class AddFriendBuilder extends NamedObjectBuilder<AddFriendDescContent, EmptyProtobufBodyContent> {
}
export class AddFriendId extends NamedObjectId<AddFriendDescContent, EmptyProtobufBodyContent> {
    constructor(id: ObjectId);
    static default(): AddFriendId;
    static from_base_58(s: string): BuckyResult<AddFriendId>;
    static try_from_object_id(id: ObjectId): BuckyResult<AddFriendId>;
}
export class AddFriendIdDecoder extends NamedObjectIdDecoder<AddFriendDescContent, EmptyProtobufBodyContent> {
    constructor();
}
export class AddFriend extends NamedObject<AddFriendDescContent, EmptyProtobufBodyContent> {
    static create(owner: PeopleId, to: PeopleId): AddFriend;
    to(): PeopleId;
}
export class AddFriendDecoder extends NamedObjectDecoder<AddFriendDescContent, EmptyProtobufBodyContent, AddFriend> {
    constructor();
}

export class RemoveFriendDescTypeInfo extends DescTypeInfo {
    obj_type(): number;
    sub_desc_type(): SubDescType;
}
export class RemoveFriendDescContent extends ProtobufDescContent {
    to: PeopleId;
    try_to_proto(): BuckyResult<protos.RemoveFriendDescContent>;
    constructor(to: PeopleId);
    type_info(): DescTypeInfo;
}
export class RemoveFriendDescContentDecoder extends ProtobufDescContentDecoder<RemoveFriendDescContent, protos.RemoveFriendDescContent> {
    constructor();
    try_from_proto(value: protos.RemoveFriendDescContent): BuckyResult<RemoveFriendDescContent>;
    type_info(): DescTypeInfo;
}
export class RemoveFriendDesc extends NamedObjectDesc<RemoveFriendDescContent> {
}
export class RemoveFriendDescDecoder extends NamedObjectDescDecoder<RemoveFriendDescContent> {
}
export class RemoveFriendBuilder extends NamedObjectBuilder<RemoveFriendDescContent, EmptyProtobufBodyContent> {
}
export class RemoveFriendId extends NamedObjectId<RemoveFriendDescContent, EmptyProtobufBodyContent> {
    constructor(id: ObjectId);
    static default(): RemoveFriendId;
    static from_base_58(s: string): BuckyResult<RemoveFriendId>;
    static try_from_object_id(id: ObjectId): BuckyResult<RemoveFriendId>;
}
export class RemoveFriendIdDecoder extends NamedObjectIdDecoder<RemoveFriendDescContent, EmptyProtobufBodyContent> {
    constructor();
}
export class RemoveFriend extends NamedObject<RemoveFriendDescContent, EmptyProtobufBodyContent> {
    static create(owner: PeopleId, to: PeopleId): RemoveFriend;
    to(): PeopleId;
}
export class RemoveFriendDecoder extends NamedObjectDecoder<RemoveFriendDescContent, EmptyProtobufBodyContent, RemoveFriend> {
    constructor();
}

export class FriendOptionDescTypeInfo extends DescTypeInfo {
    obj_type(): number;
    sub_desc_type(): SubDescType;
}
export class FriendOptionDescContent extends ProtobufDescContent {
    try_to_proto(): BuckyResult<base_protos.EmptyContent>;
    constructor();
    type_info(): DescTypeInfo;
}
export class FriendOptionDescContentDecoder extends ProtobufDescContentDecoder<FriendOptionDescContent, base_protos.EmptyContent> {
    constructor();
    try_from_proto(value: base_protos.EmptyContent): BuckyResult<FriendOptionDescContent>;
    type_info(): DescTypeInfo;
}
export class FriendOptionBodyContent extends ProtobufBodyContent {
    auto_confirm?: boolean | undefined;
    msg?: string | undefined;
    constructor(auto_confirm?: boolean | undefined, msg?: string | undefined);
    try_to_proto(): BuckyResult<protos.FriendOptionContent>;
}
export class FriendOptionBodyContentDecoder extends ProtobufBodyContentDecoder<FriendOptionBodyContent, protos.FriendOptionContent> {
    constructor();
    try_from_proto(value: protos.FriendOptionContent): BuckyResult<FriendOptionBodyContent>;
}
export class FriendOptionDesc extends NamedObjectDesc<FriendOptionDescContent> {
}
export class FriendOptionDescDecoder extends NamedObjectDescDecoder<FriendOptionDescContent> {
}
export class FriendOptionBuilder extends NamedObjectBuilder<FriendOptionDescContent, FriendOptionBodyContent> {
}
export class FriendOptionId extends NamedObjectId<FriendOptionDescContent, FriendOptionBodyContent> {
    constructor(id: ObjectId);
    static default(): FriendOptionId;
    static from_base_58(s: string): BuckyResult<FriendOptionId>;
    static try_from_object_id(id: ObjectId): BuckyResult<FriendOptionId>;
}
export class FriendOptionIdDecoder extends NamedObjectIdDecoder<FriendOptionDescContent, FriendOptionBodyContent> {
    constructor();
}
export class FriendOption extends NamedObject<FriendOptionDescContent, FriendOptionBodyContent> {
    static create(owner: PeopleId, auto_confirm?: boolean, msg?: string): FriendOption;
}
export class FriendOptionDecoder extends NamedObjectDecoder<FriendOptionDescContent, FriendOptionBodyContent, FriendOption> {
    constructor();
}

export class MsgDescTypeInfo extends DescTypeInfo {
    obj_type(): number;
    sub_desc_type(): SubDescType;
}
export class MsgObjectContent {
    id: ObjectId;
    name: string;
    constructor(id: ObjectId, name: string);
}
export class MsgContent {
    static Text(text: string): MsgContent;
    static Object(object: MsgObjectContent): MsgContent;
    match<T>(visitor: {
        Text?: (text: string) => T;
        Object?: (object: MsgObjectContent) => T;
    }): T | undefined;
}
export class MsgDescContent extends ProtobufDescContent {
    to: ObjectId;
    content: MsgContent;
    constructor(to: ObjectId, content: MsgContent);
    try_to_proto(): BuckyResult<protos.MsgDescContent>;
    type_info(): DescTypeInfo;
}
export class MsgDescContentDecoder extends ProtobufDescContentDecoder<MsgDescContent, protos.MsgDescContent> {
    constructor();
    try_from_proto(value: protos.MsgDescContent): BuckyResult<MsgDescContent>;
    type_info(): DescTypeInfo;
}
export class MsgDesc extends NamedObjectDesc<MsgDescContent> {
}
export class MsgDescDecoder extends NamedObjectDescDecoder<MsgDescContent> {
}
export class MsgBuilder extends NamedObjectBuilder<MsgDescContent, EmptyProtobufBodyContent> {
}
export class MsgId extends NamedObjectId<MsgDescContent, EmptyProtobufBodyContent> {
    constructor(id: ObjectId);
    static default(): MsgId;
    static from_base_58(s: string): BuckyResult<MsgId>;
    static try_from_object_id(id: ObjectId): BuckyResult<MsgId>;
}
export class MsgIdDecoder extends NamedObjectIdDecoder<MsgDescContent, EmptyProtobufBodyContent> {
    constructor();
}
export class Msg extends NamedObject<MsgDescContent, EmptyProtobufBodyContent> {
    static create(owner: PeopleId, to: ObjectId, content: MsgContent): Msg;
    to(): ObjectId;
    content(): MsgContent;
    belongs(id: ObjectId): boolean;
}
export class MsgDecoder extends NamedObjectDecoder<MsgDescContent, EmptyProtobufBodyContent, Msg> {
    constructor();
}

export enum CoreObjectType {
    Zone = 32,
    Storage = 40,
    Text = 41,
    FriendList = 130,
    Topic = 150,
    TopicSubscribe = 151,
    TopicSubscribeSuccess = 152,
    TopicUnsubscribe = 153,
    TopicUnsubscribeSuccess = 154,
    TopicPublishStatus = 155,
    TopicPublish = 156,
    TopicPublishReq = 157,
    TopicPublishResp = 158,
    TopicMessageList = 159,
    BlockV1 = 300,
    MetaProto = 301,
    MetaMinerGroup = 302,
    BlockV2 = 303,
    TransContext = 350,
    DecApp = 400,
    AppStatus = 401,
    AppList = 402,
    AppStoreList = 405,
    AppExtInfo = 406,
    DefaultAppList = 407,
    SetDefaultApp = 408,
    AppCmd = 410,
    AppLocalStatus = 411,
    AppCmdList = 413,
    AppSetting = 414,
    AppManagerAction = 415,
    AppLocalList = 416,
    NFTList = 500,
    PerfOperation = 600,
    AddFriend = 1001,
    FriendOption = 1002,
    Msg = 1003,
    RemoveFriend = 1004,
    ErrObjType = 32767
}
export function number_2_core_object_type(x: number): CoreObjectType;
export function number_2_core_object_name(x: number): string;

export interface MetaResult<T> {
    err: number;
    msg: string;
    result: T;
}
export interface RawTxInfo {
    create_time: number;
    nonce: number;
    caller: string;
    gas_coin_id: number;
    gas_price: number;
    max_fee: number;
    result: number;
    use_fee: number;
    to: [string, number, number][];
    block_number: number;
    block_hash: number;
    block_create_time: number;
}
export interface RawBlock {
    height: number;
    block_hash: string;
    create_time: number;
    tx_list: RawTxInfo[];
}
export interface MetaStatus {
    version: number;
    height: number;
    gas_price: {
        low: number;
        medium: number;
        high: number;
    };
}
export interface Erc20TransferRequest {
    tx_hash?: string;
    start_number?: number;
    end_number?: number;
    from?: string;
    to?: string;
}
export interface Erc20TransferResult {
    address: string;
    tx_hash: string;
    from: string;
    to: string;
    value: number;
    height: number;
    gas_price: number;
    create_time: number;
    result: number;
}
export type NFTState = "Normal" | {
    "Auctioning": [number, CoinTokenId, number];
} | {
    "Selling": [number, CoinTokenId];
};
export interface NFTData {
    nft_id: string;
    create_time: number;
    beneficiary: string;
    owner_id: string;
    author_id: string;
    reward_amount: number;
    like_count: number;
    state: NFTState;
}
export interface NFTBidRecord {
    buyer_id: string;
    price: number;
    coin_id: CoinTokenId;
}
export enum MetaMinerTarget {
    Dev = 0,
    Test = 1,
    Formal = 2
}
export function get_meta_miner_host(target: MetaMinerTarget): string;
export function get_meta_spv_host(target: MetaMinerTarget): string;
export function meta_target_from_str(target?: string): MetaMinerTarget | undefined;
export function get_meta_client(target: MetaMinerTarget): MetaClient;
export function create_meta_client(target_str?: string, spv_str?: string): MetaClient;
export class MetaClient {
    constructor(meta_url: string, meta_spv_url: string);
    stringToUint8Array(str: string): Uint8Array;
    commit_signed_tx(tx: Tx): Promise<BuckyResult<Uint8Array>>;
    getSpvStatus(): Promise<MetaResult<MetaStatus> | null>;
    getPaymentTxList(address_list: string[], offset: number, length: number, start_block: number | null | undefined, end_block: number | null | undefined, coin_id_list: string[]): Promise<MetaResult<SPVTx[]> | null>;
    getCollectTxList(address_list: string[], offset: number, length: number, start_block: number | null | undefined, end_block: number | null | undefined, coin_id_list: string[]): Promise<MetaResult<SPVTx[]> | null>;
    getTxList(address_list: string[], offset: number, length: number, start_block: number | null | undefined, end_block: number | null | undefined, coin_id_list: string[]): Promise<MetaResult<SPVTx[]> | null>;
    getBlocksByRange(start_block: number, end_block: number): Promise<MetaResult<RawBlock[] | null>>;
    getFileRewardAmount(address: string): Promise<MetaResult<number>>;
    getErc20TransferList(address: string, query: Erc20TransferRequest): Promise<MetaResult<Erc20TransferResult>>;
    getTx(txId: string): Promise<MetaResult<RawTxInfo> | null>;
    getBalance(coidId: number, accountId: string): Promise<MetaResult<number> | null>;
    getBalances(list: [number, string][]): Promise<MetaResult<number[]> | null>;
    getChainStatus(): Promise<MetaResult<MetaStatus> | null>;
    view_request(view: ViewRequest): Promise<BuckyResult<ViewResponse>>;
    getDesc(id: ObjectId): Promise<BuckyResult<SavedMetaObject>>;
    getBalance2(id: ObjectId, coinId: number): Promise<BuckyResult<JSBI>>;
    getBeneficiary(address: ObjectId): Promise<BuckyResult<ObjectId>>;
    getRawData(id: ObjectId): Promise<BuckyResult<Uint8Array>>;
    getChainViewStatus(): Promise<BuckyResult<ChainStatus>>;
    getName(name: string): Promise<BuckyResult<Option<ViewNameResultItem>>>;
    getReceipt(id: TxId): Promise<BuckyResult<Option<[Receipt, number]>>>;
    get_nonce(id: ObjectId): Promise<BuckyResult<JSBI>>;
    create_desc(owner: StandardObject, desc: SavedMetaObject, v: JSBI, price: number, coin_id: number, secret: PrivateKey): Promise<BuckyResult<TxId>>;
    update_desc(owner: StandardObject, desc: SavedMetaObject, price: Option<number>, coin_id: Option<number>, secret: PrivateKey): Promise<BuckyResult<TxId>>;
    trans_balance(from: StandardObject, to: ObjectId, v: JSBI, coin_id: number, secret: PrivateKey): Promise<BuckyResult<TxId>>;
    withdraw_from_file(caller: StandardObject, file_id: ObjectId, v: JSBI, coin_id: number, secret: PrivateKey): Promise<BuckyResult<TxId>>;
    create_contract(caller: StandardObject, secret: PrivateKey, value: JSBI, init_data: Uint8Array, gas_price: number, max_fee: number): Promise<BuckyResult<TxId>>;
    call_contract(caller: StandardObject, secret: PrivateKey, address: ObjectId, value: JSBI, data: Uint8Array, gas_price: number, max_fee: number): Promise<BuckyResult<TxId>>;
    view_contract(address: ObjectId, data: Uint8Array): Promise<BuckyResult<ViewContractResult>>;
    get_logs(address: ObjectId, topics: (Uint8Array | null)[], from: number, to: number): Promise<BuckyResult<ViewLogResult>>;
    nft_get(nft_id: string): Promise<MetaResult<NFTData>>;
    nft_get_largest_buy(nft_id: string): Promise<BuckyResult<NFTLargestBuyValue>>;
    nft_get_apply_buy_list(nft_id: string, offset: number, length: number): Promise<BuckyResult<ViewNFTBuyListResult>>;
    nft_get_bid_list(nft_id: string, offset: number, length: number): Promise<BuckyResult<ViewNFTBuyListResult>>;
    nft_get_latest_likes(nft_id: string, count: number): Promise<MetaResult<[string, number, string][]>>;
    nft_has_like(nft_id: string, user_id: string): Promise<MetaResult<boolean>>;
}

export abstract class BaseRequestor {
    abstract remote_addr(): string;
    abstract request(req: HttpRequest): Promise<BuckyResult<Response>>;
}
export class HttpRequestor extends BaseRequestor {
    constructor(service_url: string);
    remote_addr(): string;
    request(req: HttpRequest): Promise<BuckyResult<Response>>;
}
export class WSHttpRequestor extends BaseRequestor {
    constructor(service_url: string);
    remote_addr(): string;
    request(req: HttpRequest): Promise<BuckyResult<Response>>;
}
export class RequestorHelper {
    static decode_str_body<T>(resp: Response, from_str: (s: string) => T): Promise<BuckyResult<T>>;
    static decode_header<T>(resp: Response, name: string, from_str: (s: string) => T): BuckyResult<T>;
    static decode_optional_header<T>(resp: Response, name: string, from_str: (s: string) => T): BuckyResult<Option<T>>;
    static decode_optional_headers<T>(resp: Response, name: string, from_str: (s: string) => T): BuckyResult<Option<T[]>>;
    static trans_status_code(code: number): BuckyErrorCode;
    static insert_device_list_header(http_req: HttpRequest, device_list: DeviceId[]): void;
    static error_from_resp(resp: Response): Promise<BuckyError>;
}

export class HttpRequest {
    url: string;
    init: RequestInit;
    constructor(method: string, url: string);
    insert_header(name: string, value: string): void;
    set_body(buf: Uint8Array): void;
    set_string_body(str: string): void;
    set_json_body(object: any): void;
}

export const NON_STACK_HTTP_URL: string;
export const NON_STACK_WS_URL: string;
export const RUNTIME_NON_STACK_HTTP_URL: string;
export const RUNTIME_NON_STACK_WS_URL: string;
export enum NONProtocol {
    Native = "native",
    Meta = "meta",
    Sync = "sync",
    HttpBdt = "http-bdt",
    HttpLocal = "http-local",
    DatagramBdt = "datagram-bdt",
    DataBdt = "data-bdt"
}
export enum ObjectProtocol {
    Local = "local",
    Meta = "meta",
    HttpBdt = "http_bdt",
    Http = "http",
    DatagramBdt = "datagram_bdt"
}
export const ROUTER_WS_EVENT_CMD_ADD = 1;
export const ROUTER_WS_EVENT_CMD_REMOVE = 2;
export const ROUTER_WS_EVENT_CMD_EVENT = 3;
export const ROUTER_WS_HANDLER_CMD_ADD = 11;
export const ROUTER_WS_HANDLER_CMD_REMOVE = 12;
export const ROUTER_WS_HANDLER_CMD_EVENT = 13;
export const HTTP_CMD_REQUEST = 21;

export class SelectTimeRange {
    begin?: JSBI | undefined;
    end?: JSBI | undefined;
    constructor(begin?: JSBI | undefined, end?: JSBI | undefined);
    toString(): string;
    static fromString(s: string): BuckyResult<SelectTimeRange>;
}
export interface SelectFilter {
    obj_type?: number;
    obj_type_code?: ObjectTypeCode;
    dec_id?: ObjectId;
    owner_id?: ObjectId;
    author_id?: ObjectId;
    create_time?: SelectTimeRange;
    update_time?: SelectTimeRange;
    insert_time?: SelectTimeRange;
    flags?: number;
}
export class SelectOption {
    page_size: number;
    page_index: number;
}
export class SelectEncoder {
    constructor(serviceURL: string);
    encode_select_request(req: SelectFilter, opt: Option<SelectOption>): HttpRequest;
}
export class SelectResponseObjectInfo {
    size: number;
    insert_time: JSBI;
    object?: AnyNamedObject;
    object_raw?: Uint8Array;
    constructor(size: number, insert_time: JSBI);
    static decode_meta_info(o: any): BuckyResult<SelectResponseObjectInfo>;
    bind_object(buf: Uint8Array): BuckyResult<void>;
}
export class SelectResponse {
    objects: SelectResponseObjectInfo[];
    constructor(objects?: SelectResponseObjectInfo[]);
    static from_response(resp: Response): Promise<BuckyResult<SelectResponse>>;
}
export class SelectTimeRangeJsonCodec extends JsonCodec<SelectTimeRange> {
    encode_object(param: SelectTimeRange): any;
    decode_object(o: any): BuckyResult<SelectTimeRange>;
}
export class SelectFilterJsonCodec extends JsonCodec<SelectFilter> {
    time_range_codec: SelectTimeRangeJsonCodec;
    constructor();
    encode_object(param: SelectFilter): any;
    decode_object(o: any): BuckyResult<SelectFilter>;
}
export class SelectOptionJsonCodec extends JsonCodec<SelectOption> {
}
export class SelectResponseObjectInfoJsonCodec extends JsonCodec<SelectResponseObjectInfo> {
    encode_object(param: SelectResponseObjectInfo): any;
    decode_object(o: any): BuckyResult<SelectResponseObjectInfo>;
}
export class SelectOptionCodec {
    static encode(req: HttpRequest, opt?: SelectOption): void;
}
export class SelectFilterUrlCodec {
    static encode(url: string, filter: SelectFilter): string;
}

export interface JsonCodecBase<T> {
    encode_string(param: T): string;
    decode_string(s: string): BuckyResult<T>;
}
export abstract class JsonCodec<T> implements JsonCodecBase<T> {
    encode_object(param: T): any;
    encode_string(param: T): string;
    decode_object(o: any): BuckyResult<T>;
    decode_string(s: string): BuckyResult<T>;
}
export class JsonCodecHelper {
    static decode_number(o: any): BuckyResult<number>;
    static decode_big_int(o: any): BuckyResult<JSBI>;
    static decode_hex_to_buffer(o: any): BuckyResult<Uint8Array>;
}
export class BuckyErrorJsonCodec extends JsonCodec<BuckyError> {
    encode_object(param: BuckyError): any;
    decode_object(o: any): BuckyResult<BuckyError>;
}
export class BuckyResultJsonCodec<T> extends JsonCodec<BuckyResult<T>> {
    constructor(codec: JsonCodec<T>);
    encode_object(param: BuckyResult<T>): any;
    decode_object(o: any): BuckyResult<BuckyResult<T>>;
}

export const CYFS_ROUTER_REQUEST_FLAG_FLUSH: number;
export const CYFS_REQUEST_FLAG_DELETE_WITH_QUERY: number;
export const CYFS_REQUEST_FLAG_LIST_DIR: number;

export enum ZoneDirection {
    LocalToLocal = "local_to_local",
    LocalToRemote = "local_to_remote",
    RemoteToLocal = "remote_to_local"
}
export interface RouterEventResponse {
    err: number;
    msg?: string;
}
export class RouterEventResponseJsonCodec extends JsonCodec<RouterEventResponse> {
    decode_object(o: any): BuckyResult<RouterEventResponse>;
}

export enum NDNAction {
    PutData = "put-data",
    GetData = "get-data",
    DeleteData = "delete-data",
    QueryFile = "query-file"
}
export enum NDNAPILevel {
    NDC = "ndc",
    NDN = "ndn",
    Router = "router"
}
export enum NDNPutDataResult {
    Accept = "Accept",
    AlreadyExists = "AlreadyExists"
}
export class NDNDataRefererObject {
    object_id: ObjectId;
    inner_path?: string | undefined;
    constructor(object_id: ObjectId, inner_path?: string | undefined);
    toString(): string;
    toJSON(): string;
}
export class NDNDataRefererObjectJsonCodec extends JsonCodec<NDNDataRefererObject> {
    constructor();
    decode_object(o: any): BuckyResult<NDNDataRefererObject>;
}

export interface NDNInputRequestCommon {
    req_path?: string;
    dec_id?: ObjectId;
    source: DeviceId;
    protocol: NONProtocol;
    level: NDNAPILevel;
    referer_object: NDNDataRefererObject[];
    target?: ObjectId;
    flags: number;
    user_data?: any;
}
export class NDNInputRequestCommonJsonCodec extends JsonCodec<NDNInputRequestCommon> {
    constructor(user_data_codec?: JsonCodec<any> | undefined);
    encode_object(param: NDNInputRequestCommon): any;
    decode_object(o: any): BuckyResult<NDNInputRequestCommon>;
}
export interface NDNGetDataInputRequest {
    common: NDNInputRequestCommon;
    object_id: ObjectId;
    inner_path?: string;
}
export class NDNGetDataInputRequestJsonCodec extends JsonCodec<NDNGetDataInputRequest> {
    constructor(common_user_data_codec?: JsonCodec<any> | undefined);
    encode_object(param: NDNGetDataInputRequest): any;
    decode_object(o: any): BuckyResult<NDNGetDataInputRequest>;
}
export interface NDNGetDataInputResponse {
    object_id: ObjectId;
    attr?: Attributes;
    length: number;
    data: Uint8Array;
}
export class NDNGetDataInputResponseJsonCodec extends JsonCodec<NDNGetDataInputResponse> {
    constructor();
    encode_object(param: NDNGetDataInputResponse): any;
    decode_object(o: any): BuckyResult<NDNGetDataInputResponse>;
}
export interface NDNPutDataInputRequest {
    common: NDNInputRequestCommon;
    object_id: ObjectId;
    length: number;
    data: Uint8Array;
}
export class NDNPutDataInputRequestJsonCodec extends JsonCodec<NDNPutDataInputRequest> {
    constructor(common_user_data_codec?: JsonCodec<any> | undefined);
    encode_object(param: NDNPutDataInputRequest): any;
    decode_object(o: any): BuckyResult<NDNPutDataInputRequest>;
}
export interface NDNPutDataInputResponse {
    result: NDNPutDataResult;
}
export class NDNPutDataInputResponseJsonCodec extends JsonCodec<NDNPutDataInputResponse> {
}
export interface NDNDeleteDataInputRequest {
    common: NDNInputRequestCommon;
    object_id: ObjectId;
    inner_path?: string;
}
export class NDNDeleteDataInputRequestJsonCodec extends JsonCodec<NDNDeleteDataInputRequest> {
    constructor(common_user_data_codec?: JsonCodec<any> | undefined);
    encode_object(param: NDNDeleteDataInputRequest): any;
    decode_object(o: any): BuckyResult<NDNDeleteDataInputRequest>;
}
export interface NDNDeleteDataInputResponse {
    object_id: ObjectId;
}
export class NDNDeleteDataInputResponseJsonCodec extends JsonCodec<NDNDeleteDataInputResponse> {
    constructor();
    encode_object(param: NDNDeleteDataInputResponse): any;
    decode_object(o: any): BuckyResult<NDNDeleteDataInputResponse>;
}
export const NDN_QUERY_FILE_REQUEST_FLAG_QUICK_HASN: number;
export const NDN_QUERY_FILE_REQUEST_FLAG_REF_DIRS: number;
export enum NDNQueryFileParamType {
    File = "file",
    Hash = "hash",
    QuickHash = "quick-hash",
    Chunk = "chunk"
}
export interface NDNQueryFileParam {
    type: NDNQueryFileParamType;
    file_id?: ObjectId;
    hash?: HashValue;
    quick_hash?: string;
    chunk_id?: ChunkId;
}
export function ndn_query_file_param_to_key_pair(param: NDNQueryFileParam): string[];
export class NDNQueryFileParamJsonCodec extends JsonCodec<NDNQueryFileParam> {
    constructor();
    encode_object(param: NDNQueryFileParam): any;
    decode_object(o: any): BuckyResult<NDNQueryFileParam>;
}
export interface NDNQueryFileInputRequest {
    common: NDNInputRequestCommon;
    param: NDNQueryFileParam;
}
export interface NDNQueryFileInfo {
    file_id: FileId;
    hash: string;
    length: JSBI;
    flags: number;
    owner?: ObjectId;
    quick_hash?: string[];
    ref_dirs?: FileDirRef[];
}
export interface NDNQueryFileInputResponse {
    list: NDNQueryFileInfo[];
}
export class NDNQueryFileInfoJsonCodec extends JsonCodec<NDNQueryFileInfo> {
    constructor();
    encode_object(param: NDNQueryFileInfo): any;
    decode_object(o: any): BuckyResult<NDNQueryFileInfo>;
}
export class NDNQueryFileInputResponseJsonCodec extends JsonCodec<NDNQueryFileInputResponse> {
    constructor();
    encode_object(param: NDNQueryFileInputResponse): any;
    decode_object(o: any): BuckyResult<NDNQueryFileInputResponse>;
}

export interface NDNOutputRequestCommon {
    req_path?: string;
    dec_id?: ObjectId;
    level: NDNAPILevel;
    target?: ObjectId;
    referer_object: NDNDataRefererObject[];
    flags: number;
}
export class NDNOutputRequestCommonJsonCodec extends JsonCodec<NDNOutputRequestCommon> {
    constructor();
    decode_object(o: any): BuckyResult<NDNOutputRequestCommon>;
}
export interface NDNPutDataOutputRequest {
    common: NDNOutputRequestCommon;
    object_id: ObjectId;
    length: number;
    data: Uint8Array;
}
export class NDNPutDataOutputRequestJsonCodec extends JsonCodec<NDNPutDataOutputRequest> {
    constructor();
    encode_object(param: NDNPutDataOutputRequest): any;
    decode_object(o: any): BuckyResult<NDNPutDataOutputRequest>;
}
export interface NDNPutDataOutputRequestWithBuffer {
    common: NDNOutputRequestCommon;
    object_id: ObjectId;
    data: Uint8Array;
}
export class NDNPutDataOutputRequestWithBufferJsonCodec extends JsonCodec<NDNPutDataOutputRequestWithBuffer> {
    constructor();
    encode_object(param: NDNPutDataOutputRequestWithBuffer): any;
    decode_object(o: any): BuckyResult<NDNPutDataOutputRequestWithBuffer>;
}
export interface NDNPutDataOutputResponse {
    result: NDNPutDataResult;
}
export class NDNPutDataOutputResponseJsonCodec extends JsonCodec<NDNPutDataOutputResponse> {
}
export interface NDNGetDataOutputRequest {
    common: NDNOutputRequestCommon;
    object_id: ObjectId;
    inner_path?: string;
}
export class NDNGetDataOutputRequestJsonCodec extends JsonCodec<NDNGetDataOutputRequest> {
    constructor();
    encode_object(param: NDNGetDataOutputRequest): any;
    decode_object(o: any): BuckyResult<NDNGetDataOutputRequest>;
}
export interface NDNGetDataOutputResponse {
    object_id: ObjectId;
    attr?: Attributes;
    length: number;
    data: Uint8Array;
}
export class NDNGetDataOutputResponseJsonCodec extends JsonCodec<NDNGetDataOutputResponse> {
    constructor();
    encode_object(param: NDNGetDataOutputResponse): any;
    decode_object(o: any): BuckyResult<NDNGetDataOutputResponse>;
}
export interface NDNDeleteDataOutputRequest {
    common: NDNOutputRequestCommon;
    object_id: ObjectId;
    inner_path?: string;
}
export class NDNDeleteDataOutputRequestJsonCodec extends JsonCodec<NDNDeleteDataOutputRequest> {
    constructor();
    encode_object(param: NDNDeleteDataOutputRequest): any;
    decode_object(o: any): BuckyResult<NDNDeleteDataOutputRequest>;
}
export interface NDNDeleteDataOutputResponse {
    object_id: ObjectId;
}
export class NDNDeleteDataOutputResponseJsonCodec extends JsonCodec<NDNDeleteDataOutputResponse> {
    constructor();
    encode_object(param: NDNDeleteDataOutputResponse): any;
    decode_object(o: any): BuckyResult<NDNDeleteDataOutputResponse>;
}
export interface NDNQueryFileOutputRequest {
    common: NDNOutputRequestCommon;
    param: NDNQueryFileParam;
}
export class NDNQueryFileOutputRequestJsonCodec extends JsonCodec<NDNQueryFileOutputRequest> {
    constructor();
    encode_object(param: NDNQueryFileOutputRequest): any;
    decode_object(o: any): BuckyResult<NDNQueryFileOutputRequest>;
}
export type NDNQueryFileOutputResponse = NDNQueryFileInputResponse;
export type NDNQueryFileOutputResponseJsonCodec = NDNQueryFileInputResponseJsonCodec;

export type NDNRequestCommon = NDNOutputRequestCommon;
export type NDNPutDataRequest = NDNPutDataOutputRequest;
export type NDNPutDataResponse = NDNPutDataOutputResponse;
export type NDNGetDataRequest = NDNGetDataOutputRequest;
export type NDNGetDataResponse = NDNGetDataOutputResponse;
export type NDNDeleteDataRequest = NDNDeleteDataOutputRequest;
export type NDNDeleteDataResponse = NDNDeleteDataOutputResponse;

export class NDNRequestor {
    service_url: string;
    constructor(requestor: BaseRequestor, dec_id?: ObjectId | undefined);
    format_url(req_path: string | undefined, object_id?: ObjectId, inner_path?: string): string;
    encode_common_headers(action: NDNAction, com_req: NDNOutputRequestCommon, http_req: HttpRequest): void;
    encode_common_headers_to_query(action: NDNAction, com_req: NDNOutputRequestCommon): string;
    encode_put_data_request(req: NDNPutDataOutputRequest): HttpRequest;
    decode_put_data_response(resp: Response): Promise<BuckyResult<NDNPutDataOutputResponse>>;
    put_data(req: NDNPutDataOutputRequest): Promise<BuckyResult<NDNPutDataOutputResponse>>;
    prepare_download_data(req: NDNGetDataOutputRequest): string;
    get_data(req: NDNGetDataOutputRequest): Promise<BuckyResult<NDNGetDataOutputResponse>>;
    encode_delete_data_request(req: NDNDeleteDataOutputRequest): HttpRequest;
    decode_delete_data_response(resp: Response): Promise<BuckyResult<NDNDeleteDataOutputResponse>>;
    delete_data(req: NDNDeleteDataOutputRequest): Promise<BuckyResult<NDNDeleteDataOutputResponse>>;
    encode_query_file_request(req: NDNQueryFileOutputRequest): HttpRequest;
    query_file(req: NDNQueryFileOutputRequest): Promise<BuckyResult<NDNQueryFileOutputResponse>>;
}

export enum GlobalStateCategory {
    RootState = "root-state",
    LocalCache = "local-cache"
}
export enum RootStateAction {
    GetCurrentRoot = "get-current-root",
    CreateOpEnv = "create-op-env"
}
export enum OpEnvAction {
    GetByKey = "get-by-key",
    InsertWithKey = "insert-with-key",
    SetWithKey = "set-with-key",
    RemoveWithKey = "remove-with-key",
    Contains = "contains",
    Insert = "insert",
    Remove = "remove",
    Load = "load",
    LoadByPath = "load-by-path",
    CreateNew = "create-new",
    Lock = "lock",
    Commit = "commit",
    Abort = "abort",
    Metadata = "metadata",
    Next = "next"
}
export enum ObjectMapOpEnvType {
    Path = "path",
    Single = "single"
}
export interface OpEnvSetResponse {
    result: boolean;
}
export enum RootStateRootType {
    Global = "global",
    Dec = "dec"
}
export enum ObjectMapContentMode {
    Simple = "simple",
    Hub = "hub"
}
export interface ObjectMapMetaData {
    content_mode: ObjectMapContentMode;
    content_type: ObjectMapSimpleContentType;
    count: JSBI;
    size: JSBI;
    depth: number;
}

export interface RootStateInputRequestCommon {
    dec_id?: ObjectId;
    source: DeviceId;
    protocol: NONProtocol;
    flags: number;
}
export interface RootStateGetCurrentRootInputRequest {
    common: RootStateInputRequestCommon;
}
export interface RootStateGetCurrentRootInputResponse {
    root: ObjectId;
}
export interface RootStateCreateOpEnvInputRequest {
    common: RootStateInputRequestCommon;
    op_env_type: ObjectMapOpEnvType;
}
export interface OpEnvInputRequestCommon {
    dec_id?: ObjectId;
    source: DeviceId;
    protocol: NONProtocol;
    flags: number;
    sid: JSBI;
}
export interface OpEnvLoadInputRequest {
    common: OpEnvInputRequestCommon;
    target: ObjectId;
}
export interface OpEnvLoadByPathInputRequest {
    common: OpEnvInputRequestCommon;
    path: string;
}
export interface OpEnvCreateNewInputRequest {
    common: OpEnvInputRequestCommon;
    content_type: ObjectMapSimpleContentType;
}
export interface OpEnvLockInputRequest {
    common: OpEnvInputRequestCommon;
    path_list: string[];
    duration_in_millsecs: JSBI;
    try_lock: boolean;
}
export interface OpEnvCommitInputRequest {
    common: OpEnvInputRequestCommon;
}
export interface OpEnvAbortInputRequest {
    common: OpEnvInputRequestCommon;
}
export interface OpEnvGetByKeyInputRequest {
    common: OpEnvInputRequestCommon;
    path?: string;
    key: string;
}
export interface OpEnvInsertWithKeyInputRequest {
    common: OpEnvInputRequestCommon;
    path?: string;
    key: string;
    value: ObjectId;
}
export interface OpEnvSetWithKeyInputRequest {
    common: OpEnvInputRequestCommon;
    path?: string;
    key: string;
    value: ObjectId;
    prev_value?: ObjectId;
    auto_insert: boolean;
}
export interface OpEnvRemoveWithKeyInputRequest {
    common: OpEnvInputRequestCommon;
    path?: string;
    key: string;
    prev_value?: ObjectId;
}
export interface OpEnvSetInputRequest {
    common: OpEnvInputRequestCommon;
    path?: string;
    value: ObjectId;
}
export type OpEnvContainsInputRequest = OpEnvSetInputRequest;
export type OpEnvContainsInputResponse = OpEnvSetResponse;
export type OpEnvInsertInputRequest = OpEnvSetInputRequest;
export type OpEnvInsertInputResponse = OpEnvSetResponse;
export type OpEnvRemoveInputRequest = OpEnvSetInputRequest;
export type OpEnvRemoveInputResponse = OpEnvSetResponse;
export interface OpEnvNextInputRequest {
    common: OpEnvInputRequestCommon;
    step: number;
}
export type OpEnvNextInputResponse = OpEnvNextOutputResponse;

export interface RootStateOutputRequestCommon {
    dec_id?: ObjectId;
    target?: ObjectId;
    flags: number;
}
export class RootStateOutputRequestCommonJsonCodec extends JsonCodec<RootStateOutputRequestCommon> {
    constructor();
    encode_object(param: RootStateOutputRequestCommon): any;
    decode_object(o: any): BuckyResult<RootStateOutputRequestCommon>;
}
export interface RootStateGetCurrentRootOutputRequest {
    common: RootStateOutputRequestCommon;
    root_type: RootStateRootType;
}
export class RootStateGetCurrentRootOutputRequestJsonCodec extends JsonCodec<RootStateGetCurrentRootOutputRequest> {
    constructor();
    encode_object(param: RootStateGetCurrentRootOutputRequest): any;
    decode_object(o: any): BuckyResult<RootStateGetCurrentRootOutputRequest>;
}
export interface RootStateGetCurrentRootOutputResponse {
    root: ObjectId;
    revision: JSBI;
    dec_root?: ObjectId;
}
export class RootStateGetCurrentRootOutputResponseJsonCodec extends JsonCodec<RootStateGetCurrentRootOutputResponse> {
    constructor();
    encode_object(param: RootStateGetCurrentRootOutputResponse): any;
    decode_object(o: any): BuckyResult<RootStateGetCurrentRootOutputResponse>;
}
export interface RootStateCreateOpEnvOutputRequest {
    common: RootStateOutputRequestCommon;
    op_env_type: ObjectMapOpEnvType;
}
export class RootStateCreateOpEnvOutputRequestJsonCodec extends JsonCodec<RootStateCreateOpEnvOutputRequest> {
    constructor();
    encode_object(param: RootStateCreateOpEnvOutputRequest): any;
    decode_object(o: any): BuckyResult<RootStateCreateOpEnvOutputRequest>;
}
export interface RootStateCreateOpEnvOutputResponse {
    sid: JSBI;
}
export class RootStateCreateOpEnvOutputResponseJsonCodec extends JsonCodec<RootStateCreateOpEnvOutputResponse> {
    constructor();
    encode_object(param: RootStateCreateOpEnvOutputResponse): any;
    decode_object(o: any): BuckyResult<RootStateCreateOpEnvOutputResponse>;
}
export interface OpEnvOutputRequestCommon {
    dec_id?: ObjectId;
    flags: number;
    target?: ObjectId;
    sid: JSBI;
}
export class OpEnvOutputRequestCommonJsonCodec extends JsonCodec<OpEnvOutputRequestCommon> {
    constructor();
    encode_object(param: OpEnvOutputRequestCommon): any;
    decode_object(o: any): BuckyResult<OpEnvOutputRequestCommon>;
}
export interface OpEnvLoadOutputRequest {
    common: OpEnvOutputRequestCommon;
    target: ObjectId;
}
export class OpEnvLoadOutputRequestJsonCodec extends JsonCodec<OpEnvLoadOutputRequest> {
    constructor();
    encode_object(param: OpEnvLoadOutputRequest): any;
    decode_object(o: any): BuckyResult<OpEnvLoadOutputRequest>;
}
export interface OpEnvLoadByPathOutputRequest {
    common: OpEnvOutputRequestCommon;
    path: string;
}
export class OpEnvLoadByPathOutputRequestJsonCodec extends JsonCodec<OpEnvLoadByPathOutputRequest> {
    constructor();
    encode_object(param: OpEnvLoadByPathOutputRequest): any;
    decode_object(o: any): BuckyResult<OpEnvLoadByPathOutputRequest>;
}
export interface OpEnvCreateNewOutputRequest {
    common: OpEnvOutputRequestCommon;
    path?: string;
    key?: string;
    content_type: ObjectMapSimpleContentType;
}
export class OpEnvCreateNewOutputRequestJsonCodec extends JsonCodec<OpEnvCreateNewOutputRequest> {
    constructor();
    encode_object(param: OpEnvCreateNewOutputRequest): any;
    decode_object(o: any): BuckyResult<OpEnvCreateNewOutputRequest>;
}
export interface OpEnvLockOutputRequest {
    common: OpEnvOutputRequestCommon;
    path_list: string[];
    duration_in_millsecs: JSBI;
    try_lock: boolean;
}
export class OpEnvLockOutputRequestJsonCodec extends JsonCodec<OpEnvLockOutputRequest> {
    constructor();
    encode_object(param: OpEnvLockOutputRequest): any;
    decode_object(o: any): BuckyResult<OpEnvLockOutputRequest>;
}
export interface OpEnvCommitOutputRequest {
    common: OpEnvOutputRequestCommon;
}
export class OpEnvCommitOutputRequestJsonCodec extends JsonCodec<OpEnvCommitOutputRequest> {
    constructor();
    encode_object(param: OpEnvCommitOutputRequest): any;
    decode_object(o: any): BuckyResult<OpEnvCommitOutputRequest>;
}
export interface OpEnvCommitOutputResponse {
    root: ObjectId;
    revision: JSBI;
    dec_root: ObjectId;
}
export class OpEnvCommitOutputResponseJsonCodec extends JsonCodec<OpEnvCommitOutputResponse> {
    constructor();
    encode_object(param: OpEnvCommitOutputResponse): any;
    decode_object(o: any): BuckyResult<OpEnvCommitOutputResponse>;
}
export interface OpEnvAbortOutputRequest {
    common: OpEnvOutputRequestCommon;
}
export class OpEnvAbortOutputRequestJsonCodec extends JsonCodec<OpEnvAbortOutputRequest> {
    constructor();
    encode_object(param: OpEnvAbortOutputRequest): any;
    decode_object(o: any): BuckyResult<OpEnvAbortOutputRequest>;
}
export interface OpEnvMetadataOutputRequest {
    common: OpEnvOutputRequestCommon;
    path?: string;
}
export class OpEnvMetadataOutputRequestJsonCodec extends JsonCodec<OpEnvMetadataOutputRequest> {
    constructor();
    encode_object(param: OpEnvMetadataOutputRequest): any;
    decode_object(o: any): BuckyResult<OpEnvMetadataOutputRequest>;
}
export interface OpEnvMetadataOutputResponse {
    content_mode: ObjectMapContentMode;
    content_type: ObjectMapSimpleContentType;
    count: JSBI;
    size: JSBI;
    depth: number;
}
export class OpEnvMetadataOutputResponseJsonCodec extends JsonCodec<OpEnvMetadataOutputResponse> {
    constructor();
    encode_object(param: OpEnvMetadataOutputResponse): any;
    decode_object(o: any): BuckyResult<OpEnvMetadataOutputResponse>;
}
export interface OpEnvGetByKeyOutputRequest {
    common: OpEnvOutputRequestCommon;
    path?: string;
    key: string;
}
export class OpEnvGetByKeyOutputRequestJsonCodec extends JsonCodec<OpEnvGetByKeyOutputRequest> {
    constructor();
    encode_object(param: OpEnvGetByKeyOutputRequest): any;
    decode_object(o: any): BuckyResult<OpEnvGetByKeyOutputRequest>;
}
export interface OpEnvGetByKeyOutputResponse {
    value?: ObjectId;
}
export class OpEnvGetByKeyOutputResponseJsonCodec extends JsonCodec<OpEnvGetByKeyOutputResponse> {
    constructor();
    encode_object(param: OpEnvGetByKeyOutputResponse): any;
    decode_object(o: any): BuckyResult<OpEnvGetByKeyOutputResponse>;
}
export interface OpEnvInsertWithKeyOutputRequest {
    common: OpEnvOutputRequestCommon;
    path?: string;
    key: string;
    value: ObjectId;
}
export class OpEnvInsertWithKeyOutputRequestJsonCodec extends JsonCodec<OpEnvInsertWithKeyOutputRequest> {
    constructor();
    encode_object(param: OpEnvInsertWithKeyOutputRequest): any;
    decode_object(o: any): BuckyResult<OpEnvInsertWithKeyOutputRequest>;
}
export interface OpEnvSetWithKeyOutputRequest {
    common: OpEnvOutputRequestCommon;
    path?: string;
    key: string;
    value: ObjectId;
    prev_value?: ObjectId;
    auto_insert: boolean;
}
export class OpEnvSetWithKeyOutputRequestJsonCodec extends JsonCodec<OpEnvSetWithKeyOutputRequest> {
    constructor();
    encode_object(param: OpEnvSetWithKeyOutputRequest): any;
    decode_object(o: any): BuckyResult<OpEnvSetWithKeyOutputRequest>;
}
export interface OpEnvSetWithKeyOutputResponse {
    prev_value?: ObjectId;
}
export class OpEnvSetWithKeyOutputResponseJsonCodec extends JsonCodec<OpEnvSetWithKeyOutputResponse> {
    constructor();
    encode_object(param: OpEnvSetWithKeyOutputResponse): any;
    decode_object(o: any): BuckyResult<OpEnvSetWithKeyOutputResponse>;
}
export interface OpEnvRemoveWithKeyOutputRequest {
    common: OpEnvOutputRequestCommon;
    path?: string;
    key: string;
    prev_value?: ObjectId;
}
export class OpEnvRemoveWithKeyOutputRequestJsonCodec extends JsonCodec<OpEnvRemoveWithKeyOutputRequest> {
    constructor();
    encode_object(param: OpEnvRemoveWithKeyOutputRequest): any;
    decode_object(o: any): BuckyResult<OpEnvRemoveWithKeyOutputRequest>;
}
export interface OpEnvRemoveWithKeyOutputResponse {
    value?: ObjectId;
}
export class OpEnvRemoveWithKeyOutputResponseJsonCodec extends JsonCodec<OpEnvRemoveWithKeyOutputResponse> {
    constructor();
    encode_object(param: OpEnvRemoveWithKeyOutputResponse): any;
    decode_object(o: any): BuckyResult<OpEnvRemoveWithKeyOutputResponse>;
}
export interface OpEnvSetOutputRequest {
    common: OpEnvOutputRequestCommon;
    path?: string;
    value: ObjectId;
}
export class OpEnvSetOutputRequestJsonCodec extends JsonCodec<OpEnvSetOutputRequest> {
    constructor();
    encode_object(param: OpEnvSetOutputRequest): any;
    decode_object(o: any): BuckyResult<OpEnvSetOutputRequest>;
}
export class OpEnvSetResponseJsonCodec extends JsonCodec<OpEnvSetResponse> {
    constructor();
    encode_object(param: OpEnvSetResponse): any;
    decode_object(o: any): BuckyResult<OpEnvSetResponse>;
}
export type OpEnvContainsOutputRequest = OpEnvSetOutputRequest;
export type OpEnvContainsOutputResponse = OpEnvSetResponse;
export type OpEnvInsertOutputRequest = OpEnvSetOutputRequest;
export type OpEnvInsertOutputResponse = OpEnvSetResponse;
export type OpEnvRemoveOutputRequest = OpEnvSetOutputRequest;
export type OpEnvRemoveOutputResponse = OpEnvSetResponse;
export interface OpEnvNextOutputRequest {
    common: OpEnvOutputRequestCommon;
    step: number;
}
export class OpEnvNextOutputRequestJsonCodec extends JsonCodec<OpEnvNextOutputRequest> {
    constructor();
    encode_object(param: OpEnvNextOutputRequest): any;
    decode_object(o: any): BuckyResult<OpEnvNextOutputRequest>;
}
export interface ObjectMapMapItem {
    key: string;
    value: ObjectId;
}
export class ObjectMapMapItemJsonCodec extends JsonCodec<ObjectMapMapItem> {
    constructor();
    encode_object(param: ObjectMapMapItem): any;
    decode_object(o: any): BuckyResult<ObjectMapMapItem>;
}
export interface ObjectMapSetItem {
    value: ObjectId;
}
export class ObjectMapSetItemJsonCodec extends JsonCodec<ObjectMapSetItem> {
    constructor();
    encode_object(param: ObjectMapSetItem): any;
    decode_object(o: any): BuckyResult<ObjectMapSetItem>;
}
export interface ObjectMapDiffMapItem {
    key: string;
    prev?: ObjectId;
    altered?: ObjectId;
    diff?: ObjectId;
}
export class ObjectMapDiffMapItemJsonCodec extends JsonCodec<ObjectMapDiffMapItem> {
    constructor();
    encode_object(param: ObjectMapDiffMapItem): any;
    decode_object(o: any): BuckyResult<ObjectMapDiffMapItem>;
}
export interface ObjectMapDiffSetItem {
    prev?: ObjectId;
    altered?: ObjectId;
}
export class ObjectMapDiffSetItemJsonCodec extends JsonCodec<ObjectMapDiffSetItem> {
    constructor();
    encode_object(param: ObjectMapDiffSetItem): any;
    decode_object(o: any): BuckyResult<ObjectMapDiffSetItem>;
}
export interface ObjectMapContentItem {
    content_type: ObjectMapSimpleContentType;
    map?: ObjectMapMapItem;
    set?: ObjectMapSetItem;
    diff_set?: ObjectMapDiffSetItem;
    diff_map?: ObjectMapDiffMapItem;
}
export class ObjectMapContentItemJsonCodec extends JsonCodec<ObjectMapContentItem> {
    constructor();
    decode_object(o: any): BuckyResult<ObjectMapContentItem>;
}
export interface OpEnvNextOutputResponse {
    list: ObjectMapContentItem[];
}
export class OpEnvNextOutputResponseJsonCodec extends JsonCodec<OpEnvNextOutputResponse> {
    constructor();
    encode_object(param: OpEnvNextOutputResponse): any;
    decode_object(o: any): BuckyResult<OpEnvNextOutputResponse>;
}
export interface RootStateAccessGetObjectByPathOutputRequest {
    common: RootStateOutputRequestCommon;
    inner_path: string;
}
export class RootStateAccessGetObjectByPathOutputRequestJsonCodec extends JsonCodec<RootStateAccessGetObjectByPathOutputRequest> {
    constructor();
    encode_object(param: RootStateAccessGetObjectByPathOutputRequest): any;
    decode_object(o: any): BuckyResult<RootStateAccessGetObjectByPathOutputRequest>;
}
export type RootStateAccessGetObjectByPathOutputResponse = NONGetObjectOutputResponse;
export interface RootStateAccessListOutputRequest {
    common: RootStateOutputRequestCommon;
    inner_path: string;
    page_index?: number;
    page_size?: number;
}
export class RootStateAccessListOutputRequestJsonCodec extends JsonCodec<RootStateAccessListOutputRequest> {
    constructor();
    encode_object(param: RootStateAccessListOutputRequest): any;
    decode_object(o: any): BuckyResult<RootStateAccessListOutputRequest>;
}
export type RootStateAccessListOutputResponse = OpEnvNextOutputResponse;

export type RootStateRequestCommon = RootStateOutputRequestCommon;
export type RootStateGetCurrentRootRequest = RootStateGetCurrentRootOutputRequest;
export type RootStateGetCurrentRootResponse = RootStateGetCurrentRootOutputResponse;
export type RootStateCreateOpEnvRequest = RootStateCreateOpEnvOutputRequest;
export type RootStateCreateOpEnvResponse = RootStateCreateOpEnvOutputResponse;
export type OpEnvRequestCommon = OpEnvOutputRequestCommon;
export type OpEnvLoadRequest = OpEnvLoadOutputRequest;
export type OpEnvLoadByPathRequest = OpEnvLoadByPathOutputRequest;
export type OpEnvCreateNewRequest = OpEnvCreateNewOutputRequest;
export type OpEnvLockRequest = OpEnvLockOutputRequest;
export type OpEnvCommitRequest = OpEnvCommitOutputRequest;
export type OpEnvCommitResponse = OpEnvCommitOutputResponse;
export type OpEnvAbortRequest = OpEnvAbortOutputRequest;
export type OpEnvGetByKeyRequest = OpEnvGetByKeyOutputRequest;
export type OpEnvGetByKeyResponse = OpEnvGetByKeyOutputResponse;
export type OpEnvInsertWithKeyRequest = OpEnvInsertWithKeyOutputRequest;
export type OpEnvSetWithKeyRequest = OpEnvSetWithKeyOutputRequest;
export type OpEnvSetWithKeyResponse = OpEnvSetWithKeyOutputResponse;
export type OpEnvRemoveWithKeyRequest = OpEnvRemoveWithKeyOutputRequest;
export type OpEnvRemoveWithKeyResponse = OpEnvRemoveWithKeyOutputResponse;
export type OpEnvContainsRequest = OpEnvContainsOutputRequest;
export type OpEnvContainsResponse = OpEnvContainsOutputResponse;
export type OpEnvInsertRequest = OpEnvInsertOutputRequest;
export type OpEnvInsertResponse = OpEnvInsertOutputResponse;
export type OpEnvRemoveRequest = OpEnvRemoveOutputRequest;
export type OpEnvRemoveResponse = OpEnvRemoveOutputResponse;

export class GlobalStateRequestor {
    constructor(category: GlobalStateCategory, requestor: BaseRequestor, dec_id?: ObjectId);
    get_category(): GlobalStateCategory;
    get_base_requestor(): BaseRequestor;
    get_dec_id(): ObjectId;
    get_current_root(req: RootStateGetCurrentRootOutputRequest): Promise<BuckyResult<RootStateGetCurrentRootOutputResponse>>;
    create_op_env(req: RootStateCreateOpEnvOutputRequest): Promise<BuckyResult<OpEnvRequestor>>;
    create_op_env_impl(req: RootStateCreateOpEnvOutputRequest): Promise<BuckyResult<RootStateCreateOpEnvOutputResponse>>;
}
export class OpEnvRequestor {
    constructor(category: GlobalStateCategory, requestor: BaseRequestor, op_env_type: ObjectMapOpEnvType, sid: JSBI, dec_id: ObjectId);
    get_sid(): JSBI;
    get_category(): GlobalStateCategory;
    load(req: OpEnvLoadOutputRequest): Promise<BuckyResult<{}>>;
    load_by_path(req: OpEnvLoadByPathOutputRequest): Promise<BuckyResult<{}>>;
    create_new(req: OpEnvCreateNewOutputRequest): Promise<BuckyResult<{}>>;
    lock(req: OpEnvLockOutputRequest): Promise<BuckyResult<{}>>;
    commit(req: OpEnvCommitOutputRequest): Promise<BuckyResult<OpEnvCommitOutputResponse>>;
    abort(req: OpEnvAbortOutputRequest): Promise<BuckyResult<{}>>;
    metadata(req: OpEnvMetadataOutputRequest): Promise<BuckyResult<OpEnvMetadataOutputResponse>>;
    get_by_key(req: OpEnvGetByKeyOutputRequest): Promise<BuckyResult<OpEnvGetByKeyOutputResponse>>;
    insert_with_key(req: OpEnvInsertWithKeyOutputRequest): Promise<BuckyResult<{}>>;
    set_with_key(req: OpEnvSetWithKeyOutputRequest): Promise<BuckyResult<OpEnvSetWithKeyOutputResponse>>;
    remove_with_key(req: OpEnvRemoveWithKeyOutputRequest): Promise<BuckyResult<OpEnvRemoveWithKeyOutputResponse>>;
    contains(req: OpEnvContainsOutputRequest): Promise<BuckyResult<OpEnvContainsOutputResponse>>;
    insert(req: OpEnvInsertOutputRequest): Promise<BuckyResult<OpEnvInsertOutputResponse>>;
    remove(req: OpEnvRemoveOutputRequest): Promise<BuckyResult<OpEnvRemoveOutputResponse>>;
    next(req: OpEnvNextOutputRequest): Promise<BuckyResult<OpEnvNextOutputResponse>>;
}
export class GlobalStateAccessRequestor {
    static new_root_state_access(requestor: BaseRequestor, dec_id?: ObjectId): GlobalStateAccessRequestor;
    static new_local_cache_access(requestor: BaseRequestor, dec_id?: ObjectId): GlobalStateAccessRequestor;
    constructor(category: GlobalStateCategory, requestor: BaseRequestor, dec_id?: ObjectId);
    get_dec_id(): ObjectId;
    get_category(): GlobalStateCategory;
    get_object_by_path(req: RootStateAccessGetObjectByPathOutputRequest): Promise<BuckyResult<RootStateAccessGetObjectByPathOutputResponse>>;
    list(req: RootStateAccessListOutputRequest): Promise<BuckyResult<RootStateAccessListOutputResponse>>;
}

export interface DecRootInfo {
    root: ObjectId;
    revision: JSBI;
    dec_root: ObjectId;
}
export class GlobalStateStub {
    constructor(requestor: GlobalStateRequestor, target?: ObjectId);
    get_current_root(): Promise<import("ts-results/result").Err<import("../../cyfs-base").BuckyError> | Ok<{
        root: ObjectId;
        revision: JSBI;
    }>>;
    get_dec_root(): Promise<BuckyResult<DecRootInfo>>;
    create_path_op_env(): Promise<BuckyResult<PathOpEnvStub>>;
    create_single_op_env(): Promise<BuckyResult<SingleOpEnvStub>>;
}
export class SingleOpEnvStub {
    constructor(requestor: OpEnvRequestor, target?: ObjectId);
    create_new(content_type: ObjectMapSimpleContentType): Promise<BuckyResult<{}>>;
    load(target: ObjectId): Promise<BuckyResult<{}>>;
    load_by_path(path: string): Promise<BuckyResult<{}>>;
    get_by_key(key: string): Promise<BuckyResult<ObjectId | undefined>>;
    insert_with_key(key: string, value: ObjectId): Promise<BuckyResult<{}>>;
    set_with_key(key: string, value: ObjectId, prev_value?: ObjectId, auto_insert?: boolean): Promise<BuckyResult<ObjectId | undefined>>;
    remove_with_key(key: string, prev_value?: ObjectId): Promise<BuckyResult<ObjectId | undefined>>;
    contains(object_id: ObjectId): Promise<BuckyResult<boolean>>;
    insert(object_id: ObjectId): Promise<BuckyResult<boolean>>;
    remove(object_id: ObjectId): Promise<BuckyResult<boolean>>;
    commit(): Promise<BuckyResult<DecRootInfo>>;
    abort(): Promise<BuckyResult<{}>>;
    next(step: number): Promise<BuckyResult<ObjectMapContentItem[]>>;
    metadata(): Promise<BuckyResult<ObjectMapMetaData>>;
}
export class PathOpEnvStub {
    constructor(requestor: OpEnvRequestor, target?: ObjectId);
    lock(path_list: string[], duration_in_millsecs: JSBI): Promise<BuckyResult<{}>>;
    try_lock(path_list: string[], duration_in_millsecs: JSBI): Promise<BuckyResult<{}>>;
    lock_impl(path_list: string[], duration_in_millsecs: JSBI, try_lock: boolean): Promise<BuckyResult<{}>>;
    get_by_key(path: string, key: string): Promise<BuckyResult<ObjectId | undefined>>;
    create_new(path: string, key: string, content_type: ObjectMapSimpleContentType): Promise<BuckyResult<{}>>;
    insert_with_key(path: string, key: string, value: ObjectId): Promise<BuckyResult<{}>>;
    set_with_key(path: string, key: string, value: ObjectId, prev_value?: ObjectId, auto_insert?: boolean): Promise<BuckyResult<ObjectId | undefined>>;
    remove_with_key(path: string, key: string, prev_value?: ObjectId): Promise<BuckyResult<ObjectId | undefined>>;
    get_by_path(full_path: string): Promise<BuckyResult<ObjectId | undefined>>;
    create_new_with_path(full_path: string, content_type: ObjectMapSimpleContentType): Promise<BuckyResult<{}>>;
    insert_with_path(full_path: string, value: ObjectId): Promise<BuckyResult<{}>>;
    set_with_path(full_path: string, value: ObjectId, prev_value?: ObjectId, auto_insert?: boolean): Promise<BuckyResult<ObjectId | undefined>>;
    remove_with_path(full_path: string, prev_value?: ObjectId): Promise<BuckyResult<ObjectId | undefined>>;
    contains(path: string, object_id: ObjectId): Promise<BuckyResult<boolean>>;
    insert(path: string, object_id: ObjectId): Promise<BuckyResult<boolean>>;
    remove(path: string, object_id: ObjectId): Promise<BuckyResult<boolean>>;
    commit(): Promise<BuckyResult<DecRootInfo>>;
    abort(): Promise<BuckyResult<{}>>;
    metadata(path: string): Promise<BuckyResult<ObjectMapMetaData>>;
}
export class GlobalStateAccessStub {
    constructor(requestor: GlobalStateAccessRequestor, target?: ObjectId, dec_id?: ObjectId);
    get_object_by_path(inner_path: string): Promise<BuckyResult<NONGetObjectOutputResponse>>;
    list(inner_path: string, page_index?: number, page_size?: number): Promise<BuckyResult<ObjectMapContentItem[]>>;
}

export enum NONDataType {
    Object = 0,
    Data = 1
}
export enum NONAction {
    PutObject = "put-object",
    GetObject = "get-object",
    PostObject = "post-object",
    SelectObject = "select-object",
    DeleteObject = "delete-object"
}
export enum NONAPILevel {
    NOC = "noc",
    NON = "non",
    Router = "router"
}
export enum NONPutObjectResult {
    Accept = "Accept",
    AcceptWithSign = "AcceptWithSign",
    AlreadyExists = "AlreadyExists",
    Updated = "Updated",
    Merged = "Merged"
}
export class NONObjectInfo {
    object_id: ObjectId;
    object_raw: Uint8Array;
    object?: AnyNamedObject | undefined;
    constructor(object_id: ObjectId, object_raw: Uint8Array, object?: AnyNamedObject | undefined);
    static new_from_object_raw(object_raw: Uint8Array): BuckyResult<NONObjectInfo>;
    decode(): BuckyResult<null>;
    try_decode(): BuckyResult<null>;
    get_update_time(): BuckyResult<JSBI>;
    get_expired_time(): BuckyResult<Option<JSBI>>;
    verify(): BuckyResult<null>;
    decode_and_verify(): BuckyResult<null>;
}
export class NONObjectInfoJsonCodec extends JsonCodec<NONObjectInfo> {
    constructor();
    encode_object(param: NONObjectInfo): any;
    decode_object(o: any): BuckyResult<NONObjectInfo>;
}
export class NONSlimObjectInfo {
    object_id: ObjectId;
    object_raw?: Uint8Array | undefined;
    object?: AnyNamedObject | undefined;
    constructor(object_id: ObjectId, object_raw?: Uint8Array | undefined, object?: AnyNamedObject | undefined);
    decode(): BuckyResult<null>;
    verify(): BuckyResult<null>;
    decode_and_verify(): BuckyResult<null>;
}
export class NONSlimObjectInfoJsonCodec extends JsonCodec<NONSlimObjectInfo> {
    constructor();
    encode_object(param: NONSlimObjectInfo): any;
    decode_object(o: any): BuckyResult<NONSlimObjectInfo>;
}

export interface NONInputRequestCommon {
    req_path?: string;
    dec_id?: ObjectId;
    source: DeviceId;
    protocol: NONProtocol;
    level: NONAPILevel;
    target?: ObjectId;
    flags: number;
}
export class NONInputRequestCommonJsonCodec extends JsonCodec<NONInputRequestCommon> {
    constructor();
    decode_object(o: any): BuckyResult<NONInputRequestCommon>;
}
export interface NONGetObjectInputRequest {
    common: NONInputRequestCommon;
    object_id: ObjectId;
    inner_path?: string;
}
export class NONGetObjectInputRequestJsonCodec extends JsonCodec<NONGetObjectInputRequest> {
    constructor();
    decode_object(o: any): BuckyResult<NONGetObjectInputRequest>;
}
export interface NONGetObjectInputResponse {
    object_update_time?: JSBI;
    object_expires_time?: JSBI;
    object: NONObjectInfo;
}
export class NONGetObjectInputResponseJsonCodec extends JsonCodec<NONGetObjectInputResponse> {
    constructor();
    encode_object(param: NONGetObjectInputResponse): any;
    decode_object(o: any): BuckyResult<NONGetObjectInputResponse>;
}
export interface NONPutObjectInputRequest {
    common: NONInputRequestCommon;
    object: NONObjectInfo;
}
export class NONPutObjectInputRequestJsonCodec extends JsonCodec<NONPutObjectInputRequest> {
    constructor();
    encode_object(param: NONPutObjectInputRequest): any;
    decode_object(o: any): BuckyResult<NONPutObjectInputRequest>;
}
export interface NONPutObjectInputResponse {
    result: NONPutObjectResult;
    object_update_time?: JSBI;
    object_expires_time?: JSBI;
}
export class NONPutObjectInputResponseJsonCodec extends JsonCodec<NONPutObjectInputResponse> {
    constructor();
    encode_object(param: NONPutObjectInputResponse): any;
    decode_object(o: any): BuckyResult<NONPutObjectInputResponse>;
}
export interface NONPostObjectInputRequest {
    common: NONInputRequestCommon;
    object: NONObjectInfo;
}
export class NONPostObjectInputRequestJsonCodec extends JsonCodec<NONPostObjectInputRequest> {
    constructor();
    encode_object(param: NONPostObjectInputRequest): any;
    decode_object(o: any): BuckyResult<NONPostObjectInputRequest>;
}
export interface NONPostObjectInputResponse {
    object?: NONObjectInfo;
}
export class NONPostObjectInputResponseJsonCodec extends JsonCodec<NONPostObjectInputResponse> {
    constructor();
    encode_object(param: NONPostObjectInputResponse): any;
    decode_object(o: any): BuckyResult<NONPostObjectInputResponse>;
}
export interface NONSelectObjectInputRequest {
    common: NONInputRequestCommon;
    filter: SelectFilter;
    opt?: SelectOption;
}
export class NONSelectObjectInputRequestJsonCodec extends JsonCodec<NONSelectObjectInputRequest> {
    constructor();
    encode_object(param: NONSelectObjectInputRequest): any;
    decode_object(o: any): BuckyResult<NONSelectObjectInputRequest>;
}
export interface NONSelectObjectInputResponse {
    objects: SelectResponseObjectInfo[];
}
export class NONSelectObjectInputResponseJsonCodec extends JsonCodec<NONSelectObjectInputResponse> {
    constructor();
    encode_object(param: NONSelectObjectInputResponse): any;
    decode_object(o: any): BuckyResult<NONSelectObjectInputResponse>;
}
export interface NONDeleteObjectInputRequest {
    common: NONInputRequestCommon;
    object_id: ObjectId;
    inner_path?: string;
}
export class NONDeleteObjectInputRequestJsonCodec extends JsonCodec<NONDeleteObjectInputRequest> {
    constructor();
    encode_object(param: NONDeleteObjectInputRequest): any;
    decode_object(o: any): BuckyResult<NONDeleteObjectInputRequest>;
}
export interface NONDeleteObjectInputResponse {
    object?: NONObjectInfo;
}
export class NONDeleteObjectInputResponseJsonCodec extends JsonCodec<NONDeleteObjectInputResponse> {
    constructor();
    encode_object(param: NONDeleteObjectInputResponse): any;
    decode_object(o: any): BuckyResult<NONDeleteObjectInputResponse>;
}

export interface NONOutputRequestCommon {
    req_path?: string;
    dec_id?: ObjectId;
    level: NONAPILevel;
    target?: ObjectId;
    flags: number;
}
export class NONOutputRequestCommonJsonCodec extends JsonCodec<NONOutputRequestCommon> {
    constructor();
    decode_object(o: any): BuckyResult<NONOutputRequestCommon>;
}
export interface NONPutObjectOutputRequest {
    common: NONOutputRequestCommon;
    object: NONObjectInfo;
}
export class NONPutObjectOutputRequestJsonCodec extends JsonCodec<NONPutObjectOutputRequest> {
    constructor();
    encode_object(param: NONPutObjectOutputRequest): any;
    decode_object(o: any): BuckyResult<NONPutObjectOutputRequest>;
}
export interface NONPutObjectOutputResponse {
    result: NONPutObjectResult;
    object_update_time?: JSBI;
    object_expires_time?: JSBI;
}
export class NONPutObjectOutputResponseJsonCodec extends JsonCodec<NONPutObjectOutputResponse> {
    constructor();
    encode_object(param: NONPutObjectOutputResponse): any;
    decode_object(o: any): BuckyResult<NONPutObjectOutputResponse>;
}
export interface NONGetObjectOutputRequest {
    common: NONOutputRequestCommon;
    object_id: ObjectId;
    inner_path?: string;
}
export class NONGetObjectOutputRequestJsonCodec extends JsonCodec<NONGetObjectOutputRequest> {
    constructor();
    decode_object(o: any): BuckyResult<NONGetObjectOutputRequest>;
}
export interface NONGetObjectOutputResponse {
    object_update_time?: JSBI;
    object_expires_time?: JSBI;
    object: NONObjectInfo;
    attr?: Attributes;
}
export class NONGetObjectOutputResponseJsonCodec extends JsonCodec<NONGetObjectOutputResponse> {
    constructor();
    encode_object(param: NONGetObjectOutputResponse): any;
    decode_object(o: any): BuckyResult<NONGetObjectOutputResponse>;
}
export interface NONPostObjectOutputRequest {
    common: NONOutputRequestCommon;
    object: NONObjectInfo;
}
export class NONPostObjectOutputRequestJsonCodec extends JsonCodec<NONPostObjectOutputRequest> {
    constructor();
    encode_object(param: NONPostObjectOutputRequest): any;
    decode_object(o: any): BuckyResult<NONPostObjectOutputRequest>;
}
export interface NONPostObjectOutputResponse {
    object?: NONObjectInfo;
}
export class NONPostObjectOutputResponseJsonCodec extends JsonCodec<NONPostObjectOutputResponse> {
    constructor();
    encode_object(param: NONPostObjectOutputResponse): any;
    decode_object(o: any): BuckyResult<NONPostObjectOutputResponse>;
}
export interface NONSelectObjectOutputRequest {
    common: NONOutputRequestCommon;
    filter: SelectFilter;
    opt?: SelectOption;
}
export class NONSelectObjectOutputRequestJsonCodec extends JsonCodec<NONSelectObjectOutputRequest> {
    constructor();
    encode_object(param: NONSelectObjectOutputRequest): any;
    decode_object(o: any): BuckyResult<NONSelectObjectOutputRequest>;
}
export interface NONSelectObjectOutputResponse {
    objects: SelectResponseObjectInfo[];
}
export class NONSelectObjectOutputResponseJsonCodec extends JsonCodec<NONSelectObjectOutputResponse> {
    constructor();
    encode_object(param: NONSelectObjectOutputResponse): any;
    decode_object(o: any): BuckyResult<NONSelectObjectOutputResponse>;
}
export interface NONDeleteObjectOutputRequest {
    common: NONOutputRequestCommon;
    object_id: ObjectId;
    inner_path?: string;
}
export class NONDeleteObjectOutputRequestJsonCodec extends JsonCodec<NONDeleteObjectOutputRequest> {
    constructor();
    encode_object(param: NONDeleteObjectOutputRequest): any;
    decode_object(o: any): BuckyResult<NONDeleteObjectOutputRequest>;
}
export interface NONDeleteObjectOutputResponse {
    object?: NONObjectInfo;
}
export class NONDeleteObjectOutputResponseJsonCodec extends JsonCodec<NONDeleteObjectOutputResponse> {
    constructor();
    encode_object(param: NONDeleteObjectOutputResponse): any;
    decode_object(o: any): BuckyResult<NONDeleteObjectOutputResponse>;
}

export type NONRequestCommon = NONOutputRequestCommon;
export type NONGetObjectRequest = NONGetObjectOutputRequest;
export type NONGetObjectResponse = NONGetObjectOutputResponse;
export type NONPutObjectRequest = NONPutObjectOutputRequest;
export type NONPutObjectResponse = NONPutObjectOutputResponse;
export type NONPostObjectRequest = NONPostObjectOutputRequest;
export type NONPostObjectResponse = NONPostObjectOutputResponse;
export type NONSelectObjectRequest = NONSelectObjectOutputRequest;
export type NONSelectObjectResponse = NONSelectObjectOutputResponse;
export type NONDeleteObjectRequest = NONDeleteObjectOutputRequest;
export type NONDeleteObjectResponse = NONDeleteObjectOutputResponse;

export class NONRequestorHelper {
    static decode_object_info(req: Response): Promise<BuckyResult<NONObjectInfo>>;
    static decode_option_object_info(req: Response): Promise<BuckyResult<Option<NONObjectInfo>>>;
    static encode_object_info(req: HttpRequest, info: NONObjectInfo): void;
}
export class NONRequestor {
    service_url: string;
    constructor(requestor: BaseRequestor, dec_id?: ObjectId | undefined);
    format_url(req_path: string | undefined, object_id: ObjectId, inner_path?: string): string;
    encode_common_headers(action: NONAction, com_req: NONOutputRequestCommon, http_req: HttpRequest): void;
    encode_put_object_request(req: NONPutObjectOutputRequest): HttpRequest;
    decode_put_object_response(resp: Response): Promise<BuckyResult<NONPutObjectOutputResponse>>;
    put_object(req: NONPutObjectOutputRequest): Promise<BuckyResult<NONPutObjectOutputResponse>>;
    encode_get_object_request(req: NONGetObjectOutputRequest): HttpRequest;
    decode_get_object_response(req: NONGetObjectOutputRequest, resp: Response): Promise<BuckyResult<NONGetObjectOutputResponse>>;
    get_object(req: NONGetObjectOutputRequest): Promise<BuckyResult<NONGetObjectOutputResponse>>;
    encode_post_object_request(req: NONPostObjectOutputRequest): HttpRequest;
    decode_post_object_response(object_id: ObjectId, resp: Response): Promise<BuckyResult<NONPostObjectOutputResponse>>;
    post_object(req: NONPostObjectOutputRequest): Promise<BuckyResult<NONPostObjectOutputResponse>>;
    format_select_url(req_path: string | undefined, filter: SelectFilter): string;
    encode_select_request(req: NONSelectObjectOutputRequest): HttpRequest;
    select_object(req: NONSelectObjectOutputRequest): Promise<BuckyResult<NONSelectObjectOutputResponse>>;
    encode_delete_object_request(req: NONDeleteObjectOutputRequest): HttpRequest;
    decode_delete_object_response(req: NONDeleteObjectOutputRequest, resp: Response): Promise<BuckyResult<NONDeleteObjectOutputResponse>>;
    delete_object(req: NONDeleteObjectOutputRequest): Promise<BuckyResult<NONDeleteObjectOutputResponse>>;
}

export enum CyfsStackEventType {
    Http = 0,
    WebSocket = 1
}
export enum CyfsStackRequestorType {
    Http = 0,
    WebSocket = 1
}
export interface CyfsStackRequestorConfig {
    non_service: CyfsStackRequestorType;
    ndn_service: CyfsStackRequestorType;
    util_service: CyfsStackRequestorType;
    trans_service: CyfsStackRequestorType;
    crypto_service: CyfsStackRequestorType;
    root_state: CyfsStackRequestorType;
    local_cache: CyfsStackRequestorType;
}
export class SharedCyfsStackParam {
    service_url: string;
    event_type: CyfsStackEventType;
    dec_id?: ObjectId | undefined;
    ws_url?: string | undefined;
    requestor_config?: CyfsStackRequestorConfig | undefined;
    constructor(service_url: string, event_type: CyfsStackEventType, dec_id?: ObjectId | undefined, ws_url?: string | undefined, requestor_config?: CyfsStackRequestorConfig | undefined);
    static default_requestor_config(): CyfsStackRequestorConfig;
    static ws_requestor_config(): CyfsStackRequestorConfig;
    static default(dec_id?: ObjectId): SharedCyfsStackParam;
    static default_with_ws_event(dec_id?: ObjectId): SharedCyfsStackParam;
    static default_runtime(dec_id?: ObjectId): SharedCyfsStackParam;
    static new_with_http_event(service_url: string, dec_id?: ObjectId): BuckyResult<SharedCyfsStackParam>;
    static new_with_http_event_ports(service_http_port: number, dec_id?: ObjectId): BuckyResult<SharedCyfsStackParam>;
    static new_with_ws_event(service_url: string, ws_url: string, dec_id?: ObjectId): BuckyResult<SharedCyfsStackParam>;
    static new_with_ws_event_ports(service_http_port: number, ws_port: number, dec_id?: ObjectId): BuckyResult<SharedCyfsStackParam>;
}
export class SharedCyfsStack {
    dec_id?: ObjectId;
    static default_with_ws_event(dec_id?: ObjectId): SharedCyfsStack;
    static open_default(dec_id?: ObjectId): SharedCyfsStack;
    static open_default_with_ws_event(dec_id?: ObjectId): SharedCyfsStack;
    static open_runtime(dec_id?: ObjectId): SharedCyfsStack;
    static open(param: SharedCyfsStackParam): SharedCyfsStack;
    wait_online(timeoutInMicroSeconds: Option<JSBI>): Promise<BuckyResult<null>>;
    online(): Promise<BuckyResult<null>>;
    local_device_id(): DeviceId;
    local_device(): Device;
    non_service(): NONRequestor;
    ndn_service(): NDNRequestor;
    crypto(): CryptoRequestor;
    util(): UtilRequestor;
    trans(): TransRequestor;
    router_handlers(): RouterHandlerManager;
    root_state(): GlobalStateRequestor;
    root_state_stub(target?: ObjectId): GlobalStateStub;
    local_cache(): GlobalStateRequestor;
    local_cache_stub(target?: ObjectId): GlobalStateStub;
    root_state_access(): GlobalStateAccessRequestor;
    root_state_access_stub(target?: ObjectId, dec_id?: ObjectId): GlobalStateAccessStub;
    local_cache_access(): GlobalStateAccessRequestor;
    local_cache_access_stub(dec_id?: ObjectId): GlobalStateAccessStub;
}

export type UtilRequestCommon = UtilOutputRequestCommon;
export type UtilGetDeviceRequest = UtilGetDeviceOutputRequest;
export type UtilGetDeviceResponse = UtilGetDeviceOutputResponse;
export type UtilGetZoneRequest = UtilGetZoneOutputRequest;
export type UtilGetZoneResponse = UtilGetZoneOutputResponse;
export type UtilResolveOODRequest = UtilResolveOODOutputRequest;
export type UtilResolveOODResponse = UtilResolveOODOutputResponse;
export type UtilGetOODStatusRequest = UtilGetOODStatusOutputRequest;
export type UtilGetOODStatusResponse = UtilGetOODStatusOutputResponse;
export type UtilGetNOCInfoRequest = UtilGetNOCInfoOutputRequest;
export type UtilGetNOCInfoResponse = UtilGetNOCInfoOutputResponse;
export type UtilGetDeviceStaticInfoRequest = UtilGetDeviceStaticInfoOutputRequest;
export type UtilGetDeviceStaticInfoResponse = UtilGetDeviceStaticInfoOutputResponse;
export type UtilGetNetworkAccessInfoRequest = UtilGetNetworkAccessInfoOutputRequest;
export type UtilGetNetworkAccessInfoResponse = UtilGetNetworkAccessInfoOutputResponse;
export type UtilGetSystemInfoRequest = UtilGetSystemInfoOutputRequest;
export type UtilGetSystemInfoResponse = UtilGetSystemInfoOutputResponse;
export type UtilGetVersionInfoRequest = UtilGetVersionInfoOutputRequest;
export type UtilGetVersionInfoResponse = UtilGetVersionInfoOutputResponse;
export type UtilBuildDirFromObjectMapRequest = UtilBuildDirFromObjectMapOutputRequest;
export type UtilBuildDirFromObjectMapResponse = UtilBuildDirFromObjectMapOutputResponse;
export enum BuildDirType {
    Zip = 0
}

export class UtilRequestor {
    service_url: string;
    constructor(requestor: BaseRequestor, dec_id?: ObjectId | undefined);
    format_url(util_path: string, req_path?: string, object_id?: ObjectId): string;
    encode_common_headers(com_req: UtilRequestCommon, http_req: HttpRequest): void;
    encode_get_device_request(req: UtilGetDeviceRequest): HttpRequest;
    decode_get_device_response(resp: Response): Promise<BuckyResult<UtilGetDeviceResponse>>;
    get_device(req: UtilGetDeviceRequest): Promise<BuckyResult<UtilGetDeviceResponse>>;
    encode_get_zone_request(req: UtilGetZoneRequest): HttpRequest;
    decode_get_zone_response(resp: Response): Promise<BuckyResult<UtilGetZoneResponse>>;
    get_zone(req: UtilGetZoneRequest): Promise<BuckyResult<UtilGetZoneOutputResponse>>;
    format_resolve_url(req_path: string | undefined, owner_id: ObjectId | undefined, object_id: ObjectId): string;
    encode_resolve_ood_request(req: UtilResolveOODRequest): HttpRequest;
    resolve_ood(req: UtilResolveOODRequest): Promise<BuckyResult<UtilResolveOODResponse>>;
    encode_get_ood_status_request(req: UtilGetOODStatusRequest): HttpRequest;
    get_ood_status(req: UtilGetOODStatusRequest): Promise<BuckyResult<UtilGetOODStatusResponse>>;
    encode_get_noc_info_request(req: UtilGetNOCInfoRequest): HttpRequest;
    get_noc_info(req: UtilGetNOCInfoRequest): Promise<BuckyResult<UtilGetNOCInfoResponse>>;
    encode_get_network_access_info_request(req: UtilGetNetworkAccessInfoRequest): HttpRequest;
    get_network_access_info(req: UtilGetNetworkAccessInfoRequest): Promise<BuckyResult<UtilGetNetworkAccessInfoResponse>>;
    encode_get_device_static_info_request(req: UtilGetDeviceStaticInfoRequest): HttpRequest;
    get_device_static_info(req: UtilGetDeviceStaticInfoRequest): Promise<BuckyResult<UtilGetDeviceStaticInfoResponse>>;
    encode_get_system_info_request(req: UtilGetSystemInfoRequest): HttpRequest;
    get_system_info(req: UtilGetSystemInfoRequest): Promise<BuckyResult<UtilGetSystemInfoResponse>>;
    encode_get_version_info_request(req: UtilGetVersionInfoRequest): HttpRequest;
    get_version_info(req: UtilGetVersionInfoRequest): Promise<BuckyResult<UtilGetVersionInfoResponse>>;
    encode_build_dir_from_object_map_request(req: UtilBuildDirFromObjectMapOutputRequest): HttpRequest;
    build_dir_from_object_map(req: UtilBuildDirFromObjectMapOutputRequest): Promise<BuckyResult<UtilBuildDirFromObjectMapOutputResponse>>;
}

export interface TransTaskOnAirState {
    download_percent: number;
    download_speed: number;
    upload_speed: number;
}
export enum TransTaskState {
    Pending = 0,
    Downloading = 1,
    Paused = 2,
    Canceled = 3,
    Finished = 4,
    Err = 5
}
export class TransTaskStateInfo {
    state: TransTaskState;
    on_air_state?: TransTaskOnAirState;
    upload_speed?: number;
    error_code?: BuckyErrorCodeEx;
    static from_respone(resp: Response): Promise<BuckyResult<TransTaskStateInfo>>;
}
export enum TransTaskControlAction {
    Start = "Start",
    Stop = "Stop",
    Delete = "Delete"
}
export enum TransTaskStatus {
    Stopped = "Stopped",
    Running = "Running",
    Finished = "Finished",
    Failed = "Failed"
}
export interface TransGetContextRequest {
    common: NDNOutputRequestCommon;
    context_name: string;
}
export interface TransPutContextRequest {
    common: NDNOutputRequestCommon;
    context: TransContext;
}
export interface TransCreateTaskRequest {
    common: NDNOutputRequestCommon;
    object_id: ObjectId;
    local_path: string;
    device_list: DeviceId[];
    context_id?: ObjectId;
    auto_start: boolean;
}
export class TransCreateTaskResponse {
    task_id: string;
    constructor(task_id: string);
    static from_response(resp: Response): Promise<BuckyResult<TransCreateTaskResponse>>;
}
export interface TransTaskRequest {
    common: NDNOutputRequestCommon;
    task_id: string;
}
export interface TransControlTaskRequest {
    common: NDNOutputRequestCommon;
    task_id: string;
    action: TransTaskControlAction;
}
export interface TransGetTaskStateRequest {
    common: NDNOutputRequestCommon;
    task_id: string;
}
export interface FileDirRef {
    dir_id: DirId;
    inner_path: string;
}
export interface TransQueryTasksRequest {
    common: NDNOutputRequestCommon;
    context_id?: ObjectId;
    task_status?: TransTaskStatus;
    range?: [number, number];
}
export interface TransTaskInfo {
    task_id: string;
    context_id?: ObjectId;
    object_id: ObjectId;
    local_path: string;
    device_list: DeviceId[];
}
export class TransQueryTaskResponse {
    task_list: TransTaskInfo[];
    constructor(task_list: TransTaskInfo[]);
    static from_response(resp: Response): Promise<BuckyResult<TransQueryTaskResponse>>;
}
export interface TransPublishFileRequest {
    common: NDNOutputRequestCommon;
    owner: ObjectId;
    local_path: string;
    chunk_size: number;
    file_id?: ObjectId;
    dirs?: FileDirRef[];
}
export class TransAddFileResponse {
    file_id: ObjectId;
    constructor(id: ObjectId);
    static from_respone(resp: Response): Promise<BuckyResult<TransAddFileResponse>>;
}

export class TransRequestor {
    serviceURL: string;
    constructor(requestor: BaseRequestor, dec_id?: ObjectId | undefined);
    encode_common_headers(com_req: NDNOutputRequestCommon, http_req: HttpRequest): void;
    get_context(req: TransGetContextRequest): Promise<BuckyResult<TransContext>>;
    put_context(req: TransPutContextRequest): Promise<BuckyResult<null>>;
    create_task(req: TransCreateTaskRequest): Promise<BuckyResult<TransCreateTaskResponse>>;
    start_task(req: TransTaskRequest): Promise<BuckyResult<null>>;
    stop_task(req: TransTaskRequest): Promise<BuckyResult<null>>;
    delete_task(req: TransTaskRequest): Promise<BuckyResult<null>>;
    control_task(req: TransControlTaskRequest): Promise<BuckyResult<null>>;
    get_task_state(req: TransGetTaskStateRequest): Promise<BuckyResult<TransTaskStateInfo>>;
    query_tasks(req: TransQueryTasksRequest): Promise<BuckyResult<TransQueryTaskResponse>>;
    publish_file(req: TransPublishFileRequest): Promise<BuckyResult<TransAddFileResponse>>;
}

class RouterHandlerItem {
    chain: RouterHandlerChain;
    category: RouterHandlerCategory;
    index: number;
    id: string;
    constructor(chain: RouterHandlerChain, category: RouterHandlerCategory, index: number, id: string, filter: string, default_action: RouterHandlerAction, routine: Option<RouterHandlerAnyRoutine>);
    set_routine(routine: Option<RouterHandlerAnyRoutine>): void;
    emit(param: string): Promise<BuckyResult<string>>;
    register(requestor: WebSocketRequestManager): Promise<void>;
}
export class RouterHandlerUnregisterItem {
    id: string;
    constructor(chain: RouterHandlerChain, category: RouterHandlerCategory, id: string);
    unregister(requestor: WebSocketRequestManager): Promise<BuckyResult<boolean>>;
}
export class RouterWSHandlerHandlerManagerImpl {
    handlers: {
        [name: string]: RouterHandlerItem;
    };
    unregister_handlers: {
        [name: string]: RouterHandlerUnregisterItem;
    };
    session: Option<WebSocketSession>;
    add_handler(handler_item: RouterHandlerItem): Promise<BuckyResult<void>>;
    static remove_handler(manager: RouterWSHandlerHandlerManagerImpl, chain: RouterHandlerChain, category: RouterHandlerCategory, id: string): Promise<BuckyResult<boolean>>;
    remove_handler_op(chain: RouterHandlerChain, category: RouterHandlerCategory, id: string): RouterHandlerUnregisterItem;
    static on_event(manager: RouterWSHandlerHandlerManagerImpl, content: string): Promise<BuckyResult<Option<string>>>;
    static on_session_begin(manager: RouterWSHandlerHandlerManagerImpl, session: WebSocketSession): Promise<void>;
    static register_all(manager: RouterWSHandlerHandlerManagerImpl, session: WebSocketSession): Promise<void>;
    static unregister_all(manager: RouterWSHandlerHandlerManagerImpl, session: WebSocketSession): Promise<void>;
    static on_session_end(manager: RouterWSHandlerHandlerManagerImpl, session: WebSocketSession): Promise<void>;
}
export class RouterHandlerWSHandlerManager {
    manager: RouterWSHandlerHandlerManagerImpl;
    client: WebSocketClient;
    constructor(service_url: string);
    start(): void;
    add_handler<REQ, RESP>(chain: RouterHandlerChain, id: string, index: number, category: RouterHandlerCategory, req_codec: JsonCodec<REQ>, resp_codec: JsonCodec<RESP>, filter: string, default_action: RouterHandlerAction, routine: Option<EventListenerAsyncRoutineT<RouterHandlerRequest<REQ, RESP>, RouterHandlerResponse<REQ, RESP>>>): Promise<BuckyResult<void>>;
    remove_handler(chain: RouterHandlerChain, category: RouterHandlerCategory, id: string): Promise<BuckyResult<boolean>>;
}
export {};

export interface RouterAddHandlerParam {
    filter: string;
    index: number;
    default_action: RouterHandlerAction;
    routine?: string;
}
export interface RouterWSAddHandlerParam {
    chain: RouterHandlerChain;
    category: RouterHandlerCategory;
    id: string;
    param: RouterAddHandlerParam;
}
export interface RouterWSRemoveHandlerParam {
    chain: RouterHandlerChain;
    category: RouterHandlerCategory;
    id: string;
}
export type RouterWSHandlerResponse = RouterEventResponse;
export interface RouterWSHandlerEventParam {
    chain: RouterHandlerChain;
    category: RouterHandlerCategory;
    id: string;
    param: string;
}
export interface RouterWSHandlerEventResponse {
    action: RouterHandlerAction;
}

export enum RouterHandlerAction {
    Default = "Default",
    Response = "Response",
    Reject = "Reject",
    Drop = "Drop",
    Pass = "Pass"
}

export enum RouterHandlerCategory {
    PutObject = "put_object",
    GetObject = "get_object",
    PostObject = "post_object",
    SelectObject = "select_object",
    DeleteObject = "delete_object",
    GetData = "get_data",
    PutData = "put_data",
    DeleteData = "delete_data",
    SignObject = "sign_object",
    VerifyObject = "verify_object",
    Acl = "acl"
}

export interface RouterHandlerAnyRoutine {
    emit(param: string): Promise<BuckyResult<string>>;
}
export class RouterHandlerEventRoutineT<REQ, RESP> implements RouterHandlerAnyRoutine {
    constructor(req_codec: JsonCodec<REQ>, resp_codec: JsonCodec<RESP>, listener: EventListenerAsyncRoutineT<RouterHandlerRequest<REQ, RESP>, RouterHandlerResponse<REQ, RESP>>);
    emit(param: string): Promise<BuckyResult<string>>;
}
export class RouterHandlerManager {
    ws: Option<RouterHandlerWSHandlerManager>;
    constructor(event_type: CyfsStackEventType, ws_url?: string);
    add_put_object_handler(chain: RouterHandlerChain, id: string, index: number, filter: string, default_action: RouterHandlerAction, routine: Option<RouterHandlerPutObjectRoutine>): Promise<BuckyResult<void>>;
    add_get_object_handler(chain: RouterHandlerChain, id: string, index: number, filter: string, default_action: RouterHandlerAction, routine: Option<RouterHandlerGetObjectRoutine>): Promise<BuckyResult<void>>;
    add_post_object_handler(chain: RouterHandlerChain, id: string, index: number, filter: string, default_action: RouterHandlerAction, routine: Option<RouterHandlerPostObjectRoutine>): Promise<BuckyResult<void>>;
    add_select_object_handler(chain: RouterHandlerChain, id: string, index: number, filter: string, default_action: RouterHandlerAction, routine: Option<RouterHandlerSelectObjectRoutine>): Promise<BuckyResult<void>>;
    add_delete_object_handler(chain: RouterHandlerChain, id: string, index: number, filter: string, default_action: RouterHandlerAction, routine: Option<RouterHandlerDeleteObjectRoutine>): Promise<BuckyResult<void>>;
    add_put_data_handler(chain: RouterHandlerChain, id: string, index: number, filter: string, default_action: RouterHandlerAction, routine: Option<RouterHandlerPutDataRoutine>): Promise<BuckyResult<void>>;
    add_get_data_handler(chain: RouterHandlerChain, id: string, index: number, filter: string, default_action: RouterHandlerAction, routine: Option<RouterHandlerGetDataRoutine>): Promise<BuckyResult<void>>;
    add_delete_data_handler(chain: RouterHandlerChain, id: string, index: number, filter: string, default_action: RouterHandlerAction, routine: Option<RouterHandlerDeleteDataRoutine>): Promise<BuckyResult<void>>;
    add_sign_object_handler(chain: RouterHandlerChain, id: string, index: number, filter: string, default_action: RouterHandlerAction, routine: Option<RouterHandlerSignObjectRoutine>): Promise<BuckyResult<void>>;
    add_verify_object_handler(chain: RouterHandlerChain, id: string, index: number, filter: string, default_action: RouterHandlerAction, routine: Option<RouterHandlerVerifyObjectRoutine>): Promise<BuckyResult<void>>;
    add_acl_handler(chain: RouterHandlerChain, id: string, index: number, filter: string, default_action: RouterHandlerAction, routine: Option<RouterHandlerAclRoutine>): Promise<BuckyResult<void>>;
    add_handler<REQ, RESP>(chain: RouterHandlerChain, id: string, index: number, category: RouterHandlerCategory, req_codec: JsonCodec<REQ>, resp_codec: JsonCodec<RESP>, filter: string, default_action: RouterHandlerAction, routine: Option<EventListenerAsyncRoutineT<RouterHandlerRequest<REQ, RESP>, RouterHandlerResponse<REQ, RESP>>>): Promise<BuckyResult<void>>;
    remove_handler(chain: RouterHandlerChain, category: RouterHandlerCategory, id: string): Promise<BuckyResult<boolean>>;
}

export interface RouterHandlerRequest<REQ, RESP> {
    request: REQ;
    response?: BuckyResult<RESP>;
}
export interface RouterHandlerResponse<REQ, RESP> {
    action: RouterHandlerAction;
    request?: REQ;
    response?: BuckyResult<RESP>;
}
export type RouterHandlerPutObjectRequest = RouterHandlerRequest<NONPutObjectInputRequest, NONPutObjectInputResponse>;
export type RouterHandlerGetObjectRequest = RouterHandlerRequest<NONGetObjectInputRequest, NONGetObjectInputResponse>;
export type RouterHandlerPostObjectRequest = RouterHandlerRequest<NONPostObjectInputRequest, NONPostObjectInputResponse>;
export type RouterHandlerSelectObjectRequest = RouterHandlerRequest<NONSelectObjectInputRequest, NONSelectObjectInputResponse>;
export type RouterHandlerDeleteObjectRequest = RouterHandlerRequest<NONDeleteObjectInputRequest, NONDeleteObjectInputResponse>;
export type RouterHandlerPutDataRequest = RouterHandlerRequest<NDNPutDataInputRequest, NDNPutDataInputResponse>;
export type RouterHandlerGetDataRequest = RouterHandlerRequest<NDNGetDataInputRequest, NDNGetDataInputResponse>;
export type RouterHandlerDeleteDataRequest = RouterHandlerRequest<NDNDeleteDataInputRequest, NDNDeleteDataInputResponse>;
export type RouterHandlerSignObjectRequest = RouterHandlerRequest<CryptoSignObjectInputRequest, CryptoSignObjectInputResponse>;
export type RouterHandlerVerifyObjectRequest = RouterHandlerRequest<CryptoVerifyObjectInputRequest, CryptoVerifyObjectInputResponse>;
export type RouterHandlerAclRequest = RouterHandlerRequest<AclHandlerRequest, AclHandlerResponse>;
export type RouterHandlerPutObjectResult = RouterHandlerResponse<NONPutObjectInputRequest, NONPutObjectInputResponse>;
export type RouterHandlerGetObjectResult = RouterHandlerResponse<NONGetObjectInputRequest, NONGetObjectInputResponse>;
export type RouterHandlerPostObjectResult = RouterHandlerResponse<NONPostObjectInputRequest, NONPostObjectInputResponse>;
export type RouterHandlerSelectObjectResult = RouterHandlerResponse<NONSelectObjectInputRequest, NONSelectObjectInputResponse>;
export type RouterHandlerDeleteObjectResult = RouterHandlerResponse<NONDeleteObjectInputRequest, NONDeleteObjectInputResponse>;
export type RouterHandlerPutDataResult = RouterHandlerResponse<NDNPutDataInputRequest, NDNPutDataInputResponse>;
export type RouterHandlerGetDataResult = RouterHandlerResponse<NDNGetDataInputRequest, NDNGetDataInputResponse>;
export type RouterHandlerDeleteDataResult = RouterHandlerResponse<NDNDeleteDataInputRequest, NDNDeleteDataInputResponse>;
export type RouterHandlerSignObjectResult = RouterHandlerResponse<CryptoSignObjectInputRequest, CryptoSignObjectInputResponse>;
export type RouterHandlerVerifyObjectResult = RouterHandlerResponse<CryptoVerifyObjectInputRequest, CryptoVerifyObjectInputResponse>;
export type RouterHandlerAclResult = RouterHandlerResponse<AclHandlerRequest, AclHandlerResponse>;
export type RouterHandlerPutObjectRoutine = EventListenerAsyncRoutineT<RouterHandlerPutObjectRequest, RouterHandlerPutObjectResult>;
export type RouterHandlerGetObjectRoutine = EventListenerAsyncRoutineT<RouterHandlerGetObjectRequest, RouterHandlerGetObjectResult>;
export type RouterHandlerPostObjectRoutine = EventListenerAsyncRoutineT<RouterHandlerPostObjectRequest, RouterHandlerPostObjectResult>;
export type RouterHandlerSelectObjectRoutine = EventListenerAsyncRoutineT<RouterHandlerSelectObjectRequest, RouterHandlerSelectObjectResult>;
export type RouterHandlerDeleteObjectRoutine = EventListenerAsyncRoutineT<RouterHandlerDeleteObjectRequest, RouterHandlerDeleteObjectResult>;
export type RouterHandlerPutDataRoutine = EventListenerAsyncRoutineT<RouterHandlerPutDataRequest, RouterHandlerPutDataResult>;
export type RouterHandlerGetDataRoutine = EventListenerAsyncRoutineT<RouterHandlerGetDataRequest, RouterHandlerGetDataResult>;
export type RouterHandlerDeleteDataRoutine = EventListenerAsyncRoutineT<RouterHandlerDeleteDataRequest, RouterHandlerDeleteDataResult>;
export type RouterHandlerSignObjectRoutine = EventListenerAsyncRoutineT<RouterHandlerSignObjectRequest, RouterHandlerSignObjectResult>;
export type RouterHandlerVerifyObjectRoutine = EventListenerAsyncRoutineT<RouterHandlerVerifyObjectRequest, RouterHandlerVerifyObjectResult>;
export type RouterHandlerAclRoutine = EventListenerAsyncRoutineT<RouterHandlerAclRequest, RouterHandlerAclResult>;
export class RouterHandlerRequestJsonCodec<REQ, RESP> extends JsonCodec<RouterHandlerRequest<REQ, RESP>> {
    constructor(req_codec: JsonCodec<REQ>, resp_codec: JsonCodec<RESP>);
    encode_object(param: RouterHandlerRequest<REQ, RESP>): any;
    decode_object(o: any): BuckyResult<RouterHandlerRequest<REQ, RESP>>;
}
export class RouterHandlerResponseJsonCodec<REQ, RESP> extends JsonCodec<RouterHandlerResponse<REQ, RESP>> {
    constructor(req_codec: JsonCodec<REQ>, resp_codec: JsonCodec<RESP>);
    encode_object(param: RouterHandlerResponse<REQ, RESP>): any;
    decode_object(o: any): BuckyResult<RouterHandlerResponse<REQ, RESP>>;
}
export type RouterHandlerPutObjectRequestJsonCodec = RouterHandlerRequestJsonCodec<NONPutObjectInputRequest, NONPutObjectInputResponse>;
export type RouterHandlerGetObjectRequestJsonCodec = RouterHandlerRequestJsonCodec<NONGetObjectInputRequest, NONGetObjectInputResponse>;
export type RouterHandlerPostObjectRequestJsonCodec = RouterHandlerRequestJsonCodec<NONPostObjectInputRequest, NONPostObjectInputResponse>;
export type RouterHandlerSelectObjectRequestJsonCodec = RouterHandlerRequestJsonCodec<NONSelectObjectInputRequest, NONSelectObjectInputResponse>;
export type RouterHandlerDeleteObjectRequestJsonCodec = RouterHandlerRequestJsonCodec<NONDeleteObjectInputRequest, NONDeleteObjectInputResponse>;
export type RouterHandlerSignObjectRequestJsonCodec = RouterHandlerRequestJsonCodec<CryptoSignObjectInputRequest, CryptoSignObjectInputResponse>;
export type RouterHandlerVerifyObjectRequestJsonCodec = RouterHandlerRequestJsonCodec<CryptoVerifyObjectInputRequest, CryptoVerifyObjectInputResponse>;

export enum RouterHandlerChain {
    PreNOC = "pre_noc",
    PostNOC = "post_noc",
    PreRouter = "pre_router",
    PostRouter = "post_router",
    PreForward = "pre_forward",
    PostForward = "post_forward",
    PreCrypto = "pre_crypto",
    PostCrypto = "post_crypto",
    Acl = "acl"
}

export class CryptoRequestor {
    service_url: string;
    constructor(requestor: BaseRequestor, dec_id?: ObjectId | undefined);
    format_url(sign: boolean, req_path: string | undefined, object_id: ObjectId): string;
    encode_common_headers(com_req: CryptoOutputRequestCommon, http_req: HttpRequest): void;
    encode_verify_object_request(req: CryptoVerifyObjectOutputRequest): HttpRequest;
    decode_verify_object_response(object_id: ObjectId, resp: Response): Promise<BuckyResult<CryptoVerifyObjectOutputResponse>>;
    verify_object(req: CryptoVerifyObjectRequest): Promise<BuckyResult<CryptoVerifyObjectOutputResponse>>;
    encode_sign_object_request(req: CryptoSignObjectRequest): HttpRequest;
    decode_sign_object_response(object_id: ObjectId, resp: Response): Promise<BuckyResult<CryptoSignObjectOutputResponse>>;
    sign_object(req: CryptoSignObjectRequest): Promise<BuckyResult<CryptoSignObjectOutputResponse>>;
}

export type CryptoRequestCommon = CryptoOutputRequestCommon;
export type CryptoSignObjectRequest = CryptoSignObjectOutputRequest;
export type CryptoSignObjectResponse = CryptoSignObjectOutputResponse;
export type CryptoVerifyObjectRequest = CryptoVerifyObjectOutputRequest;
export type CryptoVerifyObjectResponse = CryptoVerifyObjectOutputResponse;

export interface CryptoInputRequestCommon {
    req_path?: string;
    dec_id?: ObjectId;
    source: DeviceId;
    protocol: NONProtocol;
    target?: ObjectId;
    flags: number;
}
export class CryptoInputRequestCommonJsonCodec extends JsonCodec<CryptoInputRequestCommon> {
    encode_object(param: CryptoInputRequestCommon): any;
    decode_object(o: any): BuckyResult<CryptoInputRequestCommon>;
}
export interface CryptoSignObjectInputRequest {
    common: CryptoInputRequestCommon;
    object: NONObjectInfo;
    flags: number;
}
export class CryptoSignObjectInputRequestJsonCodec extends JsonCodec<CryptoSignObjectInputRequest> {
    encode_object(param: CryptoSignObjectInputRequest): any;
    decode_object(o: any): BuckyResult<CryptoSignObjectInputRequest>;
}
export type CryptoSignObjectInputResponse = CryptoSignObjectOutputResponse;
export interface CryptoVerifyObjectInputRequest {
    common: CryptoInputRequestCommon;
    sign_type: VerifySignType;
    object: NONObjectInfo;
    sign_object: VerifyObjectType;
}
export class CryptoVerifyObjectInputRequestJsonCodec extends JsonCodec<CryptoVerifyObjectInputRequest> {
    encode_object(param: CryptoVerifyObjectInputRequest): any;
    decode_object(o: any): BuckyResult<CryptoVerifyObjectInputRequest>;
}
export type CryptoVerifyObjectInputResponse = CryptoVerifyObjectOutputResponse;

export interface CryptoOutputRequestCommon {
    req_path?: string;
    dec_id?: ObjectId;
    target?: ObjectId;
    flags: number;
}
export const CRYPTO_REQUEST_FLAG_SIGN_BY_PEOPLE: number;
export const CRYPTO_REQUEST_FLAG_SIGN_BY_DEVICE: number;
export const CRYPTO_REQUEST_FLAG_SIGN_SET_DESC: number;
export const CRYPTO_REQUEST_FLAG_SIGN_SET_BODY: number;
export const CRYPTO_REQUEST_FLAG_SIGN_PUSH_DESC: number;
export const CRYPTO_REQUEST_FLAG_SIGN_PUSH_BODY: number;
export interface CryptoSignObjectOutputRequest {
    common: CryptoOutputRequestCommon;
    object: NONObjectInfo;
    flags: number;
}
export enum SignObjectResult {
    Signed = "signed",
    Pending = "pending"
}
export interface CryptoSignObjectOutputResponse {
    result: SignObjectResult;
    object?: NONObjectInfo;
}
export class CryptoSignObjectOutputResponseJsonCodec extends JsonCodec<CryptoSignObjectOutputResponse> {
    encode_object(param: CryptoSignObjectOutputResponse): any;
    decode_object(o: any): BuckyResult<CryptoSignObjectOutputResponse>;
}
export enum VerifySignType {
    Desc = "desc",
    Body = "body",
    Both = "both"
}
export interface SignObject {
    object_id: ObjectId;
    object_raw?: Uint8Array;
    object?: AnyNamedObject;
}
export class SignObjectJsonCodec extends JsonCodec<SignObject> {
    encode_object(param: SignObject): any;
    decode_object(o: any): BuckyResult<SignObject>;
}
export interface VerifySigns {
    desc_signs?: Uint8Array;
    body_signs?: Uint8Array;
}
export class VerifySignsJsonCodec extends JsonCodec<VerifySigns> {
    constructor();
    encode_object(param: VerifySigns): any;
    decode_object(o: any): BuckyResult<VerifySigns>;
}
export class VerifyObjectType {
    type: string;
    sign_object?: SignObject | undefined;
    verify_signs?: VerifySigns | undefined;
    constructor(type: string, sign_object?: SignObject | undefined, verify_signs?: VerifySigns | undefined);
    static Owner(): VerifyObjectType;
    static Own(): VerifyObjectType;
    static Object(sign_object: SignObject): VerifyObjectType;
    static Sign(verify_signs: VerifySigns): VerifyObjectType;
    match(visitor: {
        Owner?: () => void;
        Own?: () => void;
        Object?: (object: SignObject) => void;
        Sign?: (sign: VerifySigns) => void;
    }): void;
}
export class VerifyObjectTypeJsonCodec extends JsonCodec<VerifyObjectType> {
    encode_object(param: VerifyObjectType): any;
    decode_object(o: any): BuckyResult<VerifyObjectType>;
}
export interface CryptoVerifyObjectOutputRequest {
    common: CryptoOutputRequestCommon;
    sign_type: VerifySignType;
    object: NONObjectInfo;
    sign_object: VerifyObjectType;
}
export interface VerifySignResult {
    index: number;
    valid: boolean;
    sign_object_id: ObjectId;
}
export class VerifySignResultJsonCodec extends JsonCodec<VerifySignResult> {
    encode_object(param: VerifySignResult): any;
    decode_object(o: any): BuckyResult<VerifySignResult>;
}
export interface VerifyObjectResult {
    valid: boolean;
    desc_signs: VerifySignResult[];
    body_signs: VerifySignResult[];
}
export class VerifyObjectResultJsonCodec extends JsonCodec<VerifyObjectResult> {
    encode_object(param: VerifyObjectResult): any;
    decode_object(o: any): BuckyResult<VerifyObjectResult>;
}
export interface CryptoVerifyObjectOutputResponse {
    result: VerifyObjectResult;
}
export class CryptoVerifyObjectOutputResponseJsonCodec extends JsonCodec<CryptoVerifyObjectOutputResponse> {
    encode_object(param: CryptoVerifyObjectOutputResponse): any;
    decode_object(o: any): BuckyResult<CryptoVerifyObjectOutputResponse>;
}

export enum AclDirection {
    Any = "*",
    In = "in",
    Out = "out"
}
export enum AclOperation {
    Any = "*",
    GetObject = "get-object",
    PutObject = "put-object",
    PostObject = "post-object",
    SelectObject = "select-object",
    DeleteObject = "delete-object",
    SignObject = "sign-object",
    VerifyObject = "verify-object",
    PutData = "put-data",
    GetData = "get-data",
    DeleteData = "delete-data",
    Get = "get",
    Put = "put",
    Delete = "delete",
    Read = "read",
    Write = "write",
    Crypto = "crypto"
}
export interface AclAction {
    direction: AclDirection;
    operation: AclOperation;
}
export enum AclAccess {
    Accept = "accept",
    Reject = "reject",
    Drop = "drop",
    Pass = "pass"
}

export interface AclHandlerRequest {
    protocol: NONProtocol;
    action: AclAction;
    device_id: DeviceId;
    object: NONSlimObjectInfo;
    inner_path?: string;
    dec_id: string;
    req_path?: string;
    referer_object?: NDNDataRefererObject[];
}
export class AclHandlerRequestJsonCodec extends JsonCodec<AclHandlerRequest> {
    encode_object(param: AclHandlerRequest): any;
    decode_object(o: any): BuckyResult<AclHandlerRequest>;
}
export interface AclHandlerResponse {
    access: AclAccess;
}
export class AclHandlerResponseJsonCodec extends JsonCodec<AclHandlerResponse> {
}

export enum ZoneRole {
    ActiveOOD = "active-ood",
    StandbyOOD = "standby-ood",
    ReservedOOD = "reserved-ood",
    Device = "device"
}

export interface JsonFragmentType {
    readonly name?: string;
    readonly indexed?: boolean;
    readonly type?: string;
    readonly components?: ReadonlyArray<JsonFragmentType>;
}
export interface JsonFragment {
    readonly name: string;
    readonly type: string;
    readonly anonymous?: boolean;
    readonly payable?: boolean;
    readonly constant?: boolean;
    readonly stateMutability?: string;
    readonly inputs?: ReadonlyArray<JsonFragmentType>;
    readonly outputs?: ReadonlyArray<JsonFragmentType>;
    readonly gas?: string;
}
export const FormatTypes: {
    [name: string]: string;
};
export class ParamType {
    readonly name?: string;
    readonly type: string;
    readonly baseType: string;
    readonly indexed?: boolean;
    readonly components?: ParamType[];
    readonly arrayLength?: number;
    readonly arrayChildren?: ParamType;
    readonly _isParamType: boolean;
    constructor(constructorGuard: any, params: any);
    format(format?: string): string;
    static from(value: string | JsonFragmentType | ParamType, allowIndexed?: boolean): ParamType;
    static fromObject(value: JsonFragmentType | ParamType): ParamType;
    static fromString(value: string, allowIndexed?: boolean): ParamType;
    static isParamType(value: any): value is ParamType;
}
export abstract class Fragment {
    readonly type: string;
    readonly name?: string;
    readonly inputs: ParamType[];
    readonly _isFragment: boolean;
    constructor(constructorGuard: any, params: any);
    abstract format(format?: string): string;
    static from(value: Fragment | JsonFragment | string): Fragment | undefined;
    static fromObject(value: Fragment | JsonFragment): Fragment | undefined;
    static fromString(value: string): Fragment;
    static isFragment(value: any): value is Fragment;
}
export class EventFragment extends Fragment {
    readonly anonymous?: boolean;
    format(format?: string): string;
    static from(value: EventFragment | JsonFragment | string): EventFragment;
    static fromObject(value: JsonFragment | EventFragment): EventFragment;
    static fromString(value: string): EventFragment;
    static isEventFragment(value: any): value is EventFragment;
}
export class ConstructorFragment extends Fragment {
    stateMutability?: string;
    payable?: boolean;
    gas?: BigNumber;
    format(format?: string): string;
    static from(value: ConstructorFragment | JsonFragment | string): ConstructorFragment;
    static fromObject(value: ConstructorFragment | JsonFragment): ConstructorFragment;
    static fromString(value: string): ConstructorFragment;
    static isConstructorFragment(value: any): value is ConstructorFragment;
}
export class FunctionFragment extends ConstructorFragment {
    constant: boolean;
    outputs?: ParamType[];
    format(format?: string): string;
    static from(value: FunctionFragment | JsonFragment | string): FunctionFragment;
    static fromObject(value: FunctionFragment | JsonFragment): FunctionFragment;
    static fromString(value: string): FunctionFragment;
    static isFunctionFragment(value: any): value is FunctionFragment;
}
export class ErrorFragment extends Fragment {
    format(format?: string): string;
    static from(value: ErrorFragment | JsonFragment | string): ErrorFragment;
    static fromObject(value: ErrorFragment | JsonFragment): ErrorFragment;
    static fromString(value: string): ErrorFragment;
    static isErrorFragment(value: any): value is ErrorFragment;
}

export type CoerceFunc = (type: string, value: any) => any;
export class AbiCoder {
    readonly coerceFunc?: CoerceFunc | undefined;
    constructor(coerceFunc?: CoerceFunc | undefined);
    _getCoder(param: ParamType): Coder;
    _getWordSize(): number;
    _getReader(data: Uint8Array, allowLoose?: boolean): Reader;
    _getWriter(): Writer;
    getDefaultValue(types: ReadonlyArray<string | ParamType>): EthAbiResult;
    encode(types: ReadonlyArray<string | ParamType>, values: ReadonlyArray<any>): string;
    decode(types: ReadonlyArray<string | ParamType>, data: BytesLike, loose?: boolean): EthAbiResult;
}
export const defaultAbiCoder: AbiCoder;

export { checkResultErrors, EthAbiResult };
export class LogDescription extends Description<LogDescription> {
    readonly eventFragment: EventFragment;
    readonly name: string;
    readonly signature: string;
    readonly topic: string;
    readonly args: EthAbiResult;
}
export class TransactionDescription extends Description<TransactionDescription> {
    readonly functionFragment: FunctionFragment;
    readonly name: string;
    readonly args: EthAbiResult;
    readonly signature: string;
    readonly sighash: string;
    readonly value: BigNumber;
}
export class Indexed extends Description<Indexed> {
    readonly hash: string | null;
    readonly _isIndexed: boolean;
    static isIndexed(value: any): value is Indexed;
}
export class Interface {
    readonly fragments: ReadonlyArray<Fragment>;
    readonly errors: {
        [name: string]: ErrorFragment;
    };
    readonly events: {
        [name: string]: EventFragment;
    };
    readonly functions: {
        [name: string]: FunctionFragment;
    };
    readonly structs: {
        [name: string]: any;
    };
    readonly deploy: ConstructorFragment;
    readonly _abiCoder: AbiCoder;
    readonly _isInterface: boolean;
    constructor(fragments: string | ReadonlyArray<Fragment | JsonFragment | string>);
    format(format?: string): string | string[];
    static getAbiCoder(): AbiCoder;
    static getSighash(fragment: ErrorFragment | FunctionFragment): string;
    static getEventTopic(eventFragment: EventFragment): string;
    getFunction(nameOrSignatureOrSighash: string): FunctionFragment;
    getEvent(nameOrSignatureOrTopic: string): EventFragment;
    getError(nameOrSignatureOrSighash: string): ErrorFragment;
    getSighash(functionFragment: FunctionFragment | string): string;
    getEventTopic(eventFragment: EventFragment | string): string;
    _decodeParams(params: ReadonlyArray<ParamType>, data: BytesLike): EthAbiResult;
    _encodeParams(params: ReadonlyArray<ParamType>, values: ReadonlyArray<any>): string;
    encodeDeploy(values?: ReadonlyArray<any>): string;
    decodeFunctionData(functionFragment: FunctionFragment | string, data: BytesLike): EthAbiResult;
    encodeFunctionData(functionFragment: FunctionFragment | string, values?: ReadonlyArray<any>): string;
    decodeFunctionResult(functionFragment: FunctionFragment | string, data: BytesLike): EthAbiResult;
    encodeFunctionResult(functionFragment: FunctionFragment | string, values?: ReadonlyArray<any>): string;
    encodeFilterTopics(eventFragment: EventFragment | string, values: ReadonlyArray<any>): (string | string[] | null)[];
    encodeEventLog(eventFragment: EventFragment | string, values: ReadonlyArray<any>): {
        data: string;
        topics: string[];
    };
    decodeEventLog(eventFragment: EventFragment | string, data: BytesLike, topics?: ReadonlyArray<string>): EthAbiResult;
    parseTransaction(tx: {
        data: string;
        value?: BigNumberish;
    }): TransactionDescription | null;
    parseLog(log: {
        topics: string[];
        data: string;
    }): LogDescription | null;
    static isInterface(value: any): value is Interface;
}

export function encodeRequest(request: HttpRequest): Uint8Array;
export function decodeResponse(buf: Uint8Array): Response;

export class DataViewJSBIHelperNoBigInt {
    static setBigInt64(view: DataView, byteOffset: number, value: JSBI, littleEndian?: boolean | undefined): void;
    static getBigInt64(view: DataView, byteOffset: number, littleEndian?: boolean | undefined): JSBI;
    static setBigUint64(view: DataView, byteOffset: number, value: JSBI, littleEndian?: boolean | undefined): void;
    static getBigUint64(view: DataView, byteOffset: number, littleEndian?: boolean | undefined): JSBI;
}
export class DataViewJSBIHelperWithBigInt {
    static setBigInt64(view: DataView, byteOffset: number, value: JSBI, littleEndian?: boolean | undefined): void;
    static getBigInt64(view: DataView, byteOffset: number, littleEndian?: boolean | undefined): JSBI;
    static setBigUint64(view: DataView, byteOffset: number, value: JSBI, littleEndian?: boolean | undefined): void;
    static getBigUint64(view: DataView, byteOffset: number, littleEndian?: boolean | undefined): JSBI;
}

export class BuckyFixedBuffer implements RawEncode {
    buffer: Uint8Array;
    constructor(buffer: Uint8Array);
    raw_measure(ctx?: any, purpose?: RawEncodePurpose): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any, purpose?: RawEncodePurpose): BuckyResult<Uint8Array>;
    value(): Uint8Array;
}
export class BuckyFixedBufferDecoder implements RawDecode<BuckyFixedBuffer> {
    size: number;
    constructor(size: number);
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[BuckyFixedBuffer, Uint8Array]>;
}
export class BuckyBuffer implements RawEncode {
    buffer: Uint8Array;
    size: BuckySize;
    constructor(buf: Uint8Array);
    value(): Uint8Array;
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
}
export class BuckyBufferDecoder implements RawDecode<BuckyBuffer> {
    raw_decode(buf: Uint8Array): BuckyResult<[BuckyBuffer, Uint8Array]>;
}
export function fromHexString(hexString: string): Uint8Array;
export function toHexString(bytes: Uint8Array): string;

export class BuckyHashMapKeys<K, V> implements Iterable<K> {
    values: IterableIterator<[K, V]>;
    constructor(values: IterableIterator<[K, V]>);
    [Symbol.iterator](): this;
    next(): IteratorResult<K>;
}
export class BuckyHashMapValues<K, V> implements Iterable<V> {
    values: IterableIterator<[K, V]>;
    constructor(values: IterableIterator<[K, V]>);
    [Symbol.iterator](): this;
    next(): IteratorResult<V>;
}
export class BuckyHashMapEntries<K, V> implements Iterable<[K, V]> {
    values: IterableIterator<[K, V]>;
    constructor(values: IterableIterator<[K, V]>);
    [Symbol.iterator](): this;
    next(): IteratorResult<[K, V]>;
}
export class BuckyHashMap<K extends RawEncode & Compareable<K>, V extends RawEncode> implements RawEncode {
    constructor();
    get size(): number;
    clear(): void;
    delete(key: K): void;
    has(key: K): boolean;
    set(key: K, v: V): void;
    get(key: K): V | undefined;
    keys(): IterableIterator<K>;
    values(): IterableIterator<V>;
    entries(): IterableIterator<[K, V]>;
    forEach(callback: (value: V, key: K, map: BuckyHashMap<K, V>) => void): void;
    to<K1, V1>(ke: (k: K) => K1, ve: (v: V) => V1): Map<K1, V1>;
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
}
export class BuckyHashMapDecoder<K extends RawEncode & Compareable<K>, V extends RawEncode> implements RawDecode<BuckyHashMap<K, V>> {
    readonly size_decoder: BuckySizeDecoder;
    readonly key_decoder: RawDecode<K>;
    readonly value_decoder: RawDecode<V>;
    constructor(key_decoder: RawDecode<K>, value_decoder: RawDecode<V>);
    raw_decode(buf: Uint8Array): BuckyResult<[BuckyHashMap<K, V>, Uint8Array]>;
}

export class BuckyHashSetValues<V> implements Iterable<V> {
    values: IterableIterator<V>;
    constructor(values: IterableIterator<V>);
    [Symbol.iterator](): this;
    next(): IteratorResult<V>;
}
export class BuckyHashSetEntries<V> implements Iterable<[V, V]> {
    values: IterableIterator<V>;
    constructor(values: IterableIterator<V>);
    [Symbol.iterator](): this;
    next(): IteratorResult<[V, V]>;
}
export class BuckyHashSet<T extends RawEncode & Compareable<T>> implements RawEncode {
    constructor();
    get size(): number;
    add(v: T): BuckyHashSet<T>;
    clear(): void;
    delete(v: T): boolean;
    has(v: T): boolean;
    keys(): IterableIterator<T>;
    values(): IterableIterator<T>;
    entries(): IterableIterator<[T, T]>;
    forEach(callback: (value: T, value2: T, set: BuckyHashSet<T>) => void): void;
    to<K1>(ke: (k: T) => K1): Set<K1>;
    array(): T[];
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
}
export class BuckyHashSetDecoder<T extends RawEncode & Compareable<T>> implements RawDecode<BuckyHashSet<T>> {
    readonly decoder: RawDecode<T>;
    readonly size_decoder: BuckySizeDecoder;
    constructor(decoder: RawDecode<T>);
    raw_decode(buf: Uint8Array): BuckyResult<[BuckyHashSet<T>, Uint8Array]>;
}

export class BuckyMap<K extends RawEncode, V extends RawEncode> implements RawEncode {
    constructor(val: Map<K, V>);
    static from<K extends RawEncode, V extends RawEncode, K1, V1>(val: Map<K1, V1>, ke: (k: K1) => K, ve: (v: V1) => V): BuckyMap<K, V>;
    value(): Map<K, V>;
    to<K1, V1>(ke: (k: K) => K1, ve: (v: V) => V1): Map<K1, V1>;
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
}
export class BuckyMapDecoder<K extends RawEncode, V extends RawEncode> implements RawDecode<BuckyMap<K, V>> {
    readonly size_decoder: BuckySizeDecoder;
    readonly key_decoder: RawDecode<K>;
    readonly value_decoder: RawDecode<V>;
    constructor(key_decoder: RawDecode<K>, value_decoder: RawDecode<V>);
    raw_decode(buf: Uint8Array): BuckyResult<[BuckyMap<K, V>, Uint8Array]>;
}

/**
    * 
    * 1. RawEcode
    * 2. 
    * 3. Rust
    * 4. 
    * 5. 
    * 6. JavaScript/TypeScript
    */
type Int = "u8" | "i8" | "u16" | "i16" | "u32" | "i32" | "u64" | "i64" | "u128";
/**
    * JavaScript
    */
export class BuckyNumber implements RawEncode {
        readonly type: Int;
        val: JSBI;
        constructor(type: Int, val: JSBI | number | string);
        value(): JSBI;
        raw_measure(): BuckyResult<number>;
        raw_encode(buf: Uint8Array, littleEndian?: boolean): BuckyResult<Uint8Array>;
        toBigInt(): JSBI;
        toNumber(): number;
}
export class BuckyNumberDecoder implements RawDecode<BuckyNumber> {
        readonly type: Int;
        constructor(type: Int);
        raw_decode(buf: Uint8Array, littleEndian?: boolean): BuckyResult<[BuckyNumber, Uint8Array]>;
}
export {};

export class BuckyResultEncoder<T extends RawEncode, E extends RawEncode> implements RawEncode {
    result: Result<T, E>;
    constructor(result: Result<T, E>);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class BuckyResultDecoder<T extends RawEncode, D extends RawDecode<T>, E extends RawEncode, ED extends RawDecode<E>> implements RawDecode<Result<T, E>> {
    decoder: D;
    error_decoder: ED;
    constructor(decoder: D, error_decoder: ED);
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[Result<T, E>, Uint8Array]>;
}

export class BuckySet<T extends RawEncode> implements RawEncode {
    constructor(val: Set<T>);
    value(): Set<T>;
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
}
export class BuckySetDecoder<T extends RawEncode> implements RawDecode<BuckySet<T>> {
    readonly decoder: RawDecode<T>;
    readonly size_decoder: BuckySizeDecoder;
    constructor(decoder: RawDecode<T>);
    raw_decode(buf: Uint8Array): BuckyResult<[BuckySet<T>, Uint8Array]>;
}

export class BuckyString implements RawEncode, Compareable<BuckyString> {
    constructor(value: string);
    hashCode(): symbol;
    equals(other: BuckyString): boolean;
    value(): string;
    toString(): string;
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class BuckyStringDecoder implements RawDecode<BuckyString> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[BuckyString, Uint8Array]>;
}
export class BuckyVarString implements RawEncode, Compareable<BuckyVarString> {
    constructor(value: string);
    hashCode(): symbol;
    equals(other: BuckyVarString): boolean;
    value(): string;
    toString(): string;
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class BuckyVarStringDecoder implements RawDecode<BuckyVarString> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[BuckyVarString, Uint8Array]>;
}

export class BuckySize implements RawEncode {
    constructor(size: number | JSBI | string);
    raw_measure(ctx?: any, purpose?: RawEncodePurpose): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any, purpose?: RawEncodePurpose): BuckyResult<Uint8Array>;
}
export class BuckySizeDecoder implements RawDecode<number> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[number, Uint8Array]>;
}

export class BuckyTuple implements RawEncode {
    members: RawEncode[];
    constructor(members: RawEncode[]);
    raw_measure(ctx?: any, purpose?: RawEncodePurpose): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any, purpose?: RawEncodePurpose): BuckyResult<Uint8Array>;
    index<T extends RawEncode>(index: number): T;
}
export class BuckyTupleDecoder<U extends RawEncode, T extends RawDecode<U>> implements RawDecode<BuckyTuple> {
    decoders: T[];
    constructor(decoders: T[]);
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[BuckyTuple, Uint8Array]>;
}

global {
    interface Uint8Array {
        offset(offset: number): Uint8Array;
        offsetUint16Array(offset: number): Uint16Array;
        offsetUint32Array(offset: number): Uint32Array;
        offsetView(offset: number): DataView;
        toHex(): string;
        fromHex(hex: string): BuckyResult<Uint8Array>;
    }
}
export {};

export enum Protocol {
    Unk = 0,
    Tcp = 1,
    Udp = 2
}
export class IpAddr implements RawEncode {
    is_ipv4: boolean;
    ip: string;
    static V4(ip: string): IpAddr;
    static V6(ip: string): IpAddr;
    match<T>(visitor: {
        V4?: (ip: string) => T;
        V6?: (ip: string) => T;
    }): T | undefined;
    toString(): string;
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class IpAddrDecoder implements RawDecode<IpAddr> {
    raw_decode(buf: Uint8Array): BuckyResult<[IpAddr, Uint8Array]>;
}
export class SocketAddr implements RawEncode {
    is_ipv4: boolean;
    ip: string;
    port: number;
    constructor(is_ipv4: boolean, ip: string, port: number);
    toString(): string;
    static fromString(is_ipv4: boolean, addr: string): BuckyResult<SocketAddr>;
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class Endpoint implements RawEncode {
    is_static_wan: boolean;
    protocol: Protocol;
    addr: SocketAddr;
    constructor(is_static_wan: boolean, protocol: Protocol, addr: SocketAddr);
    static fromString(endpoint: string): BuckyResult<Endpoint>;
    toString(): string;
    flag(): number;
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class EndPointDecoder implements RawDecode<Endpoint> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[Endpoint, Uint8Array]>;
}

export function log(...args: any[]): void;
export function warn(...args: any[]): void;
export function error(...args: any[]): void;
export const cyfs_log_config: {
    enable_base_log: boolean;
    enable_base_trace: boolean;
    enable_base_warn: boolean;
    enable_base_error: boolean;
};
export function base_log(...args: any[]): void;
export function base_trace(...args: any[]): void;
export function base_warn(...args: any[]): void;
export function base_error(...args: any[]): void;

export const CYFS_OBJECT_ID = "cyfs-object-id";
export const CYFS_OBJECT = "cyfs-object";
export const CYFS_RESULT = "cyfs-result";
export const CYFS_API_LEVEL = "cyfs-api-level";
export const CYFS_NON_ACTION = "cyfs-non-action";
export const CYFS_NDN_ACTION = "cyfs-ndn-action";
export const CYFS_DEC_ID = "cyfs-dec-id";
export const CYFS_FILTER_DEC_ID = "cyfs-filter-dec-id";
export const CYFS_INNER_PATH = "cyfs-inner-path";
export const CYFS_OWNER_ID = "cyfs-owner-id";
export const CYFS_AUTHOR_ID = "cyfs-author-id";
export const CYFS_DEVICE_ID = "cyfs-device-id";
export const CYFS_OOD_DEVICE_ID = "cyfs-ood-device-id";
export const CYFS_ZONE_ID = "cyfs-zone-id";
export const CYFS_ATTRIBUTES = "cyfs-attributes";
export const CYFS_FILE_TYPE = "cyfs-file-type";
export const CYFS_SIGN_OBJ_ID = "cyfs-sign-obj-id";
export const CYFS_SIGN_OBJ = "cyfs-sign-obj";
export const CYFS_VERIFY_SIGNS = "cyfs-verify-signs";
export const CYFS_VERIFY_TYPE = "cyfs-verify-type";
export const CYFS_SIGN_TYPE = "cyfs-sign-type";
export const CYFS_SIGN_FLAGS = "cyfs-sign-flags";
export const CYFS_VERIFY_RET = "cyfs-verify-ret";
export const CYFS_SIGN_RET = "cyfs-sign-ret";
export const CYFS_FLAGS = "cyfs-flags";
export const CYFS_TARGET = "cyfs-target";
export const CYFS_REFERER_OBJECT = "cyfs-referer-object";
export const CYFS_FILTER_FLAGS = "cyfs-filter-flags";
export const CYFS_TIMEOUT = "cyfs-timeout";
export const CYFS_OBJ_TYPE = "cyfs-obj-type";
export const CYFS_OBJ_TYPE_CODE = "cyfs-obj-type-code";
export const CYFS_CREATE_TIME = "cyfs-create-time";
export const CYFS_UPDATE_TIME = "cyfs-update-time";
export const CYFS_INSERT_TIME = "cyfs-insert-time";
export const CYFS_PAGE_SIZE = "cyfs-page-size";
export const CYFS_PAGE_INDEX = "cyfs-page-index";
export const CYFS_OBJECTS = "cyfs-objects";
export const CYFS_OBJECT_UPDATE_TIME = "cyfs-object-update-time";
export const CYFS_OBJECT_EXPIRES_TIME = "cyfs-object-expires-time";
export const CYFS_CHUNK_STATE = "cyfs-chunk-state";
export const CYFS_CHUNK_EXIST = "cyfs-chunk-exist";
export const CYFS_REMOTE_DEVICE = "cyfs-remote-device";
export const CYFS_REMOTE_VPORT = "cyfs-remote-vport";
export const CYFS_ROOT_STATE_ACTION = "cyfs-root-state-aciton";
export const CYFS_OP_ENV_ACTION = "cyfs-op-env-action";
export const CYFS_OP_ENV_SID = "cyfs-op-env-sid";
export const CYFS_OP_ENV_TYPE = "cyfs-op-env-type";
export const CYFS_OP_ENV_PATH = "cyfs-op-env-path";
export const CYFS_OP_ENV_KEY = "cyfs-op-env-key";
export const CYFS_OP_ENV_VALUE = "cyfs-op-env-value";

export interface BaseOption<T> {
    is_some(): boolean;
    is_none(): boolean;
    unwrap(): T;
    ok_or(): BuckyResult<T>;
    to<V1>(ve: (v: T) => V1): Option<V1>;
    map(mapper: (obj: T) => T): void;
}
export class SomeOption<T> implements BaseOption<T> {
    constructor(value: T);
    is_some(): boolean;
    is_none(): boolean;
    unwrap(): T;
    ok_or(): BuckyResult<T>;
    to<V1>(ve: (v: T) => V1): Option<V1>;
    map(mapper: (obj: T) => T): void;
}
export class NoneOption implements BaseOption<never> {
    constructor();
    is_some(): boolean;
    is_none(): boolean;
    unwrap(): never;
    ok_or(): BuckyResult<never>;
    to<V1>(ve: (v: never) => V1): NoneOption;
    map(mapper: (obj: never) => never): void;
}
export type Option<T> = (SomeOption<T> | NoneOption) & BaseOption<T>;
export function Some<T>(val: T): Option<T>;
export const None: NoneOption;
export class OptionEncoder<T extends RawEncode> implements RawEncode {
    val: Option<T>;
    constructor(val: Option<T>);
    value(): Option<T>;
    static from<V extends RawEncode, V1>(val: Option<V1>, ve: (v: V1) => V): OptionEncoder<V>;
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
}
export class OptionWrapper<T extends RawEncode> implements RawEncode {
    constructor(v: Option<T>);
    value(): Option<T>;
    to<V1>(ve: (v: T) => V1): Option<V1>;
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class OptionDecoder<T extends RawEncode> implements RawDecode<OptionWrapper<T>> {
    readonly decoder: RawDecode<T>;
    constructor(decoder: RawDecode<T>);
    raw_decode(buf: Uint8Array): BuckyResult<[OptionWrapper<T>, Uint8Array]>;
}

export const CHUNK_MANAGER_PORT: number;
export const FILE_MANAGER_PORT: number;
export const ACC_SERVICE_PORT: number;
export const GATEWAY_CONTROL_PORT: number;
export const NON_STACK_HTTP_PORT: number;
export const NON_STACK_WS_PORT: number;
export const OOD_DAEMON_CONTROL_PORT: number;
export const CYFS_RUNTIME_DAEMON_CONTROL_PORT: number;
export const CYFS_RUNTIME_NON_STACK_HTTP_PORT: number;
export const CYFS_RUNTIME_NON_STACK_WS_PORT: number;
export const OOD_BDT_STACK_PORT: number;
export const CYFS_RUNTIME_BDT_STACK_PORT: number;
export const NON_STACK_BDT_VPORT: number;
export const NON_STACK_SYNC_BDT_VPORT: number;
export const PROXY_MINER_SOCKS5_PORT: number;
export const IP_RELAY_MINER_PORT: number;
export const CYFS_META_MINER_PORT: number;
export const CACHE_MINER_PORT: number;
export const DNS_PROXY_MINER_PORT: number;
export const ALWAYS_RUN_MINER_PORT: number;
export const DSG_CHAIN_MINER_PORT: number;

/**
    * 
    */
export enum RawEncodePurpose {
        Serialize = 0,
        Hash = 1
}
export interface RawEncode {
        raw_measure(ctx?: any, purpose?: RawEncodePurpose): BuckyResult<number>;
        raw_encode(buf: Uint8Array, ctx?: any, purpose?: RawEncodePurpose): BuckyResult<Uint8Array>;
        encode_to_buf?: (purpose?: RawEncodePurpose) => BuckyResult<Uint8Array>;
        raw_hash_encode?: () => BuckyResult<HashValue>;
}
/**
    * 
    */
export type EncodeBuilder<T extends RawEncode> = new (...constructorArgs: any[]) => T;
/**
    * 
    */
export class ContentRawDecodeContext {
        readonly version: number;
        readonly format: number;
        constructor(version: number, format: number);
}
export interface RawDecode<T> {
        raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[T, Uint8Array]>;
}
export abstract class RawHexDecode<T> implements RawDecode<T> {
        raw_decode_from_hex(hex: string): BuckyResult<[T, Uint8Array]>;
        abstract raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[T, Uint8Array]>;
}
/**
    * 
    */
export type DecodeBuilder<T extends RawEncode, D extends RawDecode<T>> = new (...constructorArgs: any[]) => D;
export interface Compareable<T> {
        hashCode(): symbol;
        equals(other: T): boolean;
}
export function to_buf<T extends RawEncode>(self: T): BuckyResult<Uint8Array>;
export function to_vec<T extends RawEncode>(self: T): BuckyResult<Uint8Array>;
export function to_hex<T extends RawEncode>(self: T): BuckyResult<string>;
export function from_buf<T>(buf: Uint8Array, decoder: RawDecode<T>): BuckyResult<T>;
export function from_hex<T extends RawEncode, D extends RawDecode<T>>(decoder: D, hex: string): BuckyResult<T>;
export function buffer_from_hex(hex: string): BuckyResult<Uint8Array>;

/**
    * 
    * @param t RawEncode
    */
export function raw_hash_encode<T extends RawEncode>(t: T): BuckyResult<HashValue>;
/**
    * 
    * @param decoder 
    * @param buf Buffer
    */
export function raw_hash_decode<T, D extends RawDecode<T>>(decoder: D, buf: Uint8Array): BuckyResult<[HashValue, Uint8Array]>;

export const BUCKY_SYSTEM_ERROR_CODE_START = 0;
export const BUCKY_SYSTEM_ERROR_CODE_END = 5000;
export const BUCKY_META_ERROR_CODE_START = 5000;
export const BUCKY_META_ERROR_CODE_END = 6000;
export const BUCKY_META_ERROR_CODE_MAX: number;
export const BUCKY_DEC_ERROR_CODE_START = 15000;
export const BUCKY_DEC_ERROR_CODE_END = 65535;
export const BUCKY_DEC_ERROR_CODE_MAX: number;
export enum BuckyErrorCode {
    Ok = 0,
    Failed = 1,
    InvalidParam = 2,
    Timeout = 3,
    NotFound = 4,
    AlreadyExists = 5,
    NotSupport = 6,
    ErrorState = 7,
    InvalidFormat = 8,
    Expired = 9,
    OutOfLimit = 10,
    InternalError = 11,
    PermissionDenied = 12,
    ConnectionRefused = 13,
    ConnectionReset = 14,
    ConnectionAborted = 15,
    NotConnected = 16,
    AddrInUse = 18,
    AddrNotAvailable = 19,
    Interrupted = 20,
    InvalidInput = 21,
    InvalidData = 22,
    WriteZero = 23,
    UnexpectedEof = 24,
    BrokenPipe = 25,
    WouldBlock = 26,
    UnSupport = 27,
    Unmatch = 28,
    ExecuteError = 29,
    Reject = 30,
    Ignored = 31,
    InvalidSignature = 32,
    AlreadyExistsAndSignatureMerged = 33,
    ConnectFailed = 40,
    ConnectInterZoneFailed = 41,
    InnerPathNotFound = 42,
    Conflict = 50,
    MongoDBError = 99,
    SqliteError = 100,
    UrlError = 101,
    ZipError = 102,
    HttpError = 103,
    JsonError = 104,
    HexError = 105,
    RsaError = 106,
    CryptoError = 107,
    MpscSendError = 108,
    MpscRecvError = 109,
    IoError = 110,
    NetworkError = 111,
    CodeError = 250,
    UnknownBdtError = 253,
    UnknownIOError = 254,
    Unknown = 255,
    Pending = 256,
    NotChange = 257,
    NotMatch = 258,
    NotImplement = 259,
    NotInit = 260,
    ParseError = 261,
    NotHandled = 262,
    MetaError = 5000,
    DecError = 15000
}
export class BuckyErrorCodeEx {
    readonly m_code: BuckyErrorCode;
    readonly m_value: number;
    get code(): BuckyErrorCode;
    get value(): number;
    is_system_error(): boolean;
    is_meta_error(): boolean;
    is_dec_error(): boolean;
    to_number(): number;
    static parse(code: number | string): BuckyErrorCodeEx;
    constructor(code: BuckyErrorCode, value: number);
}
export function is_system_error_code(code: number): boolean;
export function is_meta_error_code(code: number): boolean;
export function is_dec_error_code(code: number): boolean;
export function new_meta_error(meta_err: number): BuckyErrorCodeEx;
export function new_dec_error(dec_err: number): BuckyErrorCodeEx;
export function error_code_from_number(err: number): BuckyErrorCodeEx;
export class BuckyError {
    readonly m_code: BuckyErrorCodeEx;
    readonly m_msg: string;
    readonly m_origin?: string;
    constructor(code: number | string | BuckyErrorCodeEx, msg: string, origin?: string);
    static new_meta_error(meta_err: number, msg: string, origin?: string): BuckyError;
    static new_dec_error(dec_err: number, msg: string, origin?: string): BuckyError;
    static from(arg: string | BuckyErrorCode): BuckyError;
    get code(): BuckyErrorCode;
    get code_ex(): BuckyErrorCodeEx;
    is_system_error(): boolean;
    is_meta_error(): boolean;
    is_dec_error(): boolean;
    get value(): number;
    get msg(): string;
    get origin(): string | undefined;
    format(): string;
    error_with_log<T>(msg: string): BuckyResult<T>;
    toString(): string;
}
export type BuckyResult<T> = Result<T, BuckyError>;

export function bucky_time_now(): JSBI;
export function bucky_time(date: Date): JSBI;
export function bucky_time_2_js_time(val: JSBI): number;
export function bucky_time_2_js_date(val: JSBI): Date;
export function js_time_to_bucky_time(val: number): JSBI;
export function js_date_to_bucky_time(date: Date): JSBI;
export function sleep(ms: number): Promise<unknown>;

export class Vec<T extends RawEncode> implements RawEncode {
    constructor(val: T[]);
    value(): T[];
    static from<V extends RawEncode, V1>(val: V1[], ve: (v: V1) => V): Vec<V>;
    to<V1>(ve: (v: T) => V1): V1[];
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
}
export class VecDecoder<T extends RawEncode> implements RawDecode<Vec<T>> {
    readonly size_decoder: BuckySizeDecoder;
    readonly decoder: RawDecode<T>;
    constructor(decoder: RawDecode<T>);
    raw_decode(buf: Uint8Array): BuckyResult<[Vec<T>, Uint8Array]>;
}

export function get_country_list(): any;
export function get_area_info(country_id: string, city_id: string, locale?: string): {
    country_name: string;
    state_name: string;
    city_name: string;
} | null;

export const CFYS_ROOT_NAME: string;
export function default_cyfs_root_path(): string;
export function bind_cyfs_root_path(root_path: string): void;
export function get_cyfs_root_path(): string;
export function get_temp_path(): string;
export function get_log_dir(service_name: string): string;
export function get_app_log_dir(app_name: string): string;
export function get_app_data_dir(app_name: string): string;

export interface EventListenerAsyncRoutine<R> {
    call(param: any): Promise<BuckyResult<R>>;
}
export interface EventListenerAsyncRoutineT<P, R> {
    call(param: P): Promise<BuckyResult<R>>;
}

export const OBJECT_CONTENT_CODEC_FORMAT_RAW: number;
export const OBJECT_CONTENT_CODEC_FORMAT_PROTOBUF: number;
export const OBJECT_CONTENT_CODEC_FORMAT_JSON: number;

export { protos };

/**
    * KeyMixHash
    */
export const KEY_MIX_LEN: number;
export class KeyMixHash implements RawEncode {
        m_buf: Uint8Array;
        constructor(buf: Uint8Array);
        as_slice(): Uint8Array;
        length(): number;
        static default(): KeyMixHash;
        static copy_from_slice(buf: Uint8Array): KeyMixHash;
        raw_measure(): BuckyResult<number>;
        raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
}
export class KeyMixHashDecoder implements RawDecode<KeyMixHash> {
        raw_decode(buf: Uint8Array): BuckyResult<[KeyMixHash, Uint8Array]>;
}
/**
    * AesKey
    */
export const AES_KEY_LEN: number;
export class AesKey implements RawEncode {
        m_buf: Uint8Array;
        constructor(buf: Uint8Array);
        as_slice(): Uint8Array;
        length(): number;
        static default(): AesKey;
        static random(): AesKey;
        static mix_hash(salt: Option<JSBI>): KeyMixHash;
        static copy_from_slice(buf: Uint8Array): AesKey;
        raw_measure(): BuckyResult<number>;
        raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
}
export class AesKeyDecoder implements RawDecode<AesKey> {
        raw_decode(buf: Uint8Array): BuckyResult<[AesKey, Uint8Array]>;
}

export const HASH_VALUE_LEN = 32;
export class HashValue implements RawEncode {
    m_buf: Uint8Array;
    constructor(buf: Uint8Array);
    as_slice(): Uint8Array;
    length(): number;
    static default(): HashValue;
    static copy_from_slice(buf: Uint8Array): HashValue;
    static hash_data(data: Uint8Array): HashValue;
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
    to_base_58(): string;
    to_hex_string(): string;
    static from_hex_string(s: string): BuckyResult<HashValue>;
}
export class HashValueDecoder implements RawDecode<HashValue> {
    raw_decode(buf: Uint8Array): BuckyResult<[HashValue, Uint8Array]>;
}

export abstract class PrivateKey implements RawEncode {
    readonly type: number;
    constructor(type: number);
    abstract raw_measure(ctx?: any, purpose?: RawEncodePurpose): BuckyResult<number>;
    abstract raw_encode(buf: Uint8Array, ctx?: any, purpose?: RawEncodePurpose): BuckyResult<Uint8Array>;
    toString(): string;
    static generate_rsa(bits: number): BuckyResult<PrivateKey>;
    static generate_secp256k1(): BuckyResult<PrivateKey>;
    static generate_sm2(): BuckyResult<PrivateKey>;
    abstract public(): PublicKey;
    abstract sign(data: Uint8Array, sign_source: SignatureSource): Signature;
    abstract decrypt(input: Uint8Array, out: Uint8Array): BuckyResult<number>;
    to_vec(): BuckyResult<Uint8Array>;
}
export class RSAPrivateKey extends PrivateKey {
    code: number;
    value: NodeRSA;
    constructor(code: number, value: NodeRSA);
    raw_measure(ctx?: any, purpose?: RawEncodePurpose): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any, purpose?: RawEncodePurpose): BuckyResult<Uint8Array>;
    public(): PublicKey;
    sign(data: Uint8Array, sign_source: SignatureSource): Signature;
    decrypt(input: Uint8Array, out: Uint8Array): BuckyResult<number>;
}
export class Secp256k1PrivateKey extends PrivateKey {
    constructor();
    raw_measure(ctx?: any, purpose?: RawEncodePurpose): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any, purpose?: RawEncodePurpose): BuckyResult<Uint8Array>;
    public(): PublicKey;
    sign(data: Uint8Array, sign_source: SignatureSource): Signature;
    decrypt(input: Uint8Array, out: Uint8Array): BuckyResult<number>;
}
export class SM2PrivateKey extends PrivateKey {
    constructor();
    raw_measure(ctx?: any, purpose?: RawEncodePurpose): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any, purpose?: RawEncodePurpose): BuckyResult<Uint8Array>;
    public(): PublicKey;
    sign(data: Uint8Array, sign_source: SignatureSource): Signature;
    decrypt(input: Uint8Array, out: Uint8Array): BuckyResult<number>;
}
export class PrivatekeyDecoder implements RawDecode<PrivateKey> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[PrivateKey, Uint8Array]>;
}

/*************************************
    * 
    *************************************/
export const SIGNATURE_REF_INDEX: number;
export const SIGNATURE_OBJECT: number;
export const SIGNATURE_KEY: number;
export const SIGNATURE_SOURCE_REFINDEX_REF_OBJ_BEGIN: number;
export const SIGNATURE_SOURCE_REFINDEX_REF_OBJ_END: number;
export const SIGNATURE_SOURCE_REFINDEX_SELF: number;
export const SIGNATURE_SOURCE_REFINDEX_OWNER: number;
export const SIGNATURE_SOURCE_REFINDEX_AUTHOR: number;
export const SIGNATURE_SOURCE_REFINDEX_ZONE_OOD_BEGIN: number;
export const SIGNATURE_SOURCE_REFINDEX_ZONE_OOD_END: number;
export const SIGN_DATA_FLAG_RSA1024: number;
export const SIGN_DATA_FLAG_RSA2048: number;
export const SIGN_DATA_FLAG_ECC: number;
export const SIGN_DATA_LEN_RSA1024: number;
export const SIGN_DATA_LEN_RSA2048: number;
export const SIGN_DATA_LEN_ECC: number;
export const SIGN_DATA_UNIT = 4;
export const SIGN_DATA_SIZE_RSA1024: number;
export const SIGN_DATA_SIZE_RSA2048: number;
export const SIGN_DATA_SIZE_ECC: number;
export interface SignDataPartten<T> {
        Rsa1024SignData: (obj: Rsa1024SignData) => T;
        Rsa2048SignData: (obj: Rsa2048SignData) => T;
        EccSignData: (obj: EccSignData) => T;
}
export interface SignDataVisitor {
        match<T>(p: SignDataPartten<T>): T;
}
export abstract class SignDataBase implements RawEncode {
        type: number;
        value: Uint8Array;
        constructor(type: number, value: Uint8Array);
        as_slice(): Uint8Array;
        raw_measure(): BuckyResult<number>;
        raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
        to_base_58(): string;
}
export class SignDataDecoder implements RawDecode<SignData> {
        constructor();
        raw_decode(buf: Uint8Array): BuckyResult<[SignData, Uint8Array]>;
}
export class Rsa1024SignData extends SignDataBase implements SignDataVisitor {
        constructor(value: Uint8Array);
        match<T>(p: SignDataPartten<T>): T;
}
export class Rsa2048SignData extends SignDataBase implements SignDataVisitor {
        constructor(value: Uint8Array);
        match<T>(p: SignDataPartten<T>): T;
}
export class EccSignData extends SignDataBase implements SignDataVisitor {
        constructor(value: Uint8Array);
        match<T>(p: SignDataPartten<T>): T;
}
export type SignData = Rsa1024SignData | Rsa2048SignData | EccSignData;
export interface SignatureSourcePattern<T> {
        RefIndex: (s: number) => T;
        Object: (s: ObjectLink) => T;
        Key: (s: PublicKeyValue) => T;
}
export interface SignatureSourceMatch {
        match<T>(p: SignatureSourcePattern<T>): T;
}
export class SignatureRefIndex implements SignatureSourceMatch {
        s: number;
        constructor(s: number);
        match<T>(p: SignatureSourcePattern<T>): T;
}
export class SignatureObject implements SignatureSourceMatch {
        s: ObjectLink;
        constructor(s: ObjectLink);
        match<T>(p: SignatureSourcePattern<T>): T;
}
export class SignatureKey implements SignatureSourceMatch {
        s: PublicKeyValue;
        constructor(s: PublicKeyValue);
        match<T>(p: SignatureSourcePattern<T>): T;
}
export type SignatureSource = SignatureRefIndex | SignatureObject | SignatureKey;
export type SignatureSourceLite = number | ObjectLink | PublicKeyValue;
export class Signature implements RawEncode {
        m_sign_source: SignatureSource;
        m_sign_key_index: number;
        m_sign_time: JSBI;
        m_sign: SignData;
        constructor(sign_source: SignatureSource, sign_key_index: number, sign_time: JSBI, sign: SignData);
        get sign_key_index(): number;
        get sign_time(): JSBI;
        get sign_source(): SignatureSource;
        get sign(): SignData;
        sign_source_with_ref_index(): number;
        raw_measure(): BuckyResult<number>;
        raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
}
export class SignatureDecoder implements RawDecode<Signature> {
        raw_decode(buf: Uint8Array): BuckyResult<[Signature, Uint8Array]>;
}
/*************************************
    * 
    *************************************/
export const RAW_PUBLIC_KEY_RSA_1024_CODE: number;
export const RAW_PUBLIC_KEY_RSA_1024_LENGTH: number;
export const RAW_PUBLIC_KEY_RSA_2048_CODE: number;
export const RAW_PUBLIC_KEY_RSA_2048_LENGTH: number;
export const RAW_PUBLIC_KEY_RSA_3072_CODE: number;
export const RAW_PUBLIC_KEY_RSA_3072_LENGTH: number;
export const RAW_PUBLIC_KEY_SECP256K1_CODE: number;
export const RAW_PUBLIC_KEY_SECP256K1_LENGTH: number;
export const RAW_PUBLIC_KEY_SM2_CODE: number;
export const RAW_PUBLIC_KEY_SM2_LENGTH: number;
export const KEY_TYPE_RSA: number;
export const KEY_TYPE_RSA2048: number;
export const KEY_TYPE_SECP256K1: number;
export const KEY_TYPE_SM2: number;
export interface PublicKeyPattern<T> {
        RSAPublicKey: (obj: RSAPublicKey) => T;
        Secp256k1PublicKey: (obj: Secp256k1PublicKey) => T;
        SM2PublicKey: (obj: SM2PublicKey) => T;
}
export interface PublicKeyMatcher {
        match<T>(p: PublicKeyPattern<T>): T;
}
export abstract class PublicKeyBase implements RawEncode {
        threshold: number;
        code: number;
        constructor(code: number, buffer: Uint8Array);
        abstract key_size(): number;
        abstract encrypt(data: Uint8Array, output: Uint8Array): BuckyResult<number>;
        abstract gen_aeskey_and_encrypt(): BuckyResult<[AesKey, Uint8Array]>;
        abstract verify(data: Uint8Array, sign: Signature): boolean;
        toJSON(): string;
        raw_measure(): BuckyResult<number>;
        raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
        abstract as_public_value(): PublicKeyValue;
        to_base_58(): string;
}
export class RSAPublicKey extends PublicKeyBase implements PublicKeyMatcher {
        constructor(code: number, buffer: Uint8Array);
        key_size(): number;
        encrypt(data: Uint8Array, output: Uint8Array): BuckyResult<number>;
        gen_aeskey_and_encrypt(): BuckyResult<[AesKey, Uint8Array]>;
        verify(data: Uint8Array, sign: Signature): boolean;
        match<T>(p: PublicKeyPattern<T>): T;
        as_public_value(): PublicKeyValue;
}
export class Secp256k1PublicKey extends PublicKeyBase implements PublicKeyMatcher {
        constructor(buffer: Uint8Array);
        key_size(): number;
        encrypt(data: Uint8Array, output: Uint8Array): BuckyResult<number>;
        gen_aeskey_and_encrypt(): BuckyResult<[AesKey, Uint8Array]>;
        verify(data: Uint8Array, sign: Signature): boolean;
        match<T>(p: PublicKeyPattern<T>): T;
        as_public_value(): PublicKeyValue;
}
export class SM2PublicKey extends PublicKeyBase implements PublicKeyMatcher {
        constructor(buffer: Uint8Array);
        key_size(): number;
        encrypt(data: Uint8Array, output: Uint8Array): BuckyResult<number>;
        gen_aeskey_and_encrypt(): BuckyResult<[AesKey, Uint8Array]>;
        verify(data: Uint8Array, sign: Signature): boolean;
        match<T>(p: PublicKeyPattern<T>): T;
        as_public_value(): PublicKeyValue;
}
export type PublicKey = RSAPublicKey | Secp256k1PublicKey | SM2PublicKey;
export class PublicKeyDecoder implements RawDecode<PublicKey> {
        constructor();
        raw_decode(buf: Uint8Array): BuckyResult<[PublicKey, Uint8Array]>;
}
export class MNPublicKey implements RawEncode {
        threshold: number;
        keys: Vec<PublicKey>;
        constructor(threshold: number, keys: Vec<PublicKey>);
        raw_measure(): BuckyResult<number>;
        raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
        as_public_value(): PublicKeyValue;
}
export class MNPublicKeyDecoder implements RawDecode<MNPublicKey> {
        constructor();
        raw_decode(buf: Uint8Array): BuckyResult<[MNPublicKey, Uint8Array]>;
}
export interface PublicKeyValuePattern<T> {
        PublicKey: (key: PublicKey) => T;
        MNPublicKey: (key: MNPublicKey) => T;
}
export interface PublicKeyValueMatch {
        match<T>(p: PublicKeyValuePattern<T>): T;
}
export class PublicKeyWithTag implements PublicKeyValueMatch, RawEncode {
        key: PublicKey;
        constructor(key: PublicKey);
        raw_measure(): BuckyResult<number>;
        raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
        match<T>(p: PublicKeyValuePattern<T>): T;
}
export class MNPublicKeyWithTag implements PublicKeyValueMatch, RawEncode {
        key: MNPublicKey;
        constructor(key: MNPublicKey);
        raw_measure(): BuckyResult<number>;
        raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
        match<T>(p: PublicKeyValuePattern<T>): T;
}
export type PublicKeyValue = PublicKeyWithTag | MNPublicKeyWithTag;
export class PublicKeyValueDecoder implements RawDecode<PublicKeyValue> {
        constructor();
        raw_decode(buf: Uint8Array): BuckyResult<[PublicKeyValue, Uint8Array]>;
}

export function sign_named_object_desc<DC extends DescContent, BC extends BodyContent>(private_key: PrivateKey, obj: NamedObject<DC, BC>, sign_source: SignatureSource): BuckyResult<Signature>;
export function sign_named_object_body<DC extends DescContent, BC extends BodyContent>(private_key: PrivateKey, obj: NamedObject<DC, BC>, sign_source: SignatureSource): BuckyResult<Signature>;
export function sign_and_push_named_object<DC extends DescContent, BC extends BodyContent>(private_key: PrivateKey, obj: NamedObject<DC, BC>, sign_source: SignatureSource): BuckyResult<{}>;
export function sign_and_set_named_object<DC extends DescContent, BC extends BodyContent>(private_key: PrivateKey, obj: NamedObject<DC, BC>, sign_source: SignatureSource): BuckyResult<{}>;

export class ActionDescTypeInfo extends DescTypeInfo {
    obj_type(): number;
    sub_desc_type(): SubDescType;
}
export class ActionDescContent extends DescContent {
    type_info(): DescTypeInfo;
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
}
export class ActionDescContentDecoder extends DescContentDecoder<ActionDescContent> {
    type_info(): DescTypeInfo;
    raw_decode(buf: Uint8Array): BuckyResult<[ActionDescContent, Uint8Array]>;
}
export class ActionBodyContent extends BodyContent {
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
}
export class ActionBodyContentDecoder extends BodyContentDecoder<ActionBodyContent> {
    raw_decode(buf: Uint8Array): BuckyResult<[ActionBodyContent, Uint8Array]>;
}
export class ActionDesc extends NamedObjectDesc<ActionDescContent> {
}
export class ActionDescDecoder extends NamedObjectDescDecoder<ActionDescContent> {
    constructor();
}
export class ActionBuilder extends NamedObjectBuilder<ActionDescContent, ActionBodyContent> {
}
export class ActionId extends NamedObjectId<ActionDescContent, ActionBodyContent> {
    constructor(id: ObjectId);
    static default(): ActionId;
    static from_base_58(s: string): BuckyResult<ActionId>;
    static try_from_object_id(id: ObjectId): BuckyResult<ActionId>;
}
export class ActionIdDecoder extends NamedObjectIdDecoder<ActionDescContent, ActionBodyContent> {
    constructor();
}
export class Action extends NamedObject<ActionDescContent, ActionBodyContent> {
    static create(build?: (builder: ActionBuilder) => void): Action;
    action_id(): ActionId;
    connect_info(): ActionBodyContent;
}
export class ActionDecoder extends NamedObjectDecoder<ActionDescContent, ActionBodyContent, Action> {
    constructor();
}

export type StandardObject = Device | People | SimpleGroup | Org | AppGroup | UnionAccount | ChunkId | Dir | File | Action | ObjectMap | Contract | TypelessStandardObject;
export type CoreObject = TypelessCoreObject;
export type DECAppObject = TypelessDECAppObject;
export type AnyNamedObject = StandardObject | CoreObject | DECAppObject;
export interface AnyNamedObjectVisitor<T> {
    Standard?: (obj: StandardObject) => T;
    Core?: (obj: CoreObject) => T;
    DECApp?: (obj: DECAppObject) => T;
}
export interface StandardObjectVisitor<T> {
    Device?: (obj: Device) => T;
    People?: (obj: People) => T;
    SimpleGroup?: (obj: SimpleGroup) => T;
    Org?: (obj: Org) => T;
    AppGroup?: (obj: AppGroup) => T;
    UnionAccount?: (obj: UnionAccount) => T;
    ChunkId?: (obj: ChunkId) => T;
    File?: (obj: File) => T;
    Dir?: (obj: Dir) => T;
    Action?: (obj: Action) => T;
    ObjectMap?: (obj: ObjectMap) => T;
    Contract?: (obj: Contract) => T;
    Tx?: (obj: TypelessStandardObject) => T;
    Diff?: (obj: TypelessStandardObject) => T;
}
export function match_any_obj<T>(a: AnyNamedObject, visitor: AnyNamedObjectVisitor<T>): T | undefined;
export function match_standard_obj<T>(s: StandardObject, visitor: StandardObjectVisitor<T>): T | undefined;
export class StandardObjectDecoder implements RawDecode<StandardObject> {
    constructor();
    raw_decode(buf: Uint8Array): BuckyResult<[StandardObject, Uint8Array]>;
}
export class AnyNamedObjectDecoder extends RawHexDecode<AnyNamedObject> {
    constructor();
    raw_decode(buf: Uint8Array): BuckyResult<[AnyNamedObject, Uint8Array]>;
    from_raw(buf: Uint8Array): BuckyResult<AnyNamedObject>;
}

export class AppGroupDescTypeInfo extends DescTypeInfo {
    obj_type(): number;
    sub_desc_type(): SubDescType;
}
export class AppGroupDescContent extends DescContent {
    type_info(): DescTypeInfo;
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
}
export class AppGroupDescContentDecoder extends DescContentDecoder<AppGroupDescContent> {
    type_info(): DescTypeInfo;
    raw_decode(buf: Uint8Array): BuckyResult<[AppGroupDescContent, Uint8Array]>;
}
export class AppGroupBodyContent extends BodyContent {
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
}
export class AppGroupBodyContentDecoder extends BodyContentDecoder<AppGroupBodyContent> {
    raw_decode(buf: Uint8Array): BuckyResult<[AppGroupBodyContent, Uint8Array]>;
}
export class AppGroupDesc extends NamedObjectDesc<AppGroupDescContent> {
}
export class AppGroupDescDecoder extends NamedObjectDescDecoder<AppGroupDescContent> {
    constructor();
}
export class AppGroupBuilder extends NamedObjectBuilder<AppGroupDescContent, AppGroupBodyContent> {
}
export class AppGroupId extends NamedObjectId<AppGroupDescContent, AppGroupBodyContent> {
    constructor(id: ObjectId);
    static default(): AppGroupId;
    static from_base_58(s: string): BuckyResult<AppGroupId>;
    static try_from_object_id(id: ObjectId): BuckyResult<AppGroupId>;
}
export class AppGroupIdDecoder extends NamedObjectIdDecoder<AppGroupDescContent, AppGroupBodyContent> {
    constructor();
}
export class AppGroup extends NamedObject<AppGroupDescContent, AppGroupBodyContent> {
    static create(build?: (builder: AppGroupBuilder) => void): AppGroup;
    appgroup_id(): AppGroupId;
    connect_info(): AppGroupBodyContent;
}
export class AppGroupDecoder extends NamedObjectDecoder<AppGroupDescContent, AppGroupBodyContent, AppGroup> {
    constructor();
}

export class Area implements RawEncode {
    m_country: number;
    m_carrier: number;
    m_city: number;
    m_inner: number;
    constructor(country: number, carrier: number, city: number, inner: number);
    get country(): number;
    get carrier(): number;
    get city(): number;
    get inner(): number;
    static default(): Area;
    static from_str(s: string): BuckyResult<Area>;
    clone(): Area;
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
    get_area_info(locale?: string): {
        country_name: string;
        state_name: string;
        city_name: string;
    } | null;
    toString(): string;
}
export class AreaDecoder implements RawDecode<Area> {
    constructor();
    raw_decode(buf: Uint8Array): BuckyResult<[Area, Uint8Array]>;
}

export const CHUNK_ID_LEN = 32;
export class ChunkIdDesc extends ObjectDesc {
    constructor(chunk_id: ChunkId);
    chunk_id(): ChunkId;
    calculate_id(): ObjectId;
    dec_id(): Option<ObjectId>;
    ref_objs(): Option<Vec<ObjectLink>>;
    prev(): Option<ObjectId>;
    create_timestamp(): Option<HashValue>;
    create_time(): JSBI;
    expired_time(): Option<JSBI>;
    owner(): Option<ObjectId> | undefined;
    area(): Option<Area> | undefined;
    author(): Option<ObjectId> | undefined;
    public_key(): PublicKey | undefined;
    mn_key(): MNPublicKey | undefined;
}
export class ChunkDescTypeInfo extends DescTypeInfo {
    obj_type(): number;
    sub_desc_type(): SubDescType;
}
export const CHUNK_DESC_TYPE_INFO: ChunkDescTypeInfo;
export class ChunkDescContent extends DescContent {
    type_info(): DescTypeInfo;
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
}
export class ChunkBodyContent extends BodyContent {
    type_info(): DescTypeInfo;
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
}
export class ChunkId implements RawEncode {
    constructor(buf: Uint8Array);
    calculate_id(): ObjectId;
    obj_type(): number;
    obj_type_code(): number;
    as_slice(): Uint8Array;
    length(): number;
    toString(): string;
    to_string(): string;
    to_base_58(): string;
    static from_base_58(s: string): BuckyResult<ChunkId>;
    static default(): ChunkId;
    static copy_from_slice(buf: Uint8Array): ChunkId;
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
    encode_to_buf(): BuckyResult<Uint8Array>;
    desc(): ObjectDesc;
    body(): Option<ObjectMutBody<ChunkDescContent, ChunkBodyContent>>;
    signs(): ObjectSigns;
    nonce(): Option<JSBI>;
    static calculate(data: Uint8Array): BuckyResult<ChunkId>;
}
export class ChunkIdDecoder implements RawDecode<ChunkId> {
    raw_decode(buf: Uint8Array): BuckyResult<[ChunkId, Uint8Array]>;
}

export class ContractDescTypeInfo extends DescTypeInfo {
    obj_type(): number;
    sub_desc_type(): SubDescType;
}
export class ContractDescContent extends DescContent {
    packageValue: HashValue;
    constructor(packageValue: HashValue);
    type_info(): DescTypeInfo;
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
}
export class ContractDescContentDecoder extends DescContentDecoder<ContractDescContent> {
    type_info(): DescTypeInfo;
    raw_decode(buf: Uint8Array): BuckyResult<[ContractDescContent, Uint8Array]>;
}
export class ContractBodyContent extends BodyContent {
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
}
export class ContractBodyContentDecoder extends BodyContentDecoder<ContractBodyContent> {
    raw_decode(buf: Uint8Array): BuckyResult<[ContractBodyContent, Uint8Array]>;
}
export class ContractDesc extends NamedObjectDesc<ContractDescContent> {
}
export class ContractDescDecoder extends NamedObjectDescDecoder<ContractDescContent> {
    constructor();
}
export class ContractBuilder extends NamedObjectBuilder<ContractDescContent, ContractBodyContent> {
}
export class ContractId extends NamedObjectId<ContractDescContent, ContractBodyContent> {
    constructor(id: ObjectId);
    static default(): ContractId;
    static from_base_58(s: string): BuckyResult<ContractId>;
    static try_from_object_id(id: ObjectId): BuckyResult<ContractId>;
}
export class ContractIdDecoder extends NamedObjectIdDecoder<ContractDescContent, ContractBodyContent> {
    constructor();
}
export class Contract extends NamedObject<ContractDescContent, ContractBodyContent> {
    static create(packageValue: HashValue, build?: (builder: ContractBuilder) => void): Contract;
    contract_id(): ContractId;
    connect_info(): ContractBodyContent;
}
export class ContractDecoder extends NamedObjectDecoder<ContractDescContent, ContractBodyContent, Contract> {
    constructor();
}

export enum DeviceCategory {
    OOD = 0,
    Server = 1,
    PC = 2,
    Router = 3,
    AndroidMobile = 4,
    AndroidPad = 5,
    AndroidWatch = 6,
    AndroidTV = 7,
    IOSMobile = 8,
    IOSPad = 9,
    IOSWatch = 10,
    SmartSpeakers = 11,
    Browser = 12,
    IoT = 13,
    SmartHome = 14,
    VirtualOOD = 15,
    Unknown = 255
}
export function number_2_devicecategory(x: number): DeviceCategory;
export class DeviceDescTypeInfo extends DescTypeInfo {
    obj_type(): number;
    sub_desc_type(): SubDescType;
}
export class DeviceDescContent extends DescContent {
    constructor(unique_id: UniqueId);
    type_info(): DescTypeInfo;
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
    unique_id(): UniqueId;
}
export class DeviceDescContentDecoder extends DescContentDecoder<DeviceDescContent> {
    type_info(): DescTypeInfo;
    raw_decode(buf: Uint8Array): BuckyResult<[DeviceDescContent, Uint8Array]>;
}
export class DeviceBodyContent extends ProtobufBodyContent {
    constructor(endpoints: Endpoint[], sn_list: DeviceId[], passive_pn_list: DeviceId[], name?: string);
    endpoints(): Endpoint[];
    sn_list(): DeviceId[];
    passive_pn_list(): DeviceId[];
    name(): string | undefined;
    set_name(name?: string): void;
    try_to_proto(): BuckyResult<protos.DeviceBodyContent>;
}
export class DeviceBodyContentDecoder extends ProtobufBodyContentDecoder<DeviceBodyContent, protos.DeviceBodyContent> {
    constructor();
    try_from_proto(value: protos.DeviceBodyContent): BuckyResult<DeviceBodyContent>;
}
export class DeviceDesc extends NamedObjectDesc<DeviceDescContent> {
}
export class DeviceDescDecoder extends NamedObjectDescDecoder<DeviceDescContent> {
    constructor();
}
export class DeviceBuilder extends NamedObjectBuilder<DeviceDescContent, DeviceBodyContent> {
}
export class DeviceId extends NamedObjectId<DeviceDescContent, DeviceBodyContent> {
    constructor(id: ObjectId);
    static default(): DeviceId;
    static from_base_58(s: string): BuckyResult<DeviceId>;
    static try_from_object_id(id: ObjectId): BuckyResult<DeviceId>;
}
export class DeviceIdDecoder extends NamedObjectIdDecoder<DeviceDescContent, DeviceBodyContent> {
    constructor();
}
export class Device extends NamedObject<DeviceDescContent, DeviceBodyContent> {
    static create(owner: Option<ObjectId>, unique_id: UniqueId, endpoints: Endpoint[], sn_list: DeviceId[], passive_sn_list: DeviceId[], public_key: PublicKey, area: Area, category: DeviceCategory, build?: (builder: DeviceBuilder) => void): Device;
    device_id(): DeviceId;
    connect_info(): DeviceBodyContent;
    name(): string | undefined;
    set_name(name?: string): void;
    category(): BuckyResult<DeviceCategory>;
}
export class DeviceDecoder extends NamedObjectDecoder<DeviceDescContent, DeviceBodyContent, Device> {
    constructor();
}

export class DirDescTypeInfo extends DescTypeInfo {
    obj_type(): number;
    sub_desc_type(): SubDescType;
}
export class Attributes implements RawEncode {
    flags: number;
    constructor(flags: number);
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
}
export class AttributesDecoder implements RawDecode<Attributes> {
    constructor();
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[Attributes, Uint8Array]>;
}
export class InnerNode implements RawEncode {
    constructor(id: {
        object_id?: ObjectId;
        chunk_id?: ChunkId;
        index?: {
            offset: number;
            size: number;
        };
    });
    is_object_id(): boolean;
    is_chunk_id(): boolean;
    is_index_in_parent_chunk(): boolean;
    match<T>(visitor: {
        ObjId: (object_id: ObjectId) => T;
        Chunk: (chunk_id: ChunkId) => T;
        IndexInParentChunk: (offset: number, size: number) => T;
    }): T;
    object_id(): ObjectId | undefined;
    chunk_id(): ChunkId | undefined;
    index_in_parent_chunk(): {
        offset: number;
        size: number;
    } | undefined;
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
}
export class InnerNodeDecoder implements RawDecode<InnerNode> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[InnerNode, Uint8Array]>;
}
export class InnerNodeInfo implements RawEncode {
    constructor(attributes: Attributes, node: InnerNode);
    attributes(): Attributes;
    node(): InnerNode;
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class InnerNodeInfoDecoder implements RawDecode<InnerNodeInfo> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[InnerNodeInfo, Uint8Array]>;
}
export class NDNObjectList implements RawEncode {
    constructor(parent_chunk: Option<ChunkId>, object_map?: BuckyHashMap<BuckyString, InnerNodeInfo>);
    parent_chunk(): Option<ChunkId>;
    object_map(): BuckyHashMap<BuckyString, InnerNodeInfo>;
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class NDNObjectListDecoder implements RawDecode<NDNObjectList> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[NDNObjectList, Uint8Array]>;
}
export class NDNObjectInfo implements RawEncode {
    constructor(info: {
        chunk_id?: ChunkId;
        obj_list?: NDNObjectList;
    });
    match<T>(visitor: {
        Chunk: (chunk_id: ChunkId) => T;
        ObjList: (obj_list: NDNObjectList) => T;
    }): T;
    match_async<T>(visitor: {
        Chunk: (chunk_id: ChunkId) => Promise<T>;
        ObjList: (obj_list: NDNObjectList) => Promise<T>;
    }): Promise<T>;
    raw_measure(ctx?: any, purpose?: RawEncodePurpose): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any, purpose?: RawEncodePurpose): BuckyResult<Uint8Array>;
}
export class NDNObjectInfoDecoder implements RawDecode<NDNObjectInfo> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[NDNObjectInfo, Uint8Array]>;
}
export class DirDescContent extends DescContent {
    constructor(attributes: Attributes, obj_list: NDNObjectInfo);
    attributes(): Attributes;
    obj_list(): NDNObjectInfo;
    set_obj_list(list: NDNObjectInfo): void;
    type_info(): DescTypeInfo;
    raw_measure(ctx?: any, purpose?: RawEncodePurpose): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any, purpose?: RawEncodePurpose): BuckyResult<Uint8Array>;
}
export class DirDescContentDecoder extends DescContentDecoder<DirDescContent> {
    type_info(): DescTypeInfo;
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[DirDescContent, Uint8Array]>;
}
export class DirBodyContent extends ProtobufBodyContent {
    constructor(member: {
        chunk_id?: ChunkId;
        obj_list?: BuckyHashMap<ObjectId, BuckyBuffer>;
    });
    match<T>(visitor: {
        Chunk: (chunk_id: ChunkId) => T;
        ObjList: (obj_list: BuckyHashMap<ObjectId, BuckyBuffer>) => T;
    }): T;
    match_async<T>(visitor: {
        Chunk: (chunk_id: ChunkId) => Promise<T>;
        ObjList: (obj_list: BuckyHashMap<ObjectId, BuckyBuffer>) => Promise<T>;
    }): Promise<T>;
    try_to_proto(): BuckyResult<protos.DirBodyContent>;
}
export class DirBodyContentDecoder extends ProtobufBodyContentDecoder<DirBodyContent, protos.DirBodyContent> {
    constructor();
    try_from_proto(value: protos.DirBodyContent): BuckyResult<DirBodyContent>;
}
export class DirDesc extends NamedObjectDesc<DirDescContent> {
}
export class DirDescDecoder extends NamedObjectDescDecoder<DirDescContent> {
    constructor();
}
export class DirBuilder extends NamedObjectBuilder<DirDescContent, DirBodyContent> {
}
export class DirId extends NamedObjectId<DirDescContent, DirBodyContent> {
    constructor(id: ObjectId);
    static default(): DirId;
    static from_base_58(s: string): BuckyResult<DirId>;
    static try_from_object_id(id: ObjectId): BuckyResult<DirId>;
}
export class DirIdDecoder extends NamedObjectIdDecoder<DirDescContent, DirBodyContent> {
    constructor();
}
export class Dir extends NamedObject<DirDescContent, DirBodyContent> {
    static create(owner: ObjectId, attributes: Attributes, obj_list: NDNObjectInfo, body: {
        chunk_id?: ChunkId;
        obj_list?: BuckyHashMap<ObjectId, BuckyBuffer>;
    }, build?: (builder: DirBuilder) => void): Dir;
    dir_id(): DirId;
    get_data_from_body(id: ObjectId): Option<Uint8Array>;
    check_and_fix_desc_limit(): BuckyResult<{}>;
}
export class DirDecoder extends NamedObjectDecoder<DirDescContent, DirBodyContent, Dir> {
    constructor();
}

export class FileDescTypeInfo extends DescTypeInfo {
    obj_type(): number;
    sub_desc_type(): SubDescType;
}
export class FileDescContent extends DescContent {
    len: JSBI;
    hash: HashValue;
    constructor(len: JSBI, hash: HashValue);
    type_info(): DescTypeInfo;
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
}
export class FileDescContentDecoder extends DescContentDecoder<FileDescContent> {
    type_info(): DescTypeInfo;
    raw_decode(buf: Uint8Array): BuckyResult<[FileDescContent, Uint8Array]>;
}
export enum ChunkBundleHashMethod {
    Serial = "Serial"
}
export class ChunkBundle {
    chunk_list: ChunkId[];
    hash_method: ChunkBundleHashMethod;
    constructor(chunk_list: ChunkId[], hash_method: ChunkBundleHashMethod);
    len(): JSBI;
    calc_hash_value(): HashValue;
    calc_serial_hash_value(): HashValue;
}
export class ChunkList {
    chunk_in_list?: ChunkId[] | undefined;
    file_id?: FileId | undefined;
    chunk_in_bundle?: ChunkBundle | undefined;
    constructor(chunk_in_list?: ChunkId[] | undefined, file_id?: FileId | undefined, chunk_in_bundle?: ChunkBundle | undefined);
    inner_chunk_list(): ChunkId[] | undefined;
    match<T>(visitor: {
        ChunkInList?: (list: ChunkId[]) => T;
        FileId?: (id: FileId) => T;
        ChunkInBundle?: (bundle: ChunkBundle) => T;
    }): T | undefined;
}
export class FileBodyContent extends ProtobufBodyContent {
    chunk_list: ChunkList;
    constructor(chunk_list: ChunkList);
    inner_chunk_list(): ChunkId[] | undefined;
    try_to_proto(): BuckyResult<protos.FileBodyContent>;
}
export class FileBodyContentDecoder extends ProtobufBodyContentDecoder<FileBodyContent, protos.FileBodyContent> {
    constructor();
    try_from_proto(value: protos.FileBodyContent): BuckyResult<FileBodyContent>;
}
export class FileDesc extends NamedObjectDesc<FileDescContent> {
}
export class FileDescDecoder extends NamedObjectDescDecoder<FileDescContent> {
    constructor();
}
export class FileBuilder extends NamedObjectBuilder<FileDescContent, FileBodyContent> {
}
export class FileId extends NamedObjectId<FileDescContent, FileBodyContent> {
    constructor(id: ObjectId);
    static default(): FileId;
    static from_base_58(s: string): BuckyResult<FileId>;
    static try_from_object_id(id: ObjectId): BuckyResult<FileId>;
}
export class FileIdDecoder extends NamedObjectIdDecoder<FileDescContent, FileBodyContent> {
    constructor();
}
export class File extends NamedObject<FileDescContent, FileBodyContent> {
    static create(owner: ObjectId, len: JSBI, hash: HashValue, chunk_list: ChunkList, build?: (builder: FileBuilder) => void): File;
    file_id(): FileId;
}
export class FileDecoder extends NamedObjectDecoder<FileDescContent, FileBodyContent, File> {
    constructor();
}

export class ObjectIdBuilder<T extends RawEncode & ObjectDesc> {
        m_t: T;
        m_obj_type_code: ObjectTypeCode;
        m_area: Option<Area>;
        m_has_owner: boolean;
        m_has_single_key: boolean;
        m_has_mn_key: boolean;
        constructor(t: T, obj_type_code: ObjectTypeCode);
        area(area: Option<Area>): ObjectIdBuilder<T>;
        owner(value: boolean): ObjectIdBuilder<T>;
        single_key(value: boolean): ObjectIdBuilder<T>;
        mn_key(value: boolean): ObjectIdBuilder<T>;
        build(): ObjectId;
}
export const OBJECT_FLAG_CTYPTO: number;
export const OBJECT_FLAG_MUT_BODY: number;
export const OBJECT_FLAG_DESC_SIGNS: number;
export const OBJECT_FLAG_BODY_SIGNS: number;
export const OBJECT_FLAG_NONCE: number;
export const OBJECT_FLAG_DESC_ID: number;
export const OBJECT_FLAG_REF_OBJECTS: number;
export const OBJECT_FLAG_PREV: number;
export const OBJECT_FLAG_CREATE_TIMESTAMP: number;
export const OBJECT_FLAG_CREATE_TIME: number;
export const OBJECT_FLAG_EXPIRED_TIME: number;
export const OBJECT_FLAG_OWNER: number;
export const OBJECT_FLAG_AREA: number;
export const OBJECT_FLAG_AUTHOR: number;
export const OBJECT_FLAG_PUBLIC_KEY: number;
export const OBJECT_FLAG_EXT: number;
export const OBJECT_TYPE_ANY: number;
export const OBJECT_TYPE_STANDARD_START: number;
export const OBJECT_TYPE_STANDARD_END: number;
export const OBJECT_TYPE_CORE_START: number;
export const OBJECT_TYPE_CORE_END: number;
export const OBJECT_TYPE_DECAPP_START: number;
export const OBJECT_TYPE_DECAPP_END: number;
export const OBJECT_PUBLIC_KEY_NONE: number;
export const OBJECT_PUBLIC_KEY_SINGLE: number;
export const OBJECT_PUBLIC_KEY_MN: number;
export const OBJECT_BODY_FLAG_PREV: number;
export const OBJECT_BODY_FLAG_USER_DATA: number;
export const OBJECT_BODY_FLAG_EXT: number;
export function is_standard_object(object_type: number): boolean;
export function is_core_object(object_type: number): boolean;
export function is_dec_app_object(object_type: number): boolean;
export abstract class ObjectDesc {
        constructor(obj_type: number);
        obj_type(): number;
        obj_type_code(): ObjectTypeCode;
        is_standard_object(): boolean;
        is_core_object(): boolean;
        is_dec_app_object(): boolean;
        abstract calculate_id(): ObjectId;
        abstract dec_id(): Option<ObjectId>;
        abstract ref_objs(): Option<Vec<ObjectLink>>;
        abstract prev(): Option<ObjectId>;
        abstract create_timestamp(): Option<HashValue>;
        abstract create_time(): JSBI;
        abstract expired_time(): Option<JSBI>;
        abstract owner(): Option<ObjectId> | undefined;
}
export class NamedObjectBodyContext {
        constructor();
        cache_body_content_size(size: number): NamedObjectBodyContext;
        get_body_content_cached_size(): number;
}
export class NamedObjectContext implements RawEncode {
        constructor(obj_type: number, obj_flags: number);
        get obj_type_code(): ObjectTypeCode;
        get obj_type(): number;
        get obj_flags(): number;
        is_standard_object(): boolean;
        is_core_object(): boolean;
        is_dec_app_object(): boolean;
        has_flag(flag_pos: number): boolean;
        with_crypto(): NamedObjectContext;
        has_crypto(): boolean;
        with_mut_body(): NamedObjectContext;
        has_mut_body(): boolean;
        with_desc_signs(): NamedObjectContext;
        has_desc_signs(): boolean;
        with_body_signs(): NamedObjectContext;
        has_body_signs(): boolean;
        with_nonce(): NamedObjectContext;
        has_nonce(): boolean;
        with_dec_id(): NamedObjectContext;
        has_dec_id(): boolean;
        with_ref_objects(): NamedObjectContext;
        has_ref_objects(): boolean;
        with_prev(): NamedObjectContext;
        has_prev(): boolean;
        with_create_timestamp(): NamedObjectContext;
        has_create_time_stamp(): boolean;
        with_create_time(): NamedObjectContext;
        has_create_time(): boolean;
        with_expired_time(): NamedObjectContext;
        has_expired_time(): boolean;
        with_owner(): NamedObjectContext;
        has_owner(): boolean;
        with_area(): NamedObjectContext;
        has_area(): boolean;
        with_public_key(): NamedObjectContext;
        has_public_key(): boolean;
        with_author(): NamedObjectContext;
        has_author(): boolean;
        has_ext(): boolean;
        cache_desc_content_size(size: number): NamedObjectContext;
        get_desc_content_cached_size(): number;
        body_context(): NamedObjectBodyContext;
        raw_measure(): BuckyResult<number>;
        raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
}
export class NamedObjectContextDecoder extends RawHexDecode<NamedObjectContext> {
        constructor();
        raw_decode(buf: Uint8Array): BuckyResult<[NamedObjectContext, Uint8Array]>;
}
/**
    * NamedObjectBody
    */
export class ObjectMutBodyBuilder<DC extends DescContent, BC extends BodyContent> {
        constructor(obj_type: number, content: BC);
        update_time(value: JSBI): ObjectMutBodyBuilder<DescContent, BC>;
        option_update_time(value: Option<JSBI>): ObjectMutBodyBuilder<DC, BC>;
        prev_version(value: HashValue): ObjectMutBodyBuilder<DC, BC>;
        option_prev_version(value: Option<HashValue>): ObjectMutBodyBuilder<DC, BC>;
        user_data(value: Uint8Array): ObjectMutBodyBuilder<DC, BC>;
        option_user_data(value: Option<Uint8Array>): ObjectMutBodyBuilder<DC, BC>;
        build(): ObjectMutBody<DC, BC>;
}
/**
    * NamedObjectBody
    */
export class ObjectMutBody<DC extends DescContent, BC extends BodyContent> implements RawEncode {
        toString(): string;
        constructor(obj_type: number, prev_version: Option<HashValue>, update_time: JSBI, content: BC, user_data: Option<Uint8Array>);
        set_trace_id(trace: number): void;
        trace_id(): number | undefined;
        convert_to<RBC extends BodyContent>(map: (t: BC) => BuckyResult<RBC>): BuckyResult<ObjectMutBody<DC, RBC>>;
        prev_version(): Option<HashValue>;
        update_time(): JSBI;
        content(): BC;
        user_data(): Option<Uint8Array>;
        set_update_time(value: JSBI): void;
        increase_update_time(value: JSBI): void;
        set_userdata(user_data: Uint8Array): void;
        raw_measure(ctx: NamedObjectBodyContext, purpose?: RawEncodePurpose): BuckyResult<number>;
        raw_encode(buf: Uint8Array, ctx: NamedObjectBodyContext, purpose?: RawEncodePurpose): BuckyResult<Uint8Array>;
        encode_to_buf(purpose?: RawEncodePurpose): BuckyResult<Uint8Array>;
        raw_hash_encode(): BuckyResult<HashValue>;
}
/**
    * NamedObjectBody
    */
export class ObjectMutBodyDecoder<DC extends DescContent, BC extends BodyContent> implements RawDecode<ObjectMutBody<DC, BC>> {
        constructor(obj_type: number, content_decoder: BodyContentDecoder<BC>);
        set_trace_id(trace: number): void;
        trace_id(): number | undefined;
        raw_decode(buf: Uint8Array): BuckyResult<[ObjectMutBody<DC, BC>, Uint8Array]>;
}
/**
    * NamedObject 
    */
export class ObjectSignsBuilder {
        constructor();
        reset_desc_sign(sign: Signature): ObjectSignsBuilder;
        reset_body_sign(sign: Signature): ObjectSignsBuilder;
        push_desc_sign(sign: Signature): ObjectSignsBuilder;
        push_body_sign(sign: Signature): ObjectSignsBuilder;
        build(): ObjectSigns;
}
/**
    * NamedObject 
    */
export class ObjectSigns implements RawEncode {
        constructor(desc_signs: Option<Vec<Signature>>, body_signs: Option<Vec<Signature>>);
        desc_signs(): Option<Signature[]>;
        body_signs(): Option<Signature[]>;
        reset_desc_sign(sign: Signature): void;
        reset_body_sign(sign: Signature): void;
        push_desc_sign(sign: Signature): void;
        push_body_sign(sign: Signature): void;
        latest_desc_sign_time(): JSBI;
        latest_body_sign_time(): JSBI;
        raw_measure(ctx: NamedObjectContext): BuckyResult<number>;
        raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
        static default(): ObjectSigns;
}
/**
    * NamedObject 
    */
export class ObjectSignsDecoder implements RawDecode<ObjectSigns> {
        raw_decode(buf: Uint8Array, ctx: NamedObjectContext): BuckyResult<[ObjectSigns, Uint8Array]>;
}
/**
    * Id
    */
export class NamedObjectId<DC extends DescContent, BC extends BodyContent> implements RawEncode, Compareable<NamedObjectId<DC, BC>> {
        constructor(obj_type: number, object_id: ObjectId);
        get object_id(): ObjectId;
        hashCode(): symbol;
        equals<ODC extends DescContent, OBC extends BodyContent>(other: NamedObjectId<ODC, OBC>): boolean;
        into(): ObjectId;
        gen(object_id: ObjectId): void;
        toString(): string;
        toJSON(): string;
        to_string(): string;
        to_base_58(): string;
        raw_measure(ctx?: any): BuckyResult<number>;
        raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export function named_id_gen_default<DC extends DescContent, BC extends BodyContent, O extends NamedObjectId<DC, BC>>(obj_type: number): O;
export function named_id_from_base_58<DC extends DescContent, BC extends BodyContent>(obj_type: number, s: string): BuckyResult<NamedObjectId<DC, BC>>;
export function named_id_try_from_object_id<DC extends DescContent, BC extends BodyContent>(obj_type: number, id: ObjectId): BuckyResult<NamedObjectId<DC, BC>>;
/**
    * NamedObjectId 
    */
export class NamedObjectIdDecoder<DC extends DescContent, BC extends BodyContent> implements RawDecode<NamedObjectId<DC, BC>> {
        readonly m_obj_type: number;
        constructor(obj_type: number);
        raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[NamedObjectId<DC, BC>, Uint8Array]>;
}
export interface SubDescType {
        owner_type: "disable" | "option";
        area_type: "disable" | "option";
        author_type: "disable" | "option";
        key_type: "disable" | "single_key" | "mn_key" | "any";
}
export class ContentCodecInfo {
        version: number;
        format: number;
        constructor(version: number, format: number);
        static default(): ContentCodecInfo;
}
export abstract class DescTypeInfo {
        get_sub_obj_type(): number;
        set_sub_obj_type(v: number): void;
        abstract obj_type(): number;
        abstract sub_desc_type(): SubDescType;
}
export abstract class DescContent implements RawEncode {
        abstract type_info(): DescTypeInfo;
        codec_info(): ContentCodecInfo;
        abstract raw_measure(ctx?: any, purpose?: RawEncodePurpose): BuckyResult<number>;
        abstract raw_encode(buf: Uint8Array, ctx?: any, purpose?: RawEncodePurpose): BuckyResult<Uint8Array>;
}
export abstract class DescContentDecoder<T extends DescContent> implements RawDecode<T> {
        abstract type_info(): DescTypeInfo;
        abstract raw_decode(buf: Uint8Array, ctx: ContentRawDecodeContext): BuckyResult<[T, Uint8Array]>;
}
export class EmptyDescContent extends DescContent {
        constructor(m_type_info: DescTypeInfo);
        type_info(): DescTypeInfo;
        raw_measure(): BuckyResult<number>;
        raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
}
export class EmptyDescContentDecoder extends DescContentDecoder<EmptyDescContent> {
        constructor(m_type_info: DescTypeInfo);
        type_info(): DescTypeInfo;
        raw_decode(buf: Uint8Array): BuckyResult<[EmptyDescContent, Uint8Array]>;
}
export abstract class BodyContent implements RawEncode {
        codec_info(): ContentCodecInfo;
        abstract raw_measure(ctx?: any, purpose?: RawEncodePurpose): BuckyResult<number>;
        abstract raw_encode(buf: Uint8Array, ctx?: any, purpose?: RawEncodePurpose): BuckyResult<Uint8Array>;
}
export abstract class BodyContentDecoder<T extends BodyContent> implements RawDecode<T> {
        abstract raw_decode(buf: Uint8Array, ctx: ContentRawDecodeContext): BuckyResult<[T, Uint8Array]>;
}
export class NamedObjectDescBuilder<T extends DescContent> {
        constructor(obj_type: number, desc_content: T);
        dec_id(value: ObjectId): NamedObjectDescBuilder<T>;
        option_dec_id(value: Option<ObjectId>): NamedObjectDescBuilder<T>;
        ref_objects(value: Vec<ObjectLink>): NamedObjectDescBuilder<T>;
        option_ref_objects(value: Option<Vec<ObjectLink>>): NamedObjectDescBuilder<T>;
        prev(value: ObjectId): NamedObjectDescBuilder<T>;
        option_prev(value: Option<ObjectId>): NamedObjectDescBuilder<T>;
        create_timestamp(value: HashValue): NamedObjectDescBuilder<T>;
        option_create_timestamp(value: Option<HashValue>): NamedObjectDescBuilder<T>;
        create_time(value: JSBI): NamedObjectDescBuilder<T>;
        option_create_time(value: Option<JSBI>): NamedObjectDescBuilder<T>;
        expired_time(value: JSBI): NamedObjectDescBuilder<T>;
        option_expired_time(value: Option<JSBI>): NamedObjectDescBuilder<T>;
        owner(value: ObjectId): NamedObjectDescBuilder<T>;
        option_owner(value: Option<ObjectId>): NamedObjectDescBuilder<T>;
        area(value: Area): NamedObjectDescBuilder<T>;
        option_area(value: Option<Area>): NamedObjectDescBuilder<T>;
        author(value: ObjectId): NamedObjectDescBuilder<T>;
        option_author(value: Option<ObjectId>): NamedObjectDescBuilder<T>;
        single_key(value: PublicKey): NamedObjectDescBuilder<T>;
        option_single_key(value: Option<PublicKey>): NamedObjectDescBuilder<T>;
        mn_key(value: MNPublicKey): NamedObjectDescBuilder<T>;
        option_mn_key(value: Option<MNPublicKey>): NamedObjectDescBuilder<T>;
        option_key(value: Option<PublicKey | MNPublicKey | undefined>): NamedObjectDescBuilder<T>;
        key(value: PublicKey | MNPublicKey | undefined): NamedObjectDescBuilder<T>;
        build(): NamedObjectDesc<T>;
}
export class NamedObjectDesc<T extends DescContent> extends ObjectDesc implements RawEncode {
        constructor(dec_id: Option<ObjectId>, ref_objects: Option<Vec<ObjectLink>>, prev: Option<ObjectId>, create_timestamp: Option<HashValue>, create_time: Option<JSBI>, expired_time: Option<JSBI>, desc_content: T, owner?: Option<ObjectId>, area?: Option<Area>, author?: Option<ObjectId>, public_key?: PublicKey | MNPublicKey);
        trace_id(): number;
        convert_to<U extends DescContent>(map: (t: T) => BuckyResult<U>): BuckyResult<NamedObjectDesc<U>>;
        content(): T;
        dec_id(): Option<ObjectId>;
        ref_objs(): Option<Vec<ObjectLink>>;
        prev(): Option<ObjectId>;
        create_timestamp(): Option<HashValue>;
        create_time(): JSBI;
        expired_time(): Option<JSBI>;
        object_id(): ObjectId;
        calculate_id(): ObjectId;
        owner(): Option<ObjectId> | undefined;
        area(): Option<Area> | undefined;
        author(): Option<ObjectId> | undefined;
        public_key(): PublicKey | undefined;
        mn_key(): MNPublicKey | undefined;
        raw_measure(ctx?: NamedObjectContext, purpose?: RawEncodePurpose): BuckyResult<number>;
        raw_measure_with_context(ctx: NamedObjectContext, purpose?: RawEncodePurpose): BuckyResult<number>;
        raw_encode(buf: Uint8Array, ctx?: NamedObjectContext, purpose?: RawEncodePurpose): BuckyResult<Uint8Array>;
        raw_encode_with_context(buf: Uint8Array, ctx: NamedObjectContext, purpose?: RawEncodePurpose): BuckyResult<Uint8Array>;
        encode_to_buf(purpose?: RawEncodePurpose): BuckyResult<Uint8Array>;
        raw_hash_encode(): BuckyResult<HashValue>;
}
export class NamedObjectDescDecoder<T extends DescContent> implements RawDecode<NamedObjectDesc<T>> {
        constructor(desc_content_decoder: DescContentDecoder<T>);
        trace_id(): number;
        raw_decode(buf: Uint8Array, ctx?: NamedObjectContext): BuckyResult<[NamedObjectDesc<T>, Uint8Array]>;
}
export class NamedObject<DC extends DescContent, BC extends BodyContent> implements RawEncode {
        constructor(desc: NamedObjectDesc<DC>, body: Option<ObjectMutBody<DC, BC>>, signs: ObjectSigns, nonce: Option<JSBI>);
        obj_type(): number;
        obj_type_code(): number;
        calculate_id(): ObjectId;
        protected obj_flags(): number;
        to_vec(): BuckyResult<Uint8Array>;
        to_hex(): BuckyResult<string>;
        toString(): string;
        to_string(): string;
        toJSON(): string;
        desc(): NamedObjectDesc<DC>;
        body(): Option<ObjectMutBody<DC, BC>>;
        set_body(body: Option<ObjectMutBody<DC, BC>>): void;
        body_expect(): ObjectMutBody<DC, BC>;
        signs(): ObjectSigns;
        nonce(): Option<JSBI>;
        raw_measure(_ctx?: any, purpose?: RawEncodePurpose): BuckyResult<number>;
        raw_encode(buf: Uint8Array, ctx?: NamedObjectContext, purpose?: RawEncodePurpose): BuckyResult<Uint8Array>;
        encode_to_buf(purpose?: RawEncodePurpose): BuckyResult<Uint8Array>;
        raw_hash_encode(): BuckyResult<HashValue>;
}
export class NamedObjectDecoder<DC extends DescContent, BC extends BodyContent, O extends NamedObject<DC, BC>> implements RawDecode<NamedObject<DC, BC>> {
        constructor(desc_content_decoer: DescContentDecoder<DC>, body_content_decoder: BodyContentDecoder<BC>, obj_builder: new (...constructorArgs: any[]) => O);
        raw_decode(buf: Uint8Array): BuckyResult<[O, Uint8Array]>;
        from_raw(buf: Uint8Array): BuckyResult<O>;
        from_hex(hex: string): BuckyResult<O>;
}
export class NamedObjectBuilder<DC extends DescContent, BC extends BodyContent> {
        constructor(desc_content: DC, body_content: BC);
        dec_id(dec_id: ObjectId): NamedObjectBuilder<DC, BC>;
        option_dec_id(dec_id: Option<ObjectId>): NamedObjectBuilder<DC, BC>;
        ref_objects(ref_objects: Vec<ObjectLink>): NamedObjectBuilder<DC, BC>;
        option_ref_objects(ref_objects: Option<Vec<ObjectLink>>): NamedObjectBuilder<DC, BC>;
        prev(prev: ObjectId): NamedObjectBuilder<DC, BC>;
        option_prev(prev: Option<ObjectId>): NamedObjectBuilder<DC, BC>;
        create_timestamp(create_timestamp: HashValue): NamedObjectBuilder<DC, BC>;
        option_create_timestamp(create_timestamp: Option<HashValue>): NamedObjectBuilder<DC, BC>;
        no_create_time(): NamedObjectBuilder<DC, BC>;
        create_time(create_time: JSBI): NamedObjectBuilder<DC, BC>;
        option_create_time(create_time: Option<JSBI>): NamedObjectBuilder<DC, BC>;
        expired_time(expired_time: JSBI): NamedObjectBuilder<DC, BC>;
        option_expired_time(expired_time: Option<JSBI>): NamedObjectBuilder<DC, BC>;
        owner(value: ObjectId): NamedObjectBuilder<DC, BC>;
        option_owner(value: Option<ObjectId>): NamedObjectBuilder<DC, BC>;
        area(value: Area): NamedObjectBuilder<DC, BC>;
        option_area(value: Option<Area>): NamedObjectBuilder<DC, BC>;
        author(value: ObjectId): NamedObjectBuilder<DC, BC>;
        option_author(value: Option<ObjectId>): NamedObjectBuilder<DC, BC>;
        single_key(value: PublicKey): NamedObjectBuilder<DC, BC>;
        option_single_key(value: Option<PublicKey>): NamedObjectBuilder<DC, BC>;
        mn_key(value: MNPublicKey): NamedObjectBuilder<DC, BC>;
        option_mn_key(value: Option<MNPublicKey>): NamedObjectBuilder<DC, BC>;
        no_body(): NamedObjectBuilder<DC, BC>;
        update_time(update_time: JSBI): NamedObjectBuilder<DC, BC>;
        prev_version(prev_version: HashValue): NamedObjectBuilder<DC, BC>;
        user_data(user_data: Uint8Array): NamedObjectBuilder<DC, BC>;
        reset_desc_sign(sign: Signature): NamedObjectBuilder<DC, BC>;
        reset_body_sign(sign: Signature): NamedObjectBuilder<DC, BC>;
        push_desc_sign(sign: Signature): NamedObjectBuilder<DC, BC>;
        push_body_sign(sign: Signature): NamedObjectBuilder<DC, BC>;
        nonce(nonce: JSBI): NamedObjectBuilder<DC, BC>;
        build_ex(): [
                NamedObjectDesc<DC>,
                Option<ObjectMutBody<DC, BC>>,
                ObjectSigns,
                Option<JSBI>
        ];
        build<T extends NamedObject<DC, BC>>(obj_constructor: new (desc: NamedObjectDesc<DC>, body: Option<ObjectMutBody<DC, BC>>, signs: ObjectSigns, nonce: Option<JSBI>) => T): T;
}

export enum ObjectCategory {
    Standard = "standard",
    Core = "core",
    DecApp = "dec_app"
}
export const OBJECT_ID_LEN = 32;
export const OBJECT_ID_STANDARD = 1;
export const OBJECT_ID_CORE = 2;
export const OBJECT_ID_DEC_APP = 3;
export const OBJECT_ID_FLAG_AREA: number;
export const OBJECT_ID_FLAG_PK: number;
export const OBJECT_ID_FLAG_MN_PK: number;
export const OBJECT_ID_FLAG_OWNER = 1;
export interface ObjectIdInfoPartten<T> {
    StandardObjectIdInfo: (info: StandardObjectIdInfo) => T;
    CoreObjectIdInfo: (info: CoreObjectIdInfo) => T;
    DecAppObjectIdInfo: (info: DecAppObjectIdInfo) => T;
}
export interface ObjectIdInfoMatcher {
    match<T>(p: ObjectIdInfoPartten<T>): T;
}
export class StandardObjectIdInfo implements ObjectIdInfoMatcher {
    obj_type_code: ObjectTypeCode;
    obj_type: number;
    area: Option<Area>;
    constructor(obj_type_code: ObjectTypeCode, obj_type: number, area: Option<Area>);
    match<T>(p: ObjectIdInfoPartten<T>): T;
}
export class CoreObjectIdInfo implements ObjectIdInfoMatcher {
    area: Option<Area>;
    has_owner: boolean;
    has_single_key: boolean;
    has_mn_key: boolean;
    constructor(area: Option<Area>, has_owner: boolean, has_single_key: boolean, has_mn_key: boolean);
    match<T>(p: ObjectIdInfoPartten<T>): T;
}
export class DecAppObjectIdInfo implements ObjectIdInfoMatcher {
    area: Option<Area>;
    has_owner: boolean;
    has_single_key: boolean;
    has_mn_key: boolean;
    constructor(area: Option<Area>, has_owner: boolean, has_single_key: boolean, has_mn_key: boolean);
    match<T>(p: ObjectIdInfoPartten<T>): T;
}
export type ObjectIdInfo = (StandardObjectIdInfo | CoreObjectIdInfo | DecAppObjectIdInfo) & ObjectIdInfoMatcher;
export class ObjectId implements RawEncode, Compareable<ObjectId> {
    m_buf: Uint8Array;
    m_base58?: string;
    constructor(buf: Uint8Array);
    get object_id(): void;
    static default(): ObjectId;
    static copy_from_slice(buf: Uint8Array): ObjectId;
    obj_type_code(): ObjectTypeCode;
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
    as_slice(): Uint8Array;
    clone(): ObjectId;
    length(): number;
    toString(): string;
    toJSON(): string;
    to_string(): string;
    to_base_58(): string;
    hashCode(): symbol;
    equals(other: ObjectId): boolean;
    eq(other: ObjectId): boolean;
    static from_str(s: string): BuckyResult<ObjectId>;
    static from_base_58(s: string): BuckyResult<ObjectId>;
    to_hash_value(): HashValue;
    object_category(): ObjectCategory;
    is_stand_object(): boolean;
    is_core_object(): boolean;
    is_dec_app_object(): boolean;
    info(): ObjectIdInfo;
}
export class ObjectIdDecoder implements RawDecode<ObjectId> {
    raw_decode(buf: Uint8Array): BuckyResult<[ObjectId, Uint8Array]>;
}
export class ObjectLink implements RawEncode {
    get obj_id(): ObjectId;
    get obj_owner(): Option<ObjectId>;
    constructor(obj_id: ObjectId, obj_owner: Option<ObjectId>);
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
}
export class ObjectLinkDecoder implements RawDecode<ObjectLink> {
    raw_decode(buf: Uint8Array): BuckyResult<[ObjectLink, Uint8Array]>;
}

export class TypelessDescTypeInfo extends DescTypeInfo {
    obj_type(): number;
    get_sub_obj_type(): number;
    set_sub_obj_type(v: number): void;
    sub_desc_type(): SubDescType;
}
export class TypelessDescContent extends DescContent {
    constructor(buf: Uint8Array, version: number, format: number);
    type_info(): DescTypeInfo;
    codec_info(): ContentCodecInfo;
    buffer(): Uint8Array;
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
}
export class TypelessDescContentDecoder extends DescContentDecoder<TypelessDescContent> {
    constructor();
    type_info(): DescTypeInfo;
    raw_decode(buf: Uint8Array, ctx: ContentRawDecodeContext): BuckyResult<[TypelessDescContent, Uint8Array]>;
}
export class TypelessBodyContent extends BodyContent {
    constructor(buf: Uint8Array, version: number, format: number);
    type_info(): DescTypeInfo;
    codec_info(): ContentCodecInfo;
    buffer(): Uint8Array;
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
}
export class TypelessBodyContentDecoder extends BodyContentDecoder<TypelessBodyContent> {
    constructor();
    type_info(): DescTypeInfo;
    raw_decode(buf: Uint8Array, ctx: ContentRawDecodeContext): BuckyResult<[TypelessBodyContent, Uint8Array]>;
}
export class TypelessAnyObject extends NamedObject<TypelessDescContent, TypelessBodyContent> {
    convert_to<DC extends DescContent, BC extends BodyContent>(desc_content_decoder: DescContentDecoder<DC>, body_content_decoder: BodyContentDecoder<BC>): BuckyResult<NamedObject<DC, BC>>;
}
export class TypelessAnyObjectDecoder<O extends TypelessAnyObject> extends NamedObjectDecoder<TypelessDescContent, TypelessBodyContent, O> {
    constructor(obj_builder: new (...constructorArgs: any[]) => O);
}
export class TypelessStandardObject extends TypelessAnyObject {
}
export class TypelessStandardObjectDecoder extends TypelessAnyObjectDecoder<TypelessStandardObject> {
    constructor();
}
export class TypelessCoreObject extends TypelessAnyObject {
}
export class TypelessCoreObjectDecoder extends TypelessAnyObjectDecoder<TypelessCoreObject> {
    constructor();
}
export class TypelessDECAppObject extends TypelessAnyObject {
}
export class TypelessDECAppObjectDecoder extends TypelessAnyObjectDecoder<TypelessDECAppObject> {
    constructor();
}

export enum ObjectTypeCode {
    Device = 1,
    People = 2,
    SimpleGroup = 3,
    Org = 4,
    AppGroup = 5,
    UnionAccount = 6,
    Chunk = 7,
    File = 8,
    Dir = 9,
    Diff = 10,
    ProofOfService = 11,
    Tx = 12,
    Action = 13,
    ObjectMap = 14,
    Contract = 15,
    Custom = 16
}
export function number_2_obj_type_code(x: number): ObjectTypeCode;
export function number_2_obj_type_code_name(x: number): string;
export function obj_type_code_raw_check(buf: Uint8Array): ObjectTypeCode;
export class ObjectTypeCodeEncoder implements RawEncode {
    value: ObjectTypeCode;
    constructor(value: ObjectTypeCode);
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
}
export class ObjectTypeCodeDecoder implements RawDecode<ObjectTypeCode> {
    raw_decode(buf: Uint8Array): BuckyResult<[ObjectTypeCode, Uint8Array]>;
}

export class OrgDescTypeInfo extends DescTypeInfo {
    obj_type(): number;
    sub_desc_type(): SubDescType;
}
export class OrgDescContent extends DescContent {
    type_info(): DescTypeInfo;
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
}
export class OrgDescContentDecoder extends DescContentDecoder<OrgDescContent> {
    type_info(): DescTypeInfo;
    raw_decode(buf: Uint8Array): BuckyResult<[OrgDescContent, Uint8Array]>;
}
export class Director {
    id: ObjectId;
    right: number;
    constructor(id: ObjectId, right: number);
}
export class OrgMember {
    id: ObjectId;
    right: number;
    shared: JSBI;
    constructor(id: ObjectId, right: number, shared: JSBI);
}
export class OrgBodyContent extends ProtobufBodyContent {
    members: OrgMember[];
    directors: Director[];
    total_equity: JSBI;
    constructor(members: OrgMember[], directors: Director[], total_equity: JSBI);
    try_to_proto(): BuckyResult<protos.OrgBodyContent>;
}
export class OrgBodyContentDecoder extends ProtobufBodyContentDecoder<OrgBodyContent, protos.OrgBodyContent> {
    constructor();
    try_from_proto(value: protos.OrgBodyContent): BuckyResult<OrgBodyContent>;
}
export class OrgDesc extends NamedObjectDesc<OrgDescContent> {
}
export class OrgDescDecoder extends NamedObjectDescDecoder<OrgDescContent> {
    constructor();
}
export class OrgBuilder extends NamedObjectBuilder<OrgDescContent, OrgBodyContent> {
}
export class OrgId extends NamedObjectId<OrgDescContent, OrgBodyContent> {
    constructor(id: ObjectId);
    static default(): OrgId;
    static from_base_58(s: string): BuckyResult<OrgId>;
    static try_from_object_id(id: ObjectId): BuckyResult<OrgId>;
}
export class OrgIdDecoder extends NamedObjectIdDecoder<OrgDescContent, OrgBodyContent> {
    constructor();
}
export class Org extends NamedObject<OrgDescContent, OrgBodyContent> {
    static create(members: OrgMember[], directors: Director[], total_equity: string | number, build?: (builder: OrgBuilder) => void): Org;
    org_id(): OrgId;
    content_info(): OrgBodyContent;
}
export class OrgDecoder extends NamedObjectDecoder<OrgDescContent, OrgBodyContent, Org> {
    constructor();
}

export class PeopleDescTypeInfo extends DescTypeInfo {
    obj_type(): number;
    sub_desc_type(): SubDescType;
}
export class PeopleDescContent extends DescContent {
    type_info(): DescTypeInfo;
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
}
export class PeopleDescContentDecoder extends DescContentDecoder<PeopleDescContent> {
    type_info(): DescTypeInfo;
    raw_decode(buf: Uint8Array): BuckyResult<[PeopleDescContent, Uint8Array]>;
}
export enum OODWorkMode {
    Standalone = "standalone",
    ActiveStandby = "active-standby"
}
export class PeopleBodyContent extends ProtobufBodyContent {
    ood_list: DeviceId[];
    name?: string | undefined;
    icon?: FileId | undefined;
    constructor(ood_list: DeviceId[], name?: string | undefined, icon?: FileId | undefined, ood_work_mode?: OODWorkMode);
    set_name(name?: string): void;
    set_icon(icon?: FileId): void;
    ood_work_mode(): OODWorkMode;
    set_ood_work_mode(ood_mode: OODWorkMode): void;
    try_to_proto(): BuckyResult<protos.PeopleBodyContent>;
}
export class PeopleBodyContentDecoder extends ProtobufBodyContentDecoder<PeopleBodyContent, protos.PeopleBodyContent> {
    constructor();
    try_from_proto(value: protos.PeopleBodyContent): BuckyResult<PeopleBodyContent>;
}
export class PeopleDesc extends NamedObjectDesc<PeopleDescContent> {
}
export class PeopleDescDecoder extends NamedObjectDescDecoder<PeopleDescContent> {
    constructor();
}
export class PeopleBuilder extends NamedObjectBuilder<PeopleDescContent, PeopleBodyContent> {
}
export class PeopleId extends NamedObjectId<PeopleDescContent, PeopleBodyContent> {
    constructor(id: ObjectId);
    static default(): PeopleId;
    static from_base_58(s: string): BuckyResult<PeopleId>;
    static try_from_object_id(id: ObjectId): BuckyResult<PeopleId>;
}
export class PeopleIdDecoder extends NamedObjectIdDecoder<DeviceDescContent, DeviceBodyContent> {
    constructor();
}
export class People extends NamedObject<PeopleDescContent, PeopleBodyContent> {
    static create(owner: Option<ObjectId>, ood_list: DeviceId[], public_key: PublicKey, area: Option<Area>, name?: string, icon?: FileId, build?: (builder: PeopleBuilder) => void): People;
    people_id(): PeopleId;
    name(): string | undefined;
    set_name(name?: string): void;
    ood_work_mode(): OODWorkMode;
    set_ood_work_mode(mode: OODWorkMode): void;
    icon(): FileId | undefined;
    set_icon(icon?: FileId): void;
}
export class PeopleDecoder extends NamedObjectDecoder<PeopleDescContent, PeopleBodyContent, People> {
    constructor();
}

export class SimpleGroupDescTypeInfo extends DescTypeInfo {
    obj_type(): number;
    sub_desc_type(): SubDescType;
}
export class SimpleGroupDescContent extends DescContent {
    type_info(): DescTypeInfo;
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
}
export class SimpleGroupDescContentDecoder extends DescContentDecoder<SimpleGroupDescContent> {
    type_info(): DescTypeInfo;
    raw_decode(buf: Uint8Array): BuckyResult<[SimpleGroupDescContent, Uint8Array]>;
}
export class SimpleGroupBodyContent extends ProtobufBodyContent {
    members: ObjectId[];
    ood_list: DeviceId[];
    constructor(members: ObjectId[], ood_list: DeviceId[], ood_work_mode: OODWorkMode | undefined);
    ood_work_mode(): OODWorkMode;
    set_ood_work_mode(ood_mode: OODWorkMode): void;
    try_to_proto(): BuckyResult<protos.SimpleGroupBodyContent>;
}
export class SimpleGroupBodyContentDecoder extends ProtobufBodyContentDecoder<SimpleGroupBodyContent, protos.SimpleGroupBodyContent> {
    constructor();
    try_from_proto(value: protos.SimpleGroupBodyContent): BuckyResult<SimpleGroupBodyContent>;
}
export class SimpleGroupDesc extends NamedObjectDesc<SimpleGroupDescContent> {
}
export class SimpleGroupDescDecoder extends NamedObjectDescDecoder<SimpleGroupDescContent> {
    constructor();
}
export class SimpleGroupBuilder extends NamedObjectBuilder<SimpleGroupDescContent, SimpleGroupBodyContent> {
}
export class SimpleGroupId extends NamedObjectId<SimpleGroupDescContent, SimpleGroupBodyContent> {
    constructor(id: ObjectId);
    static default(): SimpleGroupId;
    static from_base_58(s: string): BuckyResult<SimpleGroupId>;
    static try_from_object_id(id: ObjectId): BuckyResult<SimpleGroupId>;
}
export class SimpleGroupIdDecoder extends NamedObjectIdDecoder<SimpleGroupDescContent, SimpleGroupBodyContent> {
    constructor();
}
export class SimpleGroup extends NamedObject<SimpleGroupDescContent, SimpleGroupBodyContent> {
    static create(threshold: number, owners: PublicKey[], members: ObjectId[], ood_work_mode: OODWorkMode, ood_list: DeviceId[], area: Area, build?: (builder: SimpleGroupBuilder) => void): SimpleGroup;
    ood_work_mode(): OODWorkMode;
    set_ood_work_mode(mode: OODWorkMode): void;
    simple_group_id(): SimpleGroupId;
    connect_info(): SimpleGroupBodyContent;
}
export class SimpleGroupDecoder extends NamedObjectDecoder<SimpleGroupDescContent, SimpleGroupBodyContent, SimpleGroup> {
    constructor();
}

export class UnionAccountDescTypeInfo extends DescTypeInfo {
    obj_type(): number;
    sub_desc_type(): SubDescType;
}
export class UnionAccountDescContent extends DescContent {
    left: ObjectId;
    right: ObjectId;
    service_type: number;
    constructor(left: ObjectId, right: ObjectId, service_type: number);
    type_info(): DescTypeInfo;
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
}
export class UnionAccountDescContentDecoder extends DescContentDecoder<UnionAccountDescContent> {
    type_info(): DescTypeInfo;
    raw_decode(buf: Uint8Array): BuckyResult<[UnionAccountDescContent, Uint8Array]>;
}
export class UnionAccountBodyContent extends BodyContent {
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
}
export class UnionAccountBodyContentDecoder extends BodyContentDecoder<UnionAccountBodyContent> {
    raw_decode(buf: Uint8Array): BuckyResult<[UnionAccountBodyContent, Uint8Array]>;
}
export class UnionAccountDesc extends NamedObjectDesc<UnionAccountDescContent> {
}
export class UnionAccountDescDecoder extends NamedObjectDescDecoder<UnionAccountDescContent> {
    constructor();
}
export class UnionAccountBuilder extends NamedObjectBuilder<UnionAccountDescContent, UnionAccountBodyContent> {
}
export class UnionAccountId extends NamedObjectId<UnionAccountDescContent, UnionAccountBodyContent> {
    constructor(id: ObjectId);
    static default(): UnionAccountId;
    static from_base_58(s: string): BuckyResult<UnionAccountId>;
    static try_from_object_id(id: ObjectId): BuckyResult<UnionAccountId>;
}
export class UnionAccountIdDecoder extends NamedObjectIdDecoder<UnionAccountDescContent, UnionAccountBodyContent> {
    constructor();
}
export class UnionAccount extends NamedObject<UnionAccountDescContent, UnionAccountBodyContent> {
    static create(account1: ObjectId, account2: ObjectId, service_type: number, build?: (builder: UnionAccountBuilder) => void): UnionAccount;
    union_account_id(): UnionAccountId;
    connect_info(): UnionAccountBodyContent;
}
export class UnionAccountDecoder extends NamedObjectDecoder<UnionAccountDescContent, UnionAccountBodyContent, UnionAccount> {
    constructor();
}

export const UNIQUE_VALUE_LEN = 16;
export class UniqueId implements RawEncode {
    m_buf: Uint8Array;
    constructor(buf: Uint8Array);
    as_slice(): Uint8Array;
    length(): number;
    toJSON(): string;
    static default(): UniqueId;
    static copy_from_slice(buf: Uint8Array): UniqueId;
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
    to_base_58(): string;
    static from_base_58(s: string): BuckyResult<UniqueId>;
}
export class UniqueIdDecoder implements RawDecode<UniqueId> {
    raw_decode(buf: Uint8Array): BuckyResult<[UniqueId, Uint8Array]>;
}

export class ObjectMapDescTypeInfo extends DescTypeInfo {
    obj_type(): number;
    sub_desc_type(): SubDescType;
}
export enum ObjectMapClass {
    Root = 0,
    Sub = 1
}
export enum ObjectMapSimpleContentType {
    Map = "map",
    DiffMap = "diffmap",
    Set = "set",
    DiffSet = "diffset"
}
export class ObjectMapDescContent extends DescContent {
    readonly m_class: ObjectMapClass;
    readonly m_total: JSBI;
    readonly m_size: JSBI;
    readonly m_depth: number;
    readonly m_content_type: ObjectMapSimpleContentType;
    readonly m_encode_buf: Uint8Array;
    constructor(encode_buf: Uint8Array, cls: ObjectMapClass, total: JSBI, size: JSBI, depth: number, content_type: ObjectMapSimpleContentType);
    type_info(): DescTypeInfo;
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
    class(): ObjectMapClass;
    total(): JSBI;
    size(): JSBI;
    depth(): number;
    content_type(): ObjectMapSimpleContentType;
}
export class ObjectMapDescContentDecoder extends DescContentDecoder<ObjectMapDescContent> {
    type_info(): DescTypeInfo;
    raw_decode(buf: Uint8Array): BuckyResult<[ObjectMapDescContent, Uint8Array]>;
}
export class ObjectMapBodyContent extends BodyContent {
    constructor(encode_buf: Uint8Array);
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
}
export class ObjectMapBodyContentDecoder extends BodyContentDecoder<ObjectMapBodyContent> {
    raw_decode(buf: Uint8Array): BuckyResult<[ObjectMapBodyContent, Uint8Array]>;
}
export class ObjectMapDesc extends NamedObjectDesc<ObjectMapDescContent> {
}
export class ObjectMapDescDecoder extends NamedObjectDescDecoder<ObjectMapDescContent> {
    constructor();
}
export class ObjectMapBuilder extends NamedObjectBuilder<ObjectMapDescContent, ObjectMapBodyContent> {
}
export class ObjectMapId extends NamedObjectId<ObjectMapDescContent, ObjectMapBodyContent> {
    constructor(id: ObjectId);
    static default(): ObjectMapId;
    static from_base_58(s: string): BuckyResult<ObjectMapId>;
    static try_from_object_id(id: ObjectId): BuckyResult<ObjectMapId>;
}
export class ObjectMapIdDecoder extends NamedObjectIdDecoder<ObjectMapDescContent, ObjectMapBodyContent> {
    constructor();
}
export class ObjectMap extends NamedObject<ObjectMapDescContent, ObjectMapBodyContent> {
    object_map_id(): ObjectMapId;
}
export class ObjectMapDecoder extends NamedObjectDecoder<ObjectMapDescContent, ObjectMapBodyContent, ObjectMap> {
    constructor();
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class ChunkTransContract implements RawEncode {
    price_per_kbytes: number;
    obj_list: Option<ObjectId[]>;
    min_speed: Option<number>;
    max_speed: Option<number>;
    avg_speed: Option<number>;
    max_bytes: Option<JSBI>;
    constructor(price_per_kbytes: number, obj_list: Option<ObjectId[]>, min_speed: Option<number>, max_speed: Option<number>, avg_speed: Option<number>, max_bytes: Option<JSBI>);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class ChunkTransContractDecoder implements RawDecode<ChunkTransContract> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[ChunkTransContract, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class ChunkTransReceipt implements RawEncode {
    chunk_id: ChunkId;
    crypto_chunk_id: ChunkId;
    valid_length: Option<JSBI>;
    max_speed: Option<number>;
    min_speed: Option<number>;
    crypto_key: Option<JSBI>;
    constructor(chunk_id: ChunkId, crypto_chunk_id: ChunkId, valid_length: Option<JSBI>, max_speed: Option<number>, min_speed: Option<number>, crypto_key: Option<JSBI>);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class ChunkTransReceiptDecoder implements RawDecode<ChunkTransReceipt> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[ChunkTransReceipt, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class DSGReceipt implements RawEncode {
    constructor();
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class DSGReceiptDecoder implements RawDecode<DSGReceipt> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[DSGReceipt, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class ProofData implements RawEncode {
    data: Uint8Array;
    constructor(data: Uint8Array);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class ProofDataDecoder implements RawDecode<ProofData> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[ProofData, Uint8Array]>;
}

export class ProofDataExt {
    obj: ProofData;
    constructor(obj: ProofData);
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class ProofOfDSG implements RawEncode {
    constructor();
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class ProofOfDSGDecoder implements RawDecode<ProofOfDSG> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[ProofOfDSG, Uint8Array]>;
}

export class ProofOfDSGExt {
    obj: ProofOfDSG;
    constructor(obj: ProofOfDSG);
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class ProofOfServiceDescTypeInfo extends DescTypeInfo {
    obj_type(): number;
    sub_desc_type(): SubDescType;
}
export class ProofOfServiceDescContent extends DescContent {
    proof_type: ProofTypeCode;
    data: ProofData;
    constructor(proof_type: ProofTypeCode, data: ProofData);
    type_info(): DescTypeInfo;
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
}
export class ProofOfServiceDescContentDecoder extends DescContentDecoder<ProofOfServiceDescContent> {
    type_info(): DescTypeInfo;
    raw_decode(buf: Uint8Array): BuckyResult<[ProofOfServiceDescContent, Uint8Array]>;
}
export class ProofOfServiceBodyContent extends BodyContent {
    data: ProofData;
    constructor(data: ProofData);
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
}
export class ProofOfServiceBodyContentDecoder extends BodyContentDecoder<ProofOfServiceBodyContent> {
    raw_decode(buf: Uint8Array): BuckyResult<[ProofOfServiceBodyContent, Uint8Array]>;
}
export class ProofOfServiceDesc extends NamedObjectDesc<ProofOfServiceDescContent> {
}
export class ProofOfServiceDescDecoder extends NamedObjectDescDecoder<ProofOfServiceDescContent> {
    constructor();
}
export class ProofOfServiceBuilder extends NamedObjectBuilder<ProofOfServiceDescContent, ProofOfServiceBodyContent> {
}
export class ProofOfServiceId extends NamedObjectId<ProofOfServiceDescContent, ProofOfServiceBodyContent> {
    constructor(id: ObjectId);
    static default(): ProofOfServiceId;
    static from_base_58(s: string): BuckyResult<ProofOfServiceId>;
    static try_from_object_id(id: ObjectId): BuckyResult<ProofOfServiceId>;
}
export class ProofOfServiceIdDecoder extends NamedObjectIdDecoder<ProofOfServiceDescContent, ProofOfServiceBodyContent> {
    constructor();
}
export class ProofOfService extends NamedObject<ProofOfServiceDescContent, ProofOfServiceBodyContent> {
    static create(owner: Option<ObjectId>, proof_type: ProofTypeCode, data_0: ProofData, data_1: ProofData): ProofOfService;
    ext(): ProofOfServiceExt;
}
export class ProofOfServiceDecoder extends NamedObjectDecoder<ProofOfServiceDescContent, ProofOfServiceBodyContent, ProofOfService> {
    constructor();
}

export class ProofOfServiceExt {
    obj: ProofOfService;
    constructor(obj: ProofOfService);
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class ProofOfSNService implements RawEncode {
    version: SnServiceReceiptVersion;
    grade: SnServiceGrade;
    rto: JSBI;
    duration: JSBI;
    start_time: JSBI;
    ping_count: JSBI;
    ping_resp_count: JSBI;
    called_count: JSBI;
    call_peer_count: JSBI;
    connect_peer_count: JSBI;
    call_delay: JSBI;
    constructor(version: SnServiceReceiptVersion, grade: SnServiceGrade, rto: JSBI, duration: JSBI, start_time: JSBI, ping_count: JSBI, ping_resp_count: JSBI, called_count: JSBI, call_peer_count: JSBI, connect_peer_count: JSBI, call_delay: JSBI);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class ProofOfSNServiceDecoder implements RawDecode<ProofOfSNService> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[ProofOfSNService, Uint8Array]>;
}

export class ProofOfSNServiceExt {
    obj: ProofOfSNService;
    constructor(obj: ProofOfSNService);
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class ProofTypeCode implements RawEncode {
    static DSGStorage(): ProofTypeCode;
    static DSGStorageCheck(): ProofTypeCode;
    static DSGMerkleProof(): ProofTypeCode;
    match<T>(visitor: {
        DSGStorage?: () => T;
        DSGStorageCheck?: () => T;
        DSGMerkleProof?: () => T;
    }): T | undefined;
    eq_type(rhs: ProofTypeCode): boolean;
    ext(): ProofTypeCodeExt;
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class ProofTypeCodeDecoder implements RawDecode<ProofTypeCode> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[ProofTypeCode, Uint8Array]>;
}

export class ProofTypeCodeExt {
    obj: ProofTypeCode;
    constructor(obj: ProofTypeCode);
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class Service implements RawEncode {
    static Contract(contract: ServiceContract): Service;
    static Receipt(receipt: ServiceReceipt): Service;
    match<T>(visitor: {
        Contract?: (contract: ServiceContract) => T;
        Receipt?: (receipt: ServiceReceipt) => T;
    }): T | undefined;
    eq_type(rhs: Service): boolean;
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class ServiceDecoder implements RawDecode<Service> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[Service, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class ServiceContract implements RawEncode {
    buyer: ObjectId;
    seller: ObjectId;
    customer: Option<ObjectId>;
    service_type: number;
    service_start: JSBI;
    service_end: JSBI;
    coin_id: Option<number>;
    total_price: Option<JSBI>;
    advance_payment: Option<JSBI>;
    contract_body: ServiceContractBody;
    constructor(buyer: ObjectId, seller: ObjectId, customer: Option<ObjectId>, service_type: number, service_start: JSBI, service_end: JSBI, coin_id: Option<number>, total_price: Option<JSBI>, advance_payment: Option<JSBI>, contract_body: ServiceContractBody);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class ServiceContractDecoder implements RawDecode<ServiceContract> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[ServiceContract, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class ServiceContractBody implements RawEncode {
    static Traffic(traffic: TrafficContract): ServiceContractBody;
    static ChunkTrans(chunktrans: ChunkTransContract): ServiceContractBody;
    match<T>(visitor: {
        Traffic?: (traffic: TrafficContract) => T;
        ChunkTrans?: (chunktrans: ChunkTransContract) => T;
    }): T | undefined;
    eq_type(rhs: ServiceContractBody): boolean;
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class ServiceContractBodyDecoder implements RawDecode<ServiceContractBody> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[ServiceContractBody, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class ServiceReceipt implements RawEncode {
    customer: ObjectId;
    service_type: number;
    service_start: JSBI;
    service_end: JSBI;
    receipt_body: ServiceReceiptBody;
    constructor(customer: ObjectId, service_type: number, service_start: JSBI, service_end: JSBI, receipt_body: ServiceReceiptBody);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class ServiceReceiptDecoder implements RawDecode<ServiceReceipt> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[ServiceReceipt, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class ServiceReceiptBody implements RawEncode {
    static SN(sn: SNReceipt): ServiceReceiptBody;
    static Traffic(traffic: TrafficReceipt): ServiceReceiptBody;
    static ChunkTrans(chunktrans: ChunkTransReceipt): ServiceReceiptBody;
    static DSG(dsg: DSGReceipt): ServiceReceiptBody;
    match<T>(visitor: {
        SN?: (sn: SNReceipt) => T;
        Traffic?: (traffic: TrafficReceipt) => T;
        ChunkTrans?: (chunktrans: ChunkTransReceipt) => T;
        DSG?: (dsg: DSGReceipt) => T;
    }): T | undefined;
    eq_type(rhs: ServiceReceiptBody): boolean;
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class ServiceReceiptBodyDecoder implements RawDecode<ServiceReceiptBody> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[ServiceReceiptBody, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class SNReceipt implements RawEncode {
    ping_count: Option<number>;
    called_count: Option<number>;
    success_called_count: Option<number>;
    constructor(ping_count: Option<number>, called_count: Option<number>, success_called_count: Option<number>);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class SNReceiptDecoder implements RawDecode<SNReceipt> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[SNReceipt, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class SnServiceGrade implements RawEncode {
    static None(): SnServiceGrade;
    static Discard(): SnServiceGrade;
    static Passable(): SnServiceGrade;
    static Normal(): SnServiceGrade;
    static Fine(): SnServiceGrade;
    static Wonderfull(): SnServiceGrade;
    match<T>(visitor: {
        None?: () => T;
        Discard?: () => T;
        Passable?: () => T;
        Normal?: () => T;
        Fine?: () => T;
        Wonderfull?: () => T;
    }): T | undefined;
    eq_type(rhs: SnServiceGrade): boolean;
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class SnServiceGradeDecoder implements RawDecode<SnServiceGrade> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[SnServiceGrade, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class SnServiceReceiptVersion implements RawEncode {
    static Invalid(): SnServiceReceiptVersion;
    static Current(): SnServiceReceiptVersion;
    match<T>(visitor: {
        Invalid?: () => T;
        Current?: () => T;
    }): T | undefined;
    eq_type(rhs: SnServiceReceiptVersion): boolean;
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class SnServiceReceiptVersionDecoder implements RawDecode<SnServiceReceiptVersion> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[SnServiceReceiptVersion, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class TrafficContract implements RawEncode {
    price_per_kbytes: number;
    avg_ping_ms: Option<number>;
    max_up_bytes: Option<JSBI>;
    max_up_speed: Option<number>;
    min_up_speed: Option<number>;
    max_down_bytes: Option<JSBI>;
    max_down_speed: Option<number>;
    min_down_speed: Option<number>;
    constructor(price_per_kbytes: number, avg_ping_ms: Option<number>, max_up_bytes: Option<JSBI>, max_up_speed: Option<number>, min_up_speed: Option<number>, max_down_bytes: Option<JSBI>, max_down_speed: Option<number>, min_down_speed: Option<number>);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class TrafficContractDecoder implements RawDecode<TrafficContract> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[TrafficContract, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class TrafficReceipt implements RawEncode {
    up_bytes: JSBI;
    down_bytes: JSBI;
    total_package: JSBI;
    max_speed: Option<number>;
    min_speed: Option<number>;
    avg_ping_ms: Option<number>;
    stream_count: Option<number>;
    failed_stream_count: Option<number>;
    break_stream_count: Option<number>;
    constructor(up_bytes: JSBI, down_bytes: JSBI, total_package: JSBI, max_speed: Option<number>, min_speed: Option<number>, avg_ping_ms: Option<number>, stream_count: Option<number>, failed_stream_count: Option<number>, break_stream_count: Option<number>);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class TrafficReceiptDecoder implements RawDecode<TrafficReceipt> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[TrafficReceipt, Uint8Array]>;
}

export class NameInfo {
    sub_records: BuckyMap<BuckyString, NameRecord>;
    record: NameRecord;
    owner: Option<ObjectId>;
    constructor(sub_records: BuckyMap<BuckyString, NameRecord>, record: NameRecord, owner: Option<ObjectId>);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class NameInfoDecoder implements RawDecode<NameInfo> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[NameInfo, Uint8Array]>;
}

export class NameLink implements RawEncode {
    static ObjectLink(obj_link: ObjectId): NameLink;
    static OtherNameLink(other_name_link: string): NameLink;
    static IPLink(ip_link: IpAddr): NameLink;
    match<T>(visitor: {
        ObjectLink?: (obj_link: ObjectId) => T;
        OtherNameLink?: (other_name_link: string) => T;
        IPLink?: (ip_link: IpAddr) => T;
    }): T | undefined;
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class NameLinkDecoder implements RawDecode<NameLink> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[NameLink, Uint8Array]>;
}

export class NameRecord implements RawEncode {
    link: NameLink;
    user_data: string;
    constructor(link: NameLink, user_data: string);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class NameRecordDecoder implements RawDecode<NameRecord> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[NameRecord, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class NameState implements RawEncode {
    static Normal(): NameState;
    static Lock(): NameState;
    static Auction(): NameState;
    static ArrearsAuction(): NameState;
    static ArrearsAuctionWait(): NameState;
    static ActiveAuction(): NameState;
    match<T>(visitor: {
        Normal?: () => T;
        Lock?: () => T;
        Auction?: () => T;
        ArrearsAuction?: () => T;
        ArrearsAuctionWait?: () => T;
        ActiveAuction?: () => T;
    }): T | undefined;
    eq_type(rhs: NameState): boolean;
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class NameStateDecoder implements RawDecode<NameState> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[NameState, Uint8Array]>;
}

export { JSBI };

export class CreateContractTx implements RawEncode {
    value: JSBI;
    init_data: Uint8Array;
    constructor(value: JSBI, init_data: Uint8Array);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class CreateContractTxDecoder implements RawDecode<CreateContractTx> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[CreateContractTx, Uint8Array]>;
}

export class CreateContract2Tx implements RawEncode {
    value: JSBI;
    init_data: Uint8Array;
    salt: Uint8Array;
    constructor(value: JSBI, init_data: Uint8Array, salt: Uint8Array);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class CreateContract2TxDecoder implements RawDecode<CreateContract2Tx> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[CreateContract2Tx, Uint8Array]>;
}

export class CallContractTx implements RawEncode {
    address: ObjectId;
    value: JSBI;
    data: Uint8Array;
    constructor(address: ObjectId, value: JSBI, data: Uint8Array);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class CallContractTxDecoder implements RawDecode<CallContractTx> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[CallContractTx, Uint8Array]>;
}

export class TypeBuffer<T extends RawEncode> implements RawEncode {
    obj: T;
    constructor(obj: T);
    raw_measure(ctx?: any, purpose?: RawEncodePurpose): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any, purpose?: RawEncodePurpose): BuckyResult<Uint8Array>;
}
export class TypeBufferDecoder<T extends RawEncode, D extends RawDecode<T>> implements RawDecode<TypeBuffer<T>> {
    constructor(inner_decoder: D);
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[TypeBuffer<T>, Uint8Array]>;
}

export class ViewContract implements RawEncode {
    address: ObjectId;
    data: Uint8Array;
    constructor(address: ObjectId, data: Uint8Array);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class ViewContractDecoder implements RawDecode<ViewContract> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[ViewContract, Uint8Array]>;
}

export class ViewLog implements RawEncode {
    address: ObjectId;
    from: number;
    to: number;
    topic: Vec<OptionEncoder<BuckyFixedBuffer>>;
    constructor(address: ObjectId, from: number, to: number, topics: (Uint8Array | null)[]);
    raw_measure(ctx?: any, purpose?: RawEncodePurpose): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any, purpose?: RawEncodePurpose): BuckyResult<Uint8Array>;
}
export class ViewLogDecoder implements RawDecode<ViewLog> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[ViewLog, Uint8Array]>;
}

export class ViewNFTBuyList implements RawEncode {
    object_id: ObjectId;
    offset: number;
    length: number;
    constructor(object_id: ObjectId, offset: number, length: number);
    raw_encode(buf: Uint8Array, ctx?: any, purpose?: RawEncodePurpose): BuckyResult<Uint8Array>;
    raw_measure(ctx?: any, purpose?: RawEncodePurpose): BuckyResult<number>;
}
export class ViewNFTBuyListDecoder implements RawDecode<ViewNFTBuyList> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[ViewNFTBuyList, Uint8Array]>;
}

export class ViewBenefi implements RawEncode {
    address: ObjectId;
    constructor(address: ObjectId);
    raw_encode(buf: Uint8Array, ctx?: any, purpose?: RawEncodePurpose): BuckyResult<Uint8Array>;
    raw_measure(ctx?: any, purpose?: RawEncodePurpose): BuckyResult<number>;
}
export class ViewBenefiDecoder implements RawDecode<ViewBenefi> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[ViewBenefi, Uint8Array]>;
}

export class ViewContractResult implements RawEncode {
    ret: number;
    value: Uint8Array;
    constructor(ret: number, value: Uint8Array);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class ViewContractResultDecoder implements RawDecode<ViewContractResult> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[ViewContractResult, Uint8Array]>;
}

export class ViewLogResult implements RawEncode {
    logs: [Uint8Array[], Uint8Array][];
    constructor(logs: Vec<BuckyTuple>);
    raw_measure(ctx?: any, purpose?: RawEncodePurpose): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any, purpose?: RawEncodePurpose): BuckyResult<Uint8Array>;
}
export class ViewLogResultDecoder implements RawDecode<ViewLogResult> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[ViewLogResult, Uint8Array]>;
}

export class NFTBuyItem implements RawEncode {
    buyer_id: ObjectId;
    price: number;
    coin_id: CoinTokenId;
    constructor(buyer_id: ObjectId, price: number, coin_id: CoinTokenId);
    raw_encode(buf: Uint8Array, ctx?: any, purpose?: RawEncodePurpose): BuckyResult<Uint8Array>;
    raw_measure(ctx?: any, purpose?: RawEncodePurpose): BuckyResult<number>;
}
export class NFTBuyItemDecoder implements RawDecode<NFTBuyItem> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[NFTBuyItem, Uint8Array]>;
}
export class ViewNFTBuyListResult implements RawEncode {
    sum: number;
    list: NFTBuyItem[];
    constructor(sum: number, list: NFTBuyItem[]);
    raw_encode(buf: Uint8Array, ctx?: any, purpose?: RawEncodePurpose): BuckyResult<Uint8Array>;
    raw_measure(ctx?: any, purpose?: RawEncodePurpose): BuckyResult<number>;
}
export class ViewNFTBuyListResultDecoder implements RawDecode<ViewNFTBuyListResult> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[ViewNFTBuyListResult, Uint8Array]>;
}
export class NFTLargestBuyValueData implements RawEncode {
    buyer_id: ObjectId;
    coin_id: CoinTokenId;
    price: number;
    constructor(buyer_id: ObjectId, coin_id: CoinTokenId, price: number);
    raw_encode(buf: Uint8Array, ctx?: any, purpose?: RawEncodePurpose): BuckyResult<Uint8Array>;
    raw_measure(ctx?: any, purpose?: RawEncodePurpose): BuckyResult<number>;
}
export class NFTLargestBuyValueDataDecoder implements RawDecode<NFTLargestBuyValueData> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[NFTLargestBuyValueData, Uint8Array]>;
}
export class NFTLargestBuyValue implements RawEncode {
    value: Option<NFTLargestBuyValueData>;
    constructor(value: Option<NFTLargestBuyValueData>);
    raw_encode(buf: Uint8Array, ctx?: any, purpose?: RawEncodePurpose): BuckyResult<Uint8Array>;
    raw_measure(ctx?: any, purpose?: RawEncodePurpose): BuckyResult<number>;
}
export class NFTLargestBuyValueDecoder implements RawDecode<NFTLargestBuyValue> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[NFTLargestBuyValue, Uint8Array]>;
}

export class ViewBenefiResult implements RawEncode {
    address: ObjectId;
    constructor(address: ObjectId);
    raw_encode(buf: Uint8Array, ctx?: any, purpose?: RawEncodePurpose): BuckyResult<Uint8Array>;
    raw_measure(ctx?: any, purpose?: RawEncodePurpose): BuckyResult<number>;
}
export class ViewBenefiResultDecoder implements RawDecode<ViewBenefiResult> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[ViewBenefiResult, Uint8Array]>;
}

export interface UtilOutputRequestCommon {
    req_path?: string;
    dec_id?: ObjectId;
    target?: ObjectId;
    flags: number;
}
export class UtilOutputRequestCommonJsonCodec extends JsonCodec<UtilOutputRequestCommon> {
    constructor();
    encode_object(param: UtilOutputRequestCommon): any;
    decode_object(o: any): BuckyResult<UtilOutputRequestCommon>;
}
export interface UtilGetDeviceOutputRequest {
    common: UtilOutputRequestCommon;
}
export interface UtilGetDeviceOutputResponse {
    device_id: DeviceId;
    device: Device;
}
export interface UtilGetZoneOutputRequest {
    common: UtilOutputRequestCommon;
    object_id?: ObjectId;
    object_raw?: Uint8Array;
}
export interface UtilGetZoneOutputResponse {
    zone_id: ZoneId;
    zone: Zone;
    device_id: DeviceId;
}
export interface UtilResolveOODOutputRequest {
    common: UtilOutputRequestCommon;
    object_id: ObjectId;
    owner_id?: ObjectId;
}
export interface UtilResolveOODOutputResponse {
    device_list: DeviceId[];
}
export class UtilResolveOODOutputResponseJsonCodec extends JsonCodec<UtilResolveOODOutputResponse> {
    constructor();
    decode_object(o: any): BuckyResult<UtilResolveOODOutputResponse>;
}
export enum OODNetworkType {
    Unknown = "unknown",
    Intranet = "intranet",
    Extranet = "extranet"
}
export interface OODStatus {
    network: OODNetworkType;
    first_ping: JSBI;
    first_success_ping: JSBI;
    last_success_ping: JSBI;
    last_ping: JSBI;
    last_ping_result: number;
    ping_count: number;
    ping_success_count: JSBI;
    cont_fail_count: number;
    ping_avg_during: JSBI;
    ping_max_during: JSBI;
    ping_min_during: JSBI;
    ood_device_id: DeviceId;
    enable_sync: boolean;
    device_root_state: ObjectId;
    device_root_state_revision: JSBI;
    zone_root_state?: ObjectId;
    zone_root_state_revision: JSBI;
}
export class OODStatusJsonCodec extends JsonCodec<OODStatus> {
    constructor();
    decode_object(o: any): BuckyResult<OODStatus>;
}
export interface UtilGetOODStatusOutputRequest {
    common: UtilOutputRequestCommon;
}
export interface UtilGetOODStatusOutputResponse {
    status: OODStatus;
}
export class UtilGetOODStatusOutputResponseJsonCodec extends JsonCodec<UtilGetOODStatusOutputResponse> {
    constructor();
    decode_object(o: any): BuckyResult<UtilGetOODStatusOutputResponse>;
}
export interface UtilGetNOCInfoOutputRequest {
    common: UtilOutputRequestCommon;
}
export interface UtilGetNOCInfoOutputResponse {
    stat: NamedObjectCacheStat;
}
export interface DeviceStaticInfo {
    device_id: DeviceId;
    device: Device;
    is_ood_device: boolean;
    ood_work_mode: OODWorkMode;
    zone_role: ZoneRole;
    ood_device_id: DeviceId;
    zone_id: ZoneId;
    owner_id?: ObjectId;
    cyfs_root: string;
}
export class DeviceStaticInfoJsonCodec extends JsonCodec<DeviceStaticInfo> {
    constructor();
    decode_object(o: any): BuckyResult<DeviceStaticInfo>;
}
export interface UtilGetDeviceStaticInfoOutputRequest {
    common: UtilOutputRequestCommon;
}
export interface UtilGetDeviceStaticInfoOutputResponse {
    info: DeviceStaticInfo;
}
export class UtilGetDeviceStaticInfoOutputResponseJsonCodec extends JsonCodec<UtilGetDeviceStaticInfoOutputResponse> {
    constructor();
    decode_object(o: any): BuckyResult<UtilGetDeviceStaticInfoOutputResponse>;
}
export enum BdtNetworkAccessType {
    NAT = "nat",
    WAN = "wan"
}
export interface BdtNetworkAccessEndpoint {
    lan_ep: Endpoint;
    wan_ep: Endpoint;
    access_type: BdtNetworkAccessType;
}
export class BdtNetworkAccessEndpointJsonCodec extends JsonCodec<BdtNetworkAccessEndpoint> {
    constructor();
    decode_object(o: any): BuckyResult<BdtNetworkAccessEndpoint>;
}
export interface BdtNetworkAccessSn {
    sn: DeviceId;
    sn_status: SnStatus;
}
export class BdtNetworkAccessSnJsonCodec extends JsonCodec<BdtNetworkAccessSn> {
    constructor();
    decode_object(o: any): BuckyResult<BdtNetworkAccessSn>;
}
export interface BdtNetworkAccessInfo {
    v4: BdtNetworkAccessEndpoint[];
    v6: BdtNetworkAccessEndpoint[];
    sn: BdtNetworkAccessSn[];
}
export class BdtNetworkAccessInfoJsonCodec extends JsonCodec<BdtNetworkAccessInfo> {
    constructor();
    decode_object(o: any): BuckyResult<BdtNetworkAccessInfo>;
}
export interface UtilGetNetworkAccessInfoOutputRequest {
    common: UtilOutputRequestCommon;
}
export interface UtilGetNetworkAccessInfoOutputResponse {
    info: BdtNetworkAccessInfo;
}
export class UtilGetNetworkAccessInfoOutputResponseJsonCodec extends JsonCodec<UtilGetNetworkAccessInfoOutputResponse> {
    constructor();
    decode_object(o: any): BuckyResult<UtilGetNetworkAccessInfoOutputResponse>;
}
export interface UtilGetSystemInfoOutputRequest {
    common: UtilOutputRequestCommon;
}
export interface UtilGetSystemInfoOutputResponse {
    info: SystemInfo;
}
export interface VersionInfo {
    version: string;
    channel: CyfsChannel;
    target: string;
}
export interface UtilGetVersionInfoOutputRequest {
    common: UtilOutputRequestCommon;
}
export interface UtilGetVersionInfoOutputResponse {
    info: VersionInfo;
}
export interface UtilBuildDirFromObjectMapOutputRequest {
    common: UtilOutputRequestCommon;
    object_map_id: ObjectId;
    dir_type: BuildDirType;
}
export class UtilBuildDirFromObjectMapOutputRequestCodec extends JsonCodec<UtilBuildDirFromObjectMapOutputRequest> {
    constructor();
    encode_object(param: UtilBuildDirFromObjectMapOutputRequest): any;
}
export interface UtilBuildDirFromObjectMapOutputResponse {
    object_id: ObjectId;
}
export class UtilBuildDirFromObjectMapOutputResponseJsonCodec extends JsonCodec<UtilBuildDirFromObjectMapOutputResponse> {
    constructor();
    decode_object(o: any): BuckyResult<UtilBuildDirFromObjectMapOutputResponse>;
}

export class TransContextTypeInfo extends DescTypeInfo {
    obj_type(): number;
    sub_desc_type(): SubDescType;
}
export class TransContextDescContent extends ProtobufDescContent {
    constructor(dec_id: ObjectId, context_name: string);
    try_to_proto(): BuckyResult<any>;
    type_info(): DescTypeInfo;
}
export class TransContextDescContentDecoder extends ProtobufDescContentDecoder<TransContextDescContent, protos.TransContextDescContent> {
    constructor();
    try_from_proto(value: protos.TransContextDescContent): BuckyResult<TransContextDescContent>;
    type_info(): DescTypeInfo;
}
export class TransContextBodyContent extends ProtobufBodyContent {
    constructor(ref_id: Option<ObjectId>, device_list: DeviceId[]);
    try_to_proto(): BuckyResult<protos.TransContextBodyContent>;
}
export class TransContextBodyContentDecoder extends ProtobufBodyContentDecoder<TransContextBodyContent, protos.TransContextBodyContent> {
    constructor();
    try_from_proto(value: protos.TransContextBodyContent): BuckyResult<TransContextBodyContent>;
}
export class TransContext extends NamedObject<TransContextDescContent, TransContextBodyContent> {
}
export class TransContextDecoder extends NamedObjectDecoder<TransContextDescContent, TransContextBodyContent, TransContext> {
    constructor();
}

export abstract class WebSocketRequestHandler {
    on_request(requestor: WebSocketRequestManager, cmd: number, content: Uint8Array): Promise<BuckyResult<Option<Uint8Array>>>;
    process_string_request(requestor: WebSocketRequestManager, cmd: number, content: Uint8Array): Promise<BuckyResult<Option<Uint8Array>>>;
    on_string_request(requestor: WebSocketRequestManager, cmd: number, content: string): Promise<BuckyResult<Option<string>>>;
    abstract on_session_begin(session: WebSocketSession): Promise<void>;
    abstract on_session_end(session: WebSocketSession): Promise<void>;
    abstract clone_handler(): WebSocketRequestHandler;
}
export class RequestItem {
    seq: number;
    send_tick: JSBI;
    resp: Option<BuckyResult<Uint8Array>>;
    isTimeout: boolean;
    resolve?: () => void;
    waker: Promise<void>;
    constructor(seq: number, send_tick: JSBI);
    timeout(): void;
}
interface RequestResult {
    seq: number;
    req_item: RequestItem;
    list: {
        [n: number]: RequestItem;
    };
}
export class WebSocketRequestContainer {
    next_seq: number;
    list: {
        [n: number]: RequestItem;
    };
    new_request(sid: number): RequestResult;
    remove_request(seq: number): RequestItem;
    check_timeout(): {};
    clear(): void;
    static on_timeout(sid: number, list: {
        [n: number]: RequestItem;
    }): void;
}
export class WebSocketRequestManager {
    handler: WebSocketRequestHandler;
    is_monitor: boolean;
    sid: number;
    session: Option<WebSocketSession>;
    reqs: WebSocketRequestContainer;
    constructor(handler: WebSocketRequestHandler);
    is_session_valid(): boolean;
    bind_session(session: WebSocketSession): void;
    unbind_session(): void;
    static on_msg(requestor: WebSocketRequestManager, packet: WSPacket): Promise<BuckyResult<void>>;
    post_bytes_req(cmd: number, msg: Uint8Array): Promise<BuckyResult<Uint8Array>>;
    post_req(cmd: number, msg: string): Promise<BuckyResult<string>>;
    on_resp(packet: WSPacket): Promise<BuckyResult<void>>;
    monitor(): Promise<void>;
    stop_monitor(): void;
    post_to_session(buf: Uint8Array): Promise<BuckyResult<void>>;
    post_req_without_resp(cmd: number, msg: string): BuckyResult<void>;
    post_buffer_req_without_resp(cmd: number, msg: Uint8Array): BuckyResult<void>;
}
export {};

export class WebSocketSession {
    sid: number;
    handler: WebSocketRequestHandler;
    requestor: WebSocketRequestManager;
    constructor(sid: number, source: string, handler: WebSocketRequestHandler);
    post_msg(msg: Uint8Array): BuckyResult<void>;
    static run_client(session: WebSocketSession, ws: WebSocket): Promise<void>;
    static run(session: WebSocketSession, ws: WebSocket, as_server: boolean): Promise<void>;
}

export class WebSocketClient {
    service_url: string;
    handler: WebSocketRequestHandler;
    ws?: WebSocket;
    session_manager: WebSocketSessionManager;
    constructor(service_url: string, handler: WebSocketRequestHandler);
    select_session(): WebSocketSession | undefined;
    run(): Promise<void>;
    run_once(): Promise<unknown>;
    start(): void;
}

export interface EthAbiResult extends ReadonlyArray<any> {
    readonly [key: string]: any;
}
export function checkResultErrors(result: EthAbiResult): {
    path: (string | number)[];
    error: Error;
}[];
export type CoerceFunc = (type: string, value: any) => any;
export abstract class Coder {
    readonly name: string;
    readonly type: string;
    readonly localName?: string;
    readonly dynamic: boolean;
    constructor(name: string, type: string, localName: string | undefined, dynamic: boolean);
    _throwError(message: string, value: any): void;
    abstract encode(writer: Writer, value: any): number;
    abstract decode(reader: Reader): any;
    abstract defaultValue(): any;
}
export class Writer {
    readonly wordSize: number;
    _data: Uint8Array[];
    _dataLength: number;
    _padding: Uint8Array;
    constructor(wordSize: number);
    get data(): string;
    get length(): number;
    _writeData(data: Uint8Array): number;
    appendWriter(writer: Writer): number;
    writeBytes(value: BytesLike): number;
    _getValue(value: BigNumberish): Uint8Array;
    writeValue(value: BigNumberish): number;
    writeUpdatableValue(): (value: BigNumberish) => void;
}
export class Reader {
    readonly wordSize: number;
    readonly _coerceFunc?: CoerceFunc | undefined;
    readonly allowLoose?: boolean | undefined;
    readonly _data: Uint8Array;
    _offset: number;
    constructor(data: BytesLike, wordSize: number, _coerceFunc?: CoerceFunc | undefined, allowLoose?: boolean | undefined);
    get data(): string;
    get consumed(): number;
    static coerce(name: string, value: any): any;
    coerce(name: string, value: any): any;
    _peekBytes(offset: number, length: number, loose?: boolean): Uint8Array;
    subReader(offset: number): Reader;
    readBytes(length: number, loose?: boolean): Uint8Array;
    readValue(): BigNumber;
}

export abstract class ProtobufDescContent extends DescContent {
    constructor();
    abstract try_to_proto(): BuckyResult<jspb.Message>;
    codec_info(): ContentCodecInfo;
    raw_measure(ctx?: any, purpose?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any, purpose?: any): BuckyResult<Uint8Array>;
}
export abstract class ProtobufDescContentDecoder<T extends DescContent, P extends jspb.Message> extends DescContentDecoder<T> {
    constructor(decode: (reader: Uint8Array) => P);
    abstract try_from_proto(value: P): BuckyResult<T>;
    raw_decode(buf: Uint8Array, ctx: ContentRawDecodeContext): BuckyResult<[T, Uint8Array]>;
}
export abstract class ProtobufBodyContent extends BodyContent {
    constructor();
    abstract try_to_proto(): BuckyResult<jspb.Message>;
    codec_info(): ContentCodecInfo;
    raw_measure(ctx?: any, purpose?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any, purpose?: any): BuckyResult<Uint8Array>;
}
export abstract class ProtobufBodyContentDecoder<T extends BodyContent, P extends jspb.Message> extends BodyContentDecoder<T> {
    constructor(decode: (reader: Uint8Array) => P);
    abstract try_from_proto(value: P): BuckyResult<T>;
    raw_decode(buf: Uint8Array, ctx: ContentRawDecodeContext): BuckyResult<[T, Uint8Array]>;
}
export class ProtobufCodecHelper {
    static ensure_not_null<T>(value: T | null | undefined): BuckyResult<T>;
    static encode_buf_list<T extends RawEncode>(list: T[]): BuckyResult<Uint8Array[]>;
    static encode_multi_buf_list<T extends RawEncode>(...list: T[][]): BuckyResult<Uint8Array[][]>;
    static decode_buf_list<T>(list: Uint8Array[], decoder: RawDecode<T>): BuckyResult<T[]>;
    static encode_buf<T extends RawEncode>(value: T): BuckyResult<Uint8Array>;
    static decode_buf<T>(item: Uint8Array, decoder: RawDecode<T>): BuckyResult<T>;
    static encode_int64(value: JSBI): Long.Long;
    static decode_int64(value: string | number): JSBI;
}
export class EmptyProtobufBodyContent extends ProtobufBodyContent {
    constructor();
    try_to_proto(): BuckyResult<protos.EmptyContent>;
}
export class EmptyProtobufBodyContentDecoder extends ProtobufBodyContentDecoder<EmptyProtobufBodyContent, protos.EmptyContent> {
    constructor();
    try_from_proto(value: protos.EmptyContent): BuckyResult<EmptyProtobufBodyContent>;
}

export interface SystemInfo {
    name: string;
    cpu_usage: number;
    total_memory: number;
    used_memory: number;
    received_bytes: number;
    transmitted_bytes: number;
    ssd_disk_total: number;
    ssd_disk_avail: number;
    hdd_disk_total: number;
    hdd_disk_avail: number;
}
export enum SnStatus {
    Init = "init",
    Connecting = "connecting",
    Online = "online",
    Offline = "offline"
}
export interface NamedObjectCacheStat {
    count: number;
    storage_size: number;
}

export class WSPacketHeader {
    seq: number;
    cmd: number;
    content_length: number;
    magic: number;
    version: number;
    constructor(seq: number, cmd: number, content_length: number);
    static parse(buf: Uint8Array): BuckyResult<WSPacketHeader>;
    encode(buf: Uint8Array): void;
}
export class WSPacket {
    header: WSPacketHeader;
    content: Uint8Array;
    constructor(header: WSPacketHeader, content: Uint8Array);
    static new_from_buffer(seq: number, cmd: number, msg: Uint8Array): WSPacket;
    static decode_from_buffer(buf: Uint8Array): WSPacket;
    encode(): Uint8Array;
}

class WebSocketSessionManagerInner {
    list: WebSocketSession[];
    next_sid: number;
    constructor(handler: WebSocketRequestHandler);
    get_session(sid: number): WebSocketSession | undefined;
    select_session(): WebSocketSession | undefined;
    new_session(source: string): WebSocketSession;
    remove_session(sid: number): WebSocketSession | undefined;
}
export class WebSocketSessionManager extends WebSocketSessionManagerInner {
    constructor(handler: WebSocketRequestHandler);
    run_client_session(service_url: string, ws: WebSocket): Promise<WebSocketSession>;
}
export {};



export class EmptyContent extends jspb.Message {
    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): EmptyContent.AsObject;
    static toObject(includeInstance: boolean, msg: EmptyContent): EmptyContent.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: EmptyContent, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): EmptyContent;
    static deserializeBinaryFromReader(message: EmptyContent, reader: jspb.BinaryReader): EmptyContent;
}

export namespace EmptyContent {
    export type AsObject = {
    }
}

export class EmptyContentV1 extends jspb.Message {
    hasName(): boolean;
    clearName(): void;
    getName(): string;
    setName(value: string): void;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): EmptyContentV1.AsObject;
    static toObject(includeInstance: boolean, msg: EmptyContentV1): EmptyContentV1.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: EmptyContentV1, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): EmptyContentV1;
    static deserializeBinaryFromReader(message: EmptyContentV1, reader: jspb.BinaryReader): EmptyContentV1;
}

export namespace EmptyContentV1 {
    export type AsObject = {
        name: string,
    }
}



export class ContractBodyContent extends jspb.Message {
    getData(): Uint8Array | string;
    getData_asU8(): Uint8Array;
    getData_asB64(): string;
    setData(value: Uint8Array | string): void;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): ContractBodyContent.AsObject;
    static toObject(includeInstance: boolean, msg: ContractBodyContent): ContractBodyContent.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: ContractBodyContent, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): ContractBodyContent;
    static deserializeBinaryFromReader(message: ContractBodyContent, reader: jspb.BinaryReader): ContractBodyContent;
}

export namespace ContractBodyContent {
    export type AsObject = {
        data: Uint8Array | string,
    }
}

export class DeviceBodyContent extends jspb.Message {
    clearEndpointsList(): void;
    getEndpointsList(): Array<Uint8Array | string>;
    getEndpointsList_asU8(): Array<Uint8Array>;
    getEndpointsList_asB64(): Array<string>;
    setEndpointsList(value: Array<Uint8Array | string>): void;
    addEndpoints(value: Uint8Array | string, index?: number): Uint8Array | string;

    clearSnListList(): void;
    getSnListList(): Array<Uint8Array | string>;
    getSnListList_asU8(): Array<Uint8Array>;
    getSnListList_asB64(): Array<string>;
    setSnListList(value: Array<Uint8Array | string>): void;
    addSnList(value: Uint8Array | string, index?: number): Uint8Array | string;

    clearPassivePnListList(): void;
    getPassivePnListList(): Array<Uint8Array | string>;
    getPassivePnListList_asU8(): Array<Uint8Array>;
    getPassivePnListList_asB64(): Array<string>;
    setPassivePnListList(value: Array<Uint8Array | string>): void;
    addPassivePnList(value: Uint8Array | string, index?: number): Uint8Array | string;

    hasName(): boolean;
    clearName(): void;
    getName(): string;
    setName(value: string): void;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): DeviceBodyContent.AsObject;
    static toObject(includeInstance: boolean, msg: DeviceBodyContent): DeviceBodyContent.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: DeviceBodyContent, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): DeviceBodyContent;
    static deserializeBinaryFromReader(message: DeviceBodyContent, reader: jspb.BinaryReader): DeviceBodyContent;
}

export namespace DeviceBodyContent {
    export type AsObject = {
        endpointsList: Array<Uint8Array | string>,
        snListList: Array<Uint8Array | string>,
        passivePnListList: Array<Uint8Array | string>,
        name: string,
    }
}

export class DirBodyContent extends jspb.Message {
    getType(): DirBodyContent.TypeMap[keyof DirBodyContent.TypeMap];
    setType(value: DirBodyContent.TypeMap[keyof DirBodyContent.TypeMap]): void;

    hasChunkId(): boolean;
    clearChunkId(): void;
    getChunkId(): Uint8Array | string;
    getChunkId_asU8(): Uint8Array;
    getChunkId_asB64(): string;
    setChunkId(value: Uint8Array | string): void;

    clearObjListList(): void;
    getObjListList(): Array<DirBodyContent.ObjItem>;
    setObjListList(value: Array<DirBodyContent.ObjItem>): void;
    addObjList(value?: DirBodyContent.ObjItem, index?: number): DirBodyContent.ObjItem;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): DirBodyContent.AsObject;
    static toObject(includeInstance: boolean, msg: DirBodyContent): DirBodyContent.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: DirBodyContent, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): DirBodyContent;
    static deserializeBinaryFromReader(message: DirBodyContent, reader: jspb.BinaryReader): DirBodyContent;
}

export namespace DirBodyContent {
    export type AsObject = {
        type: DirBodyContent.TypeMap[keyof DirBodyContent.TypeMap],
        chunkId: Uint8Array | string,
        objListList: Array<DirBodyContent.ObjItem.AsObject>,
    }

    export class ObjItem extends jspb.Message {
        getObjId(): Uint8Array | string;
        getObjId_asU8(): Uint8Array;
        getObjId_asB64(): string;
        setObjId(value: Uint8Array | string): void;

        getValue(): Uint8Array | string;
        getValue_asU8(): Uint8Array;
        getValue_asB64(): string;
        setValue(value: Uint8Array | string): void;

        serializeBinary(): Uint8Array;
        toObject(includeInstance?: boolean): ObjItem.AsObject;
        static toObject(includeInstance: boolean, msg: ObjItem): ObjItem.AsObject;
        static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
        static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
        static serializeBinaryToWriter(message: ObjItem, writer: jspb.BinaryWriter): void;
        static deserializeBinary(bytes: Uint8Array): ObjItem;
        static deserializeBinaryFromReader(message: ObjItem, reader: jspb.BinaryReader): ObjItem;
    }

    export namespace ObjItem {
        export type AsObject = {
            objId: Uint8Array | string,
            value: Uint8Array | string,
        }
    }

    export interface TypeMap {
        CHUNK: 0;
        OBJLIST: 1;
    }

    export const Type: TypeMap;
}

export class ChunkList extends jspb.Message {
    getType(): ChunkList.TypeMap[keyof ChunkList.TypeMap];
    setType(value: ChunkList.TypeMap[keyof ChunkList.TypeMap]): void;

    clearChunkIdListList(): void;
    getChunkIdListList(): Array<Uint8Array | string>;
    getChunkIdListList_asU8(): Array<Uint8Array>;
    getChunkIdListList_asB64(): Array<string>;
    setChunkIdListList(value: Array<Uint8Array | string>): void;
    addChunkIdList(value: Uint8Array | string, index?: number): Uint8Array | string;

    getFileId(): Uint8Array | string;
    getFileId_asU8(): Uint8Array;
    getFileId_asB64(): string;
    setFileId(value: Uint8Array | string): void;

    hasHashMethod(): boolean;
    clearHashMethod(): void;
    getHashMethod(): ChunkList.HashMethodMap[keyof ChunkList.HashMethodMap];
    setHashMethod(value: ChunkList.HashMethodMap[keyof ChunkList.HashMethodMap]): void;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): ChunkList.AsObject;
    static toObject(includeInstance: boolean, msg: ChunkList): ChunkList.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: ChunkList, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): ChunkList;
    static deserializeBinaryFromReader(message: ChunkList, reader: jspb.BinaryReader): ChunkList;
}

export namespace ChunkList {
    export type AsObject = {
        type: ChunkList.TypeMap[keyof ChunkList.TypeMap],
        chunkIdListList: Array<Uint8Array | string>,
        fileId: Uint8Array | string,
        hashMethod: ChunkList.HashMethodMap[keyof ChunkList.HashMethodMap],
    }

    export interface TypeMap {
        CHUNKINLIST: 0;
        CHUNKINFILE: 1;
        CHUNKINBUNDLE: 2;
    }

    export const Type: TypeMap;

    export interface HashMethodMap {
        SERIAL: 0;
    }

    export const HashMethod: HashMethodMap;
}

export class FileBodyContent extends jspb.Message {
    hasChunkList(): boolean;
    clearChunkList(): void;
    getChunkList(): ChunkList | undefined;
    setChunkList(value?: ChunkList): void;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): FileBodyContent.AsObject;
    static toObject(includeInstance: boolean, msg: FileBodyContent): FileBodyContent.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: FileBodyContent, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): FileBodyContent;
    static deserializeBinaryFromReader(message: FileBodyContent, reader: jspb.BinaryReader): FileBodyContent;
}

export namespace FileBodyContent {
    export type AsObject = {
        chunkList?: ChunkList.AsObject,
    }
}

export class Director extends jspb.Message {
    getId(): Uint8Array | string;
    getId_asU8(): Uint8Array;
    getId_asB64(): string;
    setId(value: Uint8Array | string): void;

    getRight(): number;
    setRight(value: number): void;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): Director.AsObject;
    static toObject(includeInstance: boolean, msg: Director): Director.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: Director, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): Director;
    static deserializeBinaryFromReader(message: Director, reader: jspb.BinaryReader): Director;
}

export namespace Director {
    export type AsObject = {
        id: Uint8Array | string,
        right: number,
    }
}

export class OrgMember extends jspb.Message {
    getId(): Uint8Array | string;
    getId_asU8(): Uint8Array;
    getId_asB64(): string;
    setId(value: Uint8Array | string): void;

    getRight(): number;
    setRight(value: number): void;

    getShares(): string;
    setShares(value: string): void;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): OrgMember.AsObject;
    static toObject(includeInstance: boolean, msg: OrgMember): OrgMember.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: OrgMember, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): OrgMember;
    static deserializeBinaryFromReader(message: OrgMember, reader: jspb.BinaryReader): OrgMember;
}

export namespace OrgMember {
    export type AsObject = {
        id: Uint8Array | string,
        right: number,
        shares: string,
    }
}

export class OrgBodyContent extends jspb.Message {
    clearMembersList(): void;
    getMembersList(): Array<OrgMember>;
    setMembersList(value: Array<OrgMember>): void;
    addMembers(value?: OrgMember, index?: number): OrgMember;

    clearDirectorsList(): void;
    getDirectorsList(): Array<Director>;
    setDirectorsList(value: Array<Director>): void;
    addDirectors(value?: Director, index?: number): Director;

    getTotalEquity(): string;
    setTotalEquity(value: string): void;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): OrgBodyContent.AsObject;
    static toObject(includeInstance: boolean, msg: OrgBodyContent): OrgBodyContent.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: OrgBodyContent, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): OrgBodyContent;
    static deserializeBinaryFromReader(message: OrgBodyContent, reader: jspb.BinaryReader): OrgBodyContent;
}

export namespace OrgBodyContent {
    export type AsObject = {
        membersList: Array<OrgMember.AsObject>,
        directorsList: Array<Director.AsObject>,
        totalEquity: string,
    }
}

export class PeopleBodyContent extends jspb.Message {
    clearOodListList(): void;
    getOodListList(): Array<Uint8Array | string>;
    getOodListList_asU8(): Array<Uint8Array>;
    getOodListList_asB64(): Array<string>;
    setOodListList(value: Array<Uint8Array | string>): void;
    addOodList(value: Uint8Array | string, index?: number): Uint8Array | string;

    hasName(): boolean;
    clearName(): void;
    getName(): string;
    setName(value: string): void;

    hasIcon(): boolean;
    clearIcon(): void;
    getIcon(): Uint8Array | string;
    getIcon_asU8(): Uint8Array;
    getIcon_asB64(): string;
    setIcon(value: Uint8Array | string): void;

    hasOodWorkMode(): boolean;
    clearOodWorkMode(): void;
    getOodWorkMode(): string;
    setOodWorkMode(value: string): void;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): PeopleBodyContent.AsObject;
    static toObject(includeInstance: boolean, msg: PeopleBodyContent): PeopleBodyContent.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: PeopleBodyContent, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): PeopleBodyContent;
    static deserializeBinaryFromReader(message: PeopleBodyContent, reader: jspb.BinaryReader): PeopleBodyContent;
}

export namespace PeopleBodyContent {
    export type AsObject = {
        oodListList: Array<Uint8Array | string>,
        name: string,
        icon: Uint8Array | string,
        oodWorkMode: string,
    }
}

export class SimpleGroupBodyContent extends jspb.Message {
    clearMembersList(): void;
    getMembersList(): Array<Uint8Array | string>;
    getMembersList_asU8(): Array<Uint8Array>;
    getMembersList_asB64(): Array<string>;
    setMembersList(value: Array<Uint8Array | string>): void;
    addMembers(value: Uint8Array | string, index?: number): Uint8Array | string;

    clearOodListList(): void;
    getOodListList(): Array<Uint8Array | string>;
    getOodListList_asU8(): Array<Uint8Array>;
    getOodListList_asB64(): Array<string>;
    setOodListList(value: Array<Uint8Array | string>): void;
    addOodList(value: Uint8Array | string, index?: number): Uint8Array | string;

    hasOodWorkMode(): boolean;
    clearOodWorkMode(): void;
    getOodWorkMode(): string;
    setOodWorkMode(value: string): void;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): SimpleGroupBodyContent.AsObject;
    static toObject(includeInstance: boolean, msg: SimpleGroupBodyContent): SimpleGroupBodyContent.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: SimpleGroupBodyContent, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): SimpleGroupBodyContent;
    static deserializeBinaryFromReader(message: SimpleGroupBodyContent, reader: jspb.BinaryReader): SimpleGroupBodyContent;
}

export namespace SimpleGroupBodyContent {
    export type AsObject = {
        membersList: Array<Uint8Array | string>,
        oodListList: Array<Uint8Array | string>,
        oodWorkMode: string,
    }
}

export class TxBodyContent extends jspb.Message {
    getData(): Uint8Array | string;
    getData_asU8(): Uint8Array;
    getData_asB64(): string;
    setData(value: Uint8Array | string): void;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): TxBodyContent.AsObject;
    static toObject(includeInstance: boolean, msg: TxBodyContent): TxBodyContent.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: TxBodyContent, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): TxBodyContent;
    static deserializeBinaryFromReader(message: TxBodyContent, reader: jspb.BinaryReader): TxBodyContent;
}

export namespace TxBodyContent {
    export type AsObject = {
        data: Uint8Array | string,
    }
}

export class ProofData extends jspb.Message {
    getData(): Uint8Array | string;
    getData_asU8(): Uint8Array;
    getData_asB64(): string;
    setData(value: Uint8Array | string): void;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): ProofData.AsObject;
    static toObject(includeInstance: boolean, msg: ProofData): ProofData.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: ProofData, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): ProofData;
    static deserializeBinaryFromReader(message: ProofData, reader: jspb.BinaryReader): ProofData;
}

export namespace ProofData {
    export type AsObject = {
        data: Uint8Array | string,
    }
}

export class ProofOfServiceBodyContent extends jspb.Message {
    hasData(): boolean;
    clearData(): void;
    getData(): ProofData | undefined;
    setData(value?: ProofData): void;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): ProofOfServiceBodyContent.AsObject;
    static toObject(includeInstance: boolean, msg: ProofOfServiceBodyContent): ProofOfServiceBodyContent.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: ProofOfServiceBodyContent, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): ProofOfServiceBodyContent;
    static deserializeBinaryFromReader(message: ProofOfServiceBodyContent, reader: jspb.BinaryReader): ProofOfServiceBodyContent;
}

export namespace ProofOfServiceBodyContent {
    export type AsObject = {
        data?: ProofData.AsObject,
    }
}



export class StorageDescContent extends jspb.Message {
    getId(): string;
    setId(value: string): void;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): StorageDescContent.AsObject;
    static toObject(includeInstance: boolean, msg: StorageDescContent): StorageDescContent.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: StorageDescContent, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): StorageDescContent;
    static deserializeBinaryFromReader(message: StorageDescContent, reader: jspb.BinaryReader): StorageDescContent;
}

export namespace StorageDescContent {
    export type AsObject = {
        id: string,
    }
}

export class StorageBodyContent extends jspb.Message {
    getValue(): Uint8Array | string;
    getValue_asU8(): Uint8Array;
    getValue_asB64(): string;
    setValue(value: Uint8Array | string): void;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): StorageBodyContent.AsObject;
    static toObject(includeInstance: boolean, msg: StorageBodyContent): StorageBodyContent.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: StorageBodyContent, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): StorageBodyContent;
    static deserializeBinaryFromReader(message: StorageBodyContent, reader: jspb.BinaryReader): StorageBodyContent;
}

export namespace StorageBodyContent {
    export type AsObject = {
        value: Uint8Array | string,
    }
}

export class TextDescContent extends jspb.Message {
    getId(): string;
    setId(value: string): void;

    getHeader(): string;
    setHeader(value: string): void;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): TextDescContent.AsObject;
    static toObject(includeInstance: boolean, msg: TextDescContent): TextDescContent.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: TextDescContent, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): TextDescContent;
    static deserializeBinaryFromReader(message: TextDescContent, reader: jspb.BinaryReader): TextDescContent;
}

export namespace TextDescContent {
    export type AsObject = {
        id: string,
        header: string,
    }
}

export class TextContent extends jspb.Message {
    getValue(): string;
    setValue(value: string): void;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): TextContent.AsObject;
    static toObject(includeInstance: boolean, msg: TextContent): TextContent.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: TextContent, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): TextContent;
    static deserializeBinaryFromReader(message: TextContent, reader: jspb.BinaryReader): TextContent;
}

export namespace TextContent {
    export type AsObject = {
        value: string,
    }
}

export class ZoneDescContent extends jspb.Message {
    getOwner(): Uint8Array | string;
    getOwner_asU8(): Uint8Array;
    getOwner_asB64(): string;
    setOwner(value: Uint8Array | string): void;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): ZoneDescContent.AsObject;
    static toObject(includeInstance: boolean, msg: ZoneDescContent): ZoneDescContent.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: ZoneDescContent, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): ZoneDescContent;
    static deserializeBinaryFromReader(message: ZoneDescContent, reader: jspb.BinaryReader): ZoneDescContent;
}

export namespace ZoneDescContent {
    export type AsObject = {
        owner: Uint8Array | string,
    }
}

export class ZoneBodyContent extends jspb.Message {
    clearOodListList(): void;
    getOodListList(): Array<Uint8Array | string>;
    getOodListList_asU8(): Array<Uint8Array>;
    getOodListList_asB64(): Array<string>;
    setOodListList(value: Array<Uint8Array | string>): void;
    addOodList(value: Uint8Array | string, index?: number): Uint8Array | string;

    clearKnownDeviceListList(): void;
    getKnownDeviceListList(): Array<Uint8Array | string>;
    getKnownDeviceListList_asU8(): Array<Uint8Array>;
    getKnownDeviceListList_asB64(): Array<string>;
    setKnownDeviceListList(value: Array<Uint8Array | string>): void;
    addKnownDeviceList(value: Uint8Array | string, index?: number): Uint8Array | string;

    hasOodWorkMode(): boolean;
    clearOodWorkMode(): void;
    getOodWorkMode(): string;
    setOodWorkMode(value: string): void;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): ZoneBodyContent.AsObject;
    static toObject(includeInstance: boolean, msg: ZoneBodyContent): ZoneBodyContent.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: ZoneBodyContent, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): ZoneBodyContent;
    static deserializeBinaryFromReader(message: ZoneBodyContent, reader: jspb.BinaryReader): ZoneBodyContent;
}

export namespace ZoneBodyContent {
    export type AsObject = {
        oodListList: Array<Uint8Array | string>,
        knownDeviceListList: Array<Uint8Array | string>,
        oodWorkMode: string,
    }
}

export class AppExtInfoDescContent extends jspb.Message {
    getId(): string;
    setId(value: string): void;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): AppExtInfoDescContent.AsObject;
    static toObject(includeInstance: boolean, msg: AppExtInfoDescContent): AppExtInfoDescContent.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: AppExtInfoDescContent, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): AppExtInfoDescContent;
    static deserializeBinaryFromReader(message: AppExtInfoDescContent, reader: jspb.BinaryReader): AppExtInfoDescContent;
}

export namespace AppExtInfoDescContent {
    export type AsObject = {
        id: string,
    }
}

export class AppExtInfoBodyContent extends jspb.Message {
    getInfo(): string;
    setInfo(value: string): void;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): AppExtInfoBodyContent.AsObject;
    static toObject(includeInstance: boolean, msg: AppExtInfoBodyContent): AppExtInfoBodyContent.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: AppExtInfoBodyContent, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): AppExtInfoBodyContent;
    static deserializeBinaryFromReader(message: AppExtInfoBodyContent, reader: jspb.BinaryReader): AppExtInfoBodyContent;
}

export namespace AppExtInfoBodyContent {
    export type AsObject = {
        info: string,
    }
}

export class AppPermission extends jspb.Message {
    getPermission(): string;
    setPermission(value: string): void;

    getReason(): string;
    setReason(value: string): void;

    getState(): number;
    setState(value: number): void;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): AppPermission.AsObject;
    static toObject(includeInstance: boolean, msg: AppPermission): AppPermission.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: AppPermission, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): AppPermission;
    static deserializeBinaryFromReader(message: AppPermission, reader: jspb.BinaryReader): AppPermission;
}

export namespace AppPermission {
    export type AsObject = {
        permission: string,
        reason: string,
        state: number,
    }
}

export class AppLocalStatusDesc extends jspb.Message {
    getId(): Uint8Array | string;
    getId_asU8(): Uint8Array;
    getId_asB64(): string;
    setId(value: Uint8Array | string): void;

    getStatus(): number;
    setStatus(value: number): void;

    hasVersion(): boolean;
    clearVersion(): void;
    getVersion(): string;
    setVersion(value: string): void;

    hasWebDir(): boolean;
    clearWebDir(): void;
    getWebDir(): Uint8Array | string;
    getWebDir_asU8(): Uint8Array;
    getWebDir_asB64(): string;
    setWebDir(value: Uint8Array | string): void;

    clearPermissionsList(): void;
    getPermissionsList(): Array<AppPermission>;
    setPermissionsList(value: Array<AppPermission>): void;
    addPermissions(value?: AppPermission, index?: number): AppPermission;

    hasQuota(): boolean;
    clearQuota(): void;
    getQuota(): AppQuota | undefined;
    setQuota(value?: AppQuota): void;

    getLastStatusUpdateTime(): string;
    setLastStatusUpdateTime(value: string): void;

    getSubError(): number;
    setSubError(value: number): void;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): AppLocalStatusDesc.AsObject;
    static toObject(includeInstance: boolean, msg: AppLocalStatusDesc): AppLocalStatusDesc.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: AppLocalStatusDesc, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): AppLocalStatusDesc;
    static deserializeBinaryFromReader(message: AppLocalStatusDesc, reader: jspb.BinaryReader): AppLocalStatusDesc;
}

export namespace AppLocalStatusDesc {
    export type AsObject = {
        id: Uint8Array | string,
        status: number,
        version: string,
        webDir: Uint8Array | string,
        permissionsList: Array<AppPermission.AsObject>,
        quota?: AppQuota.AsObject,
        lastStatusUpdateTime: string,
        subError: number,
    }
}

export class AppSettingDesc extends jspb.Message {
    getId(): Uint8Array | string;
    getId_asU8(): Uint8Array;
    getId_asB64(): string;
    setId(value: Uint8Array | string): void;

    getAutoUpdate(): boolean;
    setAutoUpdate(value: boolean): void;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): AppSettingDesc.AsObject;
    static toObject(includeInstance: boolean, msg: AppSettingDesc): AppSettingDesc.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: AppSettingDesc, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): AppSettingDesc;
    static deserializeBinaryFromReader(message: AppSettingDesc, reader: jspb.BinaryReader): AppSettingDesc;
}

export namespace AppSettingDesc {
    export type AsObject = {
        id: Uint8Array | string,
        autoUpdate: boolean,
    }
}

export class AppLocalListDesc extends jspb.Message {
    getId(): string;
    setId(value: string): void;

    clearListList(): void;
    getListList(): Array<AppLocalListItem>;
    setListList(value: Array<AppLocalListItem>): void;
    addList(value?: AppLocalListItem, index?: number): AppLocalListItem;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): AppLocalListDesc.AsObject;
    static toObject(includeInstance: boolean, msg: AppLocalListDesc): AppLocalListDesc.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: AppLocalListDesc, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): AppLocalListDesc;
    static deserializeBinaryFromReader(message: AppLocalListDesc, reader: jspb.BinaryReader): AppLocalListDesc;
}

export namespace AppLocalListDesc {
    export type AsObject = {
        id: string,
        listList: Array<AppLocalListItem.AsObject>,
    }
}

export class AppLocalListItem extends jspb.Message {
    getAppId(): Uint8Array | string;
    getAppId_asU8(): Uint8Array;
    getAppId_asB64(): string;
    setAppId(value: Uint8Array | string): void;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): AppLocalListItem.AsObject;
    static toObject(includeInstance: boolean, msg: AppLocalListItem): AppLocalListItem.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: AppLocalListItem, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): AppLocalListItem;
    static deserializeBinaryFromReader(message: AppLocalListItem, reader: jspb.BinaryReader): AppLocalListItem;
}

export namespace AppLocalListItem {
    export type AsObject = {
        appId: Uint8Array | string,
    }
}

export class AddApp extends jspb.Message {
    hasAppOwnerId(): boolean;
    clearAppOwnerId(): void;
    getAppOwnerId(): Uint8Array | string;
    getAppOwnerId_asU8(): Uint8Array;
    getAppOwnerId_asB64(): string;
    setAppOwnerId(value: Uint8Array | string): void;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): AddApp.AsObject;
    static toObject(includeInstance: boolean, msg: AddApp): AddApp.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: AddApp, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): AddApp;
    static deserializeBinaryFromReader(message: AddApp, reader: jspb.BinaryReader): AddApp;
}

export namespace AddApp {
    export type AsObject = {
        appOwnerId: Uint8Array | string,
    }
}

export class InstallApp extends jspb.Message {
    getVer(): string;
    setVer(value: string): void;

    getRunAfterInstall(): boolean;
    setRunAfterInstall(value: boolean): void;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): InstallApp.AsObject;
    static toObject(includeInstance: boolean, msg: InstallApp): InstallApp.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: InstallApp, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): InstallApp;
    static deserializeBinaryFromReader(message: InstallApp, reader: jspb.BinaryReader): InstallApp;
}

export namespace InstallApp {
    export type AsObject = {
        ver: string,
        runAfterInstall: boolean,
    }
}

export class AppQuota extends jspb.Message {
    getMem(): string;
    setMem(value: string): void;

    getDiskSpace(): string;
    setDiskSpace(value: string): void;

    getCpu(): string;
    setCpu(value: string): void;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): AppQuota.AsObject;
    static toObject(includeInstance: boolean, msg: AppQuota): AppQuota.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: AppQuota, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): AppQuota;
    static deserializeBinaryFromReader(message: AppQuota, reader: jspb.BinaryReader): AppQuota;
}

export namespace AppQuota {
    export type AsObject = {
        mem: string,
        diskSpace: string,
        cpu: string,
    }
}

export class StringBoolMapItem extends jspb.Message {
    getKey(): string;
    setKey(value: string): void;

    getValue(): boolean;
    setValue(value: boolean): void;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): StringBoolMapItem.AsObject;
    static toObject(includeInstance: boolean, msg: StringBoolMapItem): StringBoolMapItem.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: StringBoolMapItem, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): StringBoolMapItem;
    static deserializeBinaryFromReader(message: StringBoolMapItem, reader: jspb.BinaryReader): StringBoolMapItem;
}

export namespace StringBoolMapItem {
    export type AsObject = {
        key: string,
        value: boolean,
    }
}

export class ModifyAppPermission extends jspb.Message {
    clearPermissionList(): void;
    getPermissionList(): Array<StringBoolMapItem>;
    setPermissionList(value: Array<StringBoolMapItem>): void;
    addPermission(value?: StringBoolMapItem, index?: number): StringBoolMapItem;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): ModifyAppPermission.AsObject;
    static toObject(includeInstance: boolean, msg: ModifyAppPermission): ModifyAppPermission.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: ModifyAppPermission, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): ModifyAppPermission;
    static deserializeBinaryFromReader(message: ModifyAppPermission, reader: jspb.BinaryReader): ModifyAppPermission;
}

export namespace ModifyAppPermission {
    export type AsObject = {
        permissionList: Array<StringBoolMapItem.AsObject>,
    }
}

export class CmdCode extends jspb.Message {
    getCode(): number;
    setCode(value: number): void;

    hasAddApp(): boolean;
    clearAddApp(): void;
    getAddApp(): AddApp | undefined;
    setAddApp(value?: AddApp): void;

    hasInstallApp(): boolean;
    clearInstallApp(): void;
    getInstallApp(): InstallApp | undefined;
    setInstallApp(value?: InstallApp): void;

    hasAppPermission(): boolean;
    clearAppPermission(): void;
    getAppPermission(): ModifyAppPermission | undefined;
    setAppPermission(value?: ModifyAppPermission): void;

    hasAppQuota(): boolean;
    clearAppQuota(): void;
    getAppQuota(): AppQuota | undefined;
    setAppQuota(value?: AppQuota): void;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): CmdCode.AsObject;
    static toObject(includeInstance: boolean, msg: CmdCode): CmdCode.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: CmdCode, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): CmdCode;
    static deserializeBinaryFromReader(message: CmdCode, reader: jspb.BinaryReader): CmdCode;
}

export namespace CmdCode {
    export type AsObject = {
        code: number,
        addApp?: AddApp.AsObject,
        installApp?: InstallApp.AsObject,
        appPermission?: ModifyAppPermission.AsObject,
        appQuota?: AppQuota.AsObject,
    }
}

export class AppCmdDesc extends jspb.Message {
    getAppId(): Uint8Array | string;
    getAppId_asU8(): Uint8Array;
    getAppId_asB64(): string;
    setAppId(value: Uint8Array | string): void;

    hasCmdCode(): boolean;
    clearCmdCode(): void;
    getCmdCode(): CmdCode | undefined;
    setCmdCode(value?: CmdCode): void;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): AppCmdDesc.AsObject;
    static toObject(includeInstance: boolean, msg: AppCmdDesc): AppCmdDesc.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: AppCmdDesc, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): AppCmdDesc;
    static deserializeBinaryFromReader(message: AppCmdDesc, reader: jspb.BinaryReader): AppCmdDesc;
}

export namespace AppCmdDesc {
    export type AsObject = {
        appId: Uint8Array | string,
        cmdCode?: CmdCode.AsObject,
    }
}

export class AppCmdListDesc extends jspb.Message {
    getId(): string;
    setId(value: string): void;

    clearListList(): void;
    getListList(): Array<AppCmdListItem>;
    setListList(value: Array<AppCmdListItem>): void;
    addList(value?: AppCmdListItem, index?: number): AppCmdListItem;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): AppCmdListDesc.AsObject;
    static toObject(includeInstance: boolean, msg: AppCmdListDesc): AppCmdListDesc.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: AppCmdListDesc, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): AppCmdListDesc;
    static deserializeBinaryFromReader(message: AppCmdListDesc, reader: jspb.BinaryReader): AppCmdListDesc;
}

export namespace AppCmdListDesc {
    export type AsObject = {
        id: string,
        listList: Array<AppCmdListItem.AsObject>,
    }
}

export class AppCmdListItem extends jspb.Message {
    getCmd(): Uint8Array | string;
    getCmd_asU8(): Uint8Array;
    getCmd_asB64(): string;
    setCmd(value: Uint8Array | string): void;

    getRetryCount(): number;
    setRetryCount(value: number): void;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): AppCmdListItem.AsObject;
    static toObject(includeInstance: boolean, msg: AppCmdListItem): AppCmdListItem.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: AppCmdListItem, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): AppCmdListItem;
    static deserializeBinaryFromReader(message: AppCmdListItem, reader: jspb.BinaryReader): AppCmdListItem;
}

export namespace AppCmdListItem {
    export type AsObject = {
        cmd: Uint8Array | string,
        retryCount: number,
    }
}

export class DecIpInfo extends jspb.Message {
    getName(): string;
    setName(value: string): void;

    getIp(): string;
    setIp(value: string): void;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): DecIpInfo.AsObject;
    static toObject(includeInstance: boolean, msg: DecIpInfo): DecIpInfo.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: DecIpInfo, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): DecIpInfo;
    static deserializeBinaryFromReader(message: DecIpInfo, reader: jspb.BinaryReader): DecIpInfo;
}

export namespace DecIpInfo {
    export type AsObject = {
        name: string,
        ip: string,
    }
}

export class DecAclInfo extends jspb.Message {
    getName(): string;
    setName(value: string): void;

    getAclInfoMap(): jspb.Map<string, boolean>;
    clearAclInfoMap(): void;
    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): DecAclInfo.AsObject;
    static toObject(includeInstance: boolean, msg: DecAclInfo): DecAclInfo.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: DecAclInfo, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): DecAclInfo;
    static deserializeBinaryFromReader(message: DecAclInfo, reader: jspb.BinaryReader): DecAclInfo;
}

export namespace DecAclInfo {
    export type AsObject = {
        name: string,
        aclInfoMap: Array<[string, boolean]>,
    }
}

export class RegisterDec extends jspb.Message {
    getDockerGatewayIp(): string;
    setDockerGatewayIp(value: string): void;

    getDecListMap(): jspb.Map<string, DecIpInfo>;
    clearDecListMap(): void;
    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): RegisterDec.AsObject;
    static toObject(includeInstance: boolean, msg: RegisterDec): RegisterDec.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: RegisterDec, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): RegisterDec;
    static deserializeBinaryFromReader(message: RegisterDec, reader: jspb.BinaryReader): RegisterDec;
}

export namespace RegisterDec {
    export type AsObject = {
        dockerGatewayIp: string,
        decListMap: Array<[string, DecIpInfo.AsObject]>,
    }
}

export class UnregisterDec extends jspb.Message {
    getDecListMap(): jspb.Map<string, string>;
    clearDecListMap(): void;
    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): UnregisterDec.AsObject;
    static toObject(includeInstance: boolean, msg: UnregisterDec): UnregisterDec.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: UnregisterDec, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): UnregisterDec;
    static deserializeBinaryFromReader(message: UnregisterDec, reader: jspb.BinaryReader): UnregisterDec;
}

export namespace UnregisterDec {
    export type AsObject = {
        decListMap: Array<[string, string]>,
    }
}

export class ModifyAcl extends jspb.Message {
    getDecListMap(): jspb.Map<string, DecAclInfo>;
    clearDecListMap(): void;
    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): ModifyAcl.AsObject;
    static toObject(includeInstance: boolean, msg: ModifyAcl): ModifyAcl.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: ModifyAcl, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): ModifyAcl;
    static deserializeBinaryFromReader(message: ModifyAcl, reader: jspb.BinaryReader): ModifyAcl;
}

export namespace ModifyAcl {
    export type AsObject = {
        decListMap: Array<[string, DecAclInfo.AsObject]>,
    }
}

export class AppManagerActionDesc extends jspb.Message {
    hasRegisterDec(): boolean;
    clearRegisterDec(): void;
    getRegisterDec(): RegisterDec | undefined;
    setRegisterDec(value?: RegisterDec): void;

    hasUnregisterDec(): boolean;
    clearUnregisterDec(): void;
    getUnregisterDec(): UnregisterDec | undefined;
    setUnregisterDec(value?: UnregisterDec): void;

    hasModifyAcl(): boolean;
    clearModifyAcl(): void;
    getModifyAcl(): ModifyAcl | undefined;
    setModifyAcl(value?: ModifyAcl): void;

    getAppmanageractionenumCase(): AppManagerActionDesc.AppmanageractionenumCase;
    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): AppManagerActionDesc.AsObject;
    static toObject(includeInstance: boolean, msg: AppManagerActionDesc): AppManagerActionDesc.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: AppManagerActionDesc, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): AppManagerActionDesc;
    static deserializeBinaryFromReader(message: AppManagerActionDesc, reader: jspb.BinaryReader): AppManagerActionDesc;
}

export namespace AppManagerActionDesc {
    export type AsObject = {
        registerDec?: RegisterDec.AsObject,
        unregisterDec?: UnregisterDec.AsObject,
        modifyAcl?: ModifyAcl.AsObject,
    }

    export enum AppmanageractionenumCase {
        APPMANAGERACTIONENUM_NOT_SET = 0,
        REGISTER_DEC = 1,
        UNREGISTER_DEC = 2,
        MODIFY_ACL = 3,
    }
}

export class AppStatusDescContent extends jspb.Message {
    getId(): Uint8Array | string;
    getId_asU8(): Uint8Array;
    getId_asB64(): string;
    setId(value: Uint8Array | string): void;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): AppStatusDescContent.AsObject;
    static toObject(includeInstance: boolean, msg: AppStatusDescContent): AppStatusDescContent.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: AppStatusDescContent, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): AppStatusDescContent;
    static deserializeBinaryFromReader(message: AppStatusDescContent, reader: jspb.BinaryReader): AppStatusDescContent;
}

export namespace AppStatusDescContent {
    export type AsObject = {
        id: Uint8Array | string,
    }
}

export class AppStatusContent extends jspb.Message {
    getVersion(): string;
    setVersion(value: string): void;

    getStatus(): number;
    setStatus(value: number): void;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): AppStatusContent.AsObject;
    static toObject(includeInstance: boolean, msg: AppStatusContent): AppStatusContent.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: AppStatusContent, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): AppStatusContent;
    static deserializeBinaryFromReader(message: AppStatusContent, reader: jspb.BinaryReader): AppStatusContent;
}

export namespace AppStatusContent {
    export type AsObject = {
        version: string,
        status: number,
    }
}

export class AppStoreListBodyContent extends jspb.Message {
    clearAppStoreListList(): void;
    getAppStoreListList(): Array<Uint8Array | string>;
    getAppStoreListList_asU8(): Array<Uint8Array>;
    getAppStoreListList_asB64(): Array<string>;
    setAppStoreListList(value: Array<Uint8Array | string>): void;
    addAppStoreList(value: Uint8Array | string, index?: number): Uint8Array | string;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): AppStoreListBodyContent.AsObject;
    static toObject(includeInstance: boolean, msg: AppStoreListBodyContent): AppStoreListBodyContent.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: AppStoreListBodyContent, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): AppStoreListBodyContent;
    static deserializeBinaryFromReader(message: AppStoreListBodyContent, reader: jspb.BinaryReader): AppStoreListBodyContent;
}

export namespace AppStoreListBodyContent {
    export type AsObject = {
        appStoreListList: Array<Uint8Array | string>,
    }
}

export class AppListDescContent extends jspb.Message {
    getId(): string;
    setId(value: string): void;

    getCategory(): string;
    setCategory(value: string): void;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): AppListDescContent.AsObject;
    static toObject(includeInstance: boolean, msg: AppListDescContent): AppListDescContent.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: AppListDescContent, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): AppListDescContent;
    static deserializeBinaryFromReader(message: AppListDescContent, reader: jspb.BinaryReader): AppListDescContent;
}

export namespace AppListDescContent {
    export type AsObject = {
        id: string,
        category: string,
    }
}

export class AppListSourceItem extends jspb.Message {
    getAppId(): Uint8Array | string;
    getAppId_asU8(): Uint8Array;
    getAppId_asB64(): string;
    setAppId(value: Uint8Array | string): void;

    getAppStatus(): Uint8Array | string;
    getAppStatus_asU8(): Uint8Array;
    getAppStatus_asB64(): string;
    setAppStatus(value: Uint8Array | string): void;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): AppListSourceItem.AsObject;
    static toObject(includeInstance: boolean, msg: AppListSourceItem): AppListSourceItem.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: AppListSourceItem, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): AppListSourceItem;
    static deserializeBinaryFromReader(message: AppListSourceItem, reader: jspb.BinaryReader): AppListSourceItem;
}

export namespace AppListSourceItem {
    export type AsObject = {
        appId: Uint8Array | string,
        appStatus: Uint8Array | string,
    }
}

export class AppListContent extends jspb.Message {
    clearSourceList(): void;
    getSourceList(): Array<AppListSourceItem>;
    setSourceList(value: Array<AppListSourceItem>): void;
    addSource(value?: AppListSourceItem, index?: number): AppListSourceItem;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): AppListContent.AsObject;
    static toObject(includeInstance: boolean, msg: AppListContent): AppListContent.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: AppListContent, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): AppListContent;
    static deserializeBinaryFromReader(message: AppListContent, reader: jspb.BinaryReader): AppListContent;
}

export namespace AppListContent {
    export type AsObject = {
        sourceList: Array<AppListSourceItem.AsObject>,
    }
}

export class DecAppDescContent extends jspb.Message {
    getId(): string;
    setId(value: string): void;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): DecAppDescContent.AsObject;
    static toObject(includeInstance: boolean, msg: DecAppDescContent): DecAppDescContent.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: DecAppDescContent, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): DecAppDescContent;
    static deserializeBinaryFromReader(message: DecAppDescContent, reader: jspb.BinaryReader): DecAppDescContent;
}

export namespace DecAppDescContent {
    export type AsObject = {
        id: string,
    }
}

export class StringBytesMapItem extends jspb.Message {
    getKey(): string;
    setKey(value: string): void;

    getValue(): Uint8Array | string;
    getValue_asU8(): Uint8Array;
    getValue_asB64(): string;
    setValue(value: Uint8Array | string): void;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): StringBytesMapItem.AsObject;
    static toObject(includeInstance: boolean, msg: StringBytesMapItem): StringBytesMapItem.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: StringBytesMapItem, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): StringBytesMapItem;
    static deserializeBinaryFromReader(message: StringBytesMapItem, reader: jspb.BinaryReader): StringBytesMapItem;
}

export namespace StringBytesMapItem {
    export type AsObject = {
        key: string,
        value: Uint8Array | string,
    }
}

export class StringStringMapItem extends jspb.Message {
    getKey(): string;
    setKey(value: string): void;

    getValue(): string;
    setValue(value: string): void;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): StringStringMapItem.AsObject;
    static toObject(includeInstance: boolean, msg: StringStringMapItem): StringStringMapItem.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: StringStringMapItem, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): StringStringMapItem;
    static deserializeBinaryFromReader(message: StringStringMapItem, reader: jspb.BinaryReader): StringStringMapItem;
}

export namespace StringStringMapItem {
    export type AsObject = {
        key: string,
        value: string,
    }
}

export class DecAppContent extends jspb.Message {
    clearSourceList(): void;
    getSourceList(): Array<StringBytesMapItem>;
    setSourceList(value: Array<StringBytesMapItem>): void;
    addSource(value?: StringBytesMapItem, index?: number): StringBytesMapItem;

    clearSourceDescList(): void;
    getSourceDescList(): Array<StringStringMapItem>;
    setSourceDescList(value: Array<StringStringMapItem>): void;
    addSourceDesc(value?: StringStringMapItem, index?: number): StringStringMapItem;

    hasIcon(): boolean;
    clearIcon(): void;
    getIcon(): string;
    setIcon(value: string): void;

    hasDesc(): boolean;
    clearDesc(): void;
    getDesc(): string;
    setDesc(value: string): void;

    clearTagsList(): void;
    getTagsList(): Array<StringStringMapItem>;
    setTagsList(value: Array<StringStringMapItem>): void;
    addTags(value?: StringStringMapItem, index?: number): StringStringMapItem;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): DecAppContent.AsObject;
    static toObject(includeInstance: boolean, msg: DecAppContent): DecAppContent.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: DecAppContent, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): DecAppContent;
    static deserializeBinaryFromReader(message: DecAppContent, reader: jspb.BinaryReader): DecAppContent;
}

export namespace DecAppContent {
    export type AsObject = {
        sourceList: Array<StringBytesMapItem.AsObject>,
        sourceDescList: Array<StringStringMapItem.AsObject>,
        icon: string,
        desc: string,
        tagsList: Array<StringStringMapItem.AsObject>,
    }
}

export class FriendItem extends jspb.Message {
    getId(): Uint8Array | string;
    getId_asU8(): Uint8Array;
    getId_asB64(): string;
    setId(value: Uint8Array | string): void;

    getContent(): Uint8Array | string;
    getContent_asU8(): Uint8Array;
    getContent_asB64(): string;
    setContent(value: Uint8Array | string): void;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): FriendItem.AsObject;
    static toObject(includeInstance: boolean, msg: FriendItem): FriendItem.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: FriendItem, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): FriendItem;
    static deserializeBinaryFromReader(message: FriendItem, reader: jspb.BinaryReader): FriendItem;
}

export namespace FriendItem {
    export type AsObject = {
        id: Uint8Array | string,
        content: Uint8Array | string,
    }
}

export class FriendListContent extends jspb.Message {
    clearFriendsList(): void;
    getFriendsList(): Array<FriendItem>;
    setFriendsList(value: Array<FriendItem>): void;
    addFriends(value?: FriendItem, index?: number): FriendItem;

    getAutoConfirm(): number;
    setAutoConfirm(value: number): void;

    getAutoMsg(): string;
    setAutoMsg(value: string): void;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): FriendListContent.AsObject;
    static toObject(includeInstance: boolean, msg: FriendListContent): FriendListContent.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: FriendListContent, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): FriendListContent;
    static deserializeBinaryFromReader(message: FriendListContent, reader: jspb.BinaryReader): FriendListContent;
}

export namespace FriendListContent {
    export type AsObject = {
        friendsList: Array<FriendItem.AsObject>,
        autoConfirm: number,
        autoMsg: string,
    }
}

export class AddFriendDescContent extends jspb.Message {
    getTo(): Uint8Array | string;
    getTo_asU8(): Uint8Array;
    getTo_asB64(): string;
    setTo(value: Uint8Array | string): void;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): AddFriendDescContent.AsObject;
    static toObject(includeInstance: boolean, msg: AddFriendDescContent): AddFriendDescContent.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: AddFriendDescContent, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): AddFriendDescContent;
    static deserializeBinaryFromReader(message: AddFriendDescContent, reader: jspb.BinaryReader): AddFriendDescContent;
}

export namespace AddFriendDescContent {
    export type AsObject = {
        to: Uint8Array | string,
    }
}

export class RemoveFriendDescContent extends jspb.Message {
    getTo(): Uint8Array | string;
    getTo_asU8(): Uint8Array;
    getTo_asB64(): string;
    setTo(value: Uint8Array | string): void;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): RemoveFriendDescContent.AsObject;
    static toObject(includeInstance: boolean, msg: RemoveFriendDescContent): RemoveFriendDescContent.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: RemoveFriendDescContent, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): RemoveFriendDescContent;
    static deserializeBinaryFromReader(message: RemoveFriendDescContent, reader: jspb.BinaryReader): RemoveFriendDescContent;
}

export namespace RemoveFriendDescContent {
    export type AsObject = {
        to: Uint8Array | string,
    }
}

export class FriendOptionContent extends jspb.Message {
    hasAutoConfirm(): boolean;
    clearAutoConfirm(): void;
    getAutoConfirm(): number;
    setAutoConfirm(value: number): void;

    hasMsg(): boolean;
    clearMsg(): void;
    getMsg(): string;
    setMsg(value: string): void;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): FriendOptionContent.AsObject;
    static toObject(includeInstance: boolean, msg: FriendOptionContent): FriendOptionContent.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: FriendOptionContent, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): FriendOptionContent;
    static deserializeBinaryFromReader(message: FriendOptionContent, reader: jspb.BinaryReader): FriendOptionContent;
}

export namespace FriendOptionContent {
    export type AsObject = {
        autoConfirm: number,
        msg: string,
    }
}

export class MsgObjectContent extends jspb.Message {
    getId(): Uint8Array | string;
    getId_asU8(): Uint8Array;
    getId_asB64(): string;
    setId(value: Uint8Array | string): void;

    getName(): string;
    setName(value: string): void;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): MsgObjectContent.AsObject;
    static toObject(includeInstance: boolean, msg: MsgObjectContent): MsgObjectContent.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: MsgObjectContent, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): MsgObjectContent;
    static deserializeBinaryFromReader(message: MsgObjectContent, reader: jspb.BinaryReader): MsgObjectContent;
}

export namespace MsgObjectContent {
    export type AsObject = {
        id: Uint8Array | string,
        name: string,
    }
}

export class MsgContent extends jspb.Message {
    getType(): MsgContent.TypeMap[keyof MsgContent.TypeMap];
    setType(value: MsgContent.TypeMap[keyof MsgContent.TypeMap]): void;

    hasText(): boolean;
    clearText(): void;
    getText(): string;
    setText(value: string): void;

    hasContent(): boolean;
    clearContent(): void;
    getContent(): MsgObjectContent | undefined;
    setContent(value?: MsgObjectContent): void;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): MsgContent.AsObject;
    static toObject(includeInstance: boolean, msg: MsgContent): MsgContent.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: MsgContent, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): MsgContent;
    static deserializeBinaryFromReader(message: MsgContent, reader: jspb.BinaryReader): MsgContent;
}

export namespace MsgContent {
    export type AsObject = {
        type: MsgContent.TypeMap[keyof MsgContent.TypeMap],
        text: string,
        content?: MsgObjectContent.AsObject,
    }

    export interface TypeMap {
        TEXT: 0;
        OBJECT: 1;
    }

    export const Type: TypeMap;
}

export class MsgDescContent extends jspb.Message {
    getTo(): Uint8Array | string;
    getTo_asU8(): Uint8Array;
    getTo_asB64(): string;
    setTo(value: Uint8Array | string): void;

    hasContent(): boolean;
    clearContent(): void;
    getContent(): MsgContent | undefined;
    setContent(value?: MsgContent): void;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): MsgDescContent.AsObject;
    static toObject(includeInstance: boolean, msg: MsgDescContent): MsgDescContent.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: MsgDescContent, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): MsgDescContent;
    static deserializeBinaryFromReader(message: MsgDescContent, reader: jspb.BinaryReader): MsgDescContent;
}

export namespace MsgDescContent {
    export type AsObject = {
        to: Uint8Array | string,
        content?: MsgContent.AsObject,
    }
}

export class MsgInfo extends jspb.Message {
    getOrderd(): number;
    setOrderd(value: number): void;

    getSeq(): number;
    setSeq(value: number): void;

    getMsgObjId(): Uint8Array | string;
    getMsgObjId_asU8(): Uint8Array;
    getMsgObjId_asB64(): string;
    setMsgObjId(value: Uint8Array | string): void;

    getMemberId(): Uint8Array | string;
    getMemberId_asU8(): Uint8Array;
    getMemberId_asB64(): string;
    setMemberId(value: Uint8Array | string): void;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): MsgInfo.AsObject;
    static toObject(includeInstance: boolean, msg: MsgInfo): MsgInfo.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: MsgInfo, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): MsgInfo;
    static deserializeBinaryFromReader(message: MsgInfo, reader: jspb.BinaryReader): MsgInfo;
}

export namespace MsgInfo {
    export type AsObject = {
        orderd: number,
        seq: number,
        msgObjId: Uint8Array | string,
        memberId: Uint8Array | string,
    }
}

export class TopicMessageListDescContent extends jspb.Message {
    getTopicId(): Uint8Array | string;
    getTopicId_asU8(): Uint8Array;
    getTopicId_asB64(): string;
    setTopicId(value: Uint8Array | string): void;

    getSlot(): number;
    setSlot(value: number): void;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): TopicMessageListDescContent.AsObject;
    static toObject(includeInstance: boolean, msg: TopicMessageListDescContent): TopicMessageListDescContent.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: TopicMessageListDescContent, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): TopicMessageListDescContent;
    static deserializeBinaryFromReader(message: TopicMessageListDescContent, reader: jspb.BinaryReader): TopicMessageListDescContent;
}

export namespace TopicMessageListDescContent {
    export type AsObject = {
        topicId: Uint8Array | string,
        slot: number,
    }
}

export class TopicMessageListBodyContent extends jspb.Message {
    getStart(): number;
    setStart(value: number): void;

    clearMsgListList(): void;
    getMsgListList(): Array<MsgInfo>;
    setMsgListList(value: Array<MsgInfo>): void;
    addMsgList(value?: MsgInfo, index?: number): MsgInfo;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): TopicMessageListBodyContent.AsObject;
    static toObject(includeInstance: boolean, msg: TopicMessageListBodyContent): TopicMessageListBodyContent.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: TopicMessageListBodyContent, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): TopicMessageListBodyContent;
    static deserializeBinaryFromReader(message: TopicMessageListBodyContent, reader: jspb.BinaryReader): TopicMessageListBodyContent;
}

export namespace TopicMessageListBodyContent {
    export type AsObject = {
        start: number,
        msgListList: Array<MsgInfo.AsObject>,
    }
}

export class TopicPublishReqDescContent extends jspb.Message {
    getTopicId(): Uint8Array | string;
    getTopicId_asU8(): Uint8Array;
    getTopicId_asB64(): string;
    setTopicId(value: Uint8Array | string): void;

    getTopicOwnerId(): Uint8Array | string;
    getTopicOwnerId_asU8(): Uint8Array;
    getTopicOwnerId_asB64(): string;
    setTopicOwnerId(value: Uint8Array | string): void;

    getMemberId(): Uint8Array | string;
    getMemberId_asU8(): Uint8Array;
    getMemberId_asB64(): string;
    setMemberId(value: Uint8Array | string): void;

    getSeq(): number;
    setSeq(value: number): void;

    getCount(): number;
    setCount(value: number): void;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): TopicPublishReqDescContent.AsObject;
    static toObject(includeInstance: boolean, msg: TopicPublishReqDescContent): TopicPublishReqDescContent.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: TopicPublishReqDescContent, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): TopicPublishReqDescContent;
    static deserializeBinaryFromReader(message: TopicPublishReqDescContent, reader: jspb.BinaryReader): TopicPublishReqDescContent;
}

export namespace TopicPublishReqDescContent {
    export type AsObject = {
        topicId: Uint8Array | string,
        topicOwnerId: Uint8Array | string,
        memberId: Uint8Array | string,
        seq: number,
        count: number,
    }
}

export class TopicPublishRespDescContent extends jspb.Message {
    getTopicId(): Uint8Array | string;
    getTopicId_asU8(): Uint8Array;
    getTopicId_asB64(): string;
    setTopicId(value: Uint8Array | string): void;

    getTopicOwnerId(): Uint8Array | string;
    getTopicOwnerId_asU8(): Uint8Array;
    getTopicOwnerId_asB64(): string;
    setTopicOwnerId(value: Uint8Array | string): void;

    getMemberId(): Uint8Array | string;
    getMemberId_asU8(): Uint8Array;
    getMemberId_asB64(): string;
    setMemberId(value: Uint8Array | string): void;

    getSeq(): number;
    setSeq(value: number): void;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): TopicPublishRespDescContent.AsObject;
    static toObject(includeInstance: boolean, msg: TopicPublishRespDescContent): TopicPublishRespDescContent.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: TopicPublishRespDescContent, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): TopicPublishRespDescContent;
    static deserializeBinaryFromReader(message: TopicPublishRespDescContent, reader: jspb.BinaryReader): TopicPublishRespDescContent;
}

export namespace TopicPublishRespDescContent {
    export type AsObject = {
        topicId: Uint8Array | string,
        topicOwnerId: Uint8Array | string,
        memberId: Uint8Array | string,
        seq: number,
    }
}

export class TopicPublishStatusDescContent extends jspb.Message {
    getTopicId(): Uint8Array | string;
    getTopicId_asU8(): Uint8Array;
    getTopicId_asB64(): string;
    setTopicId(value: Uint8Array | string): void;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): TopicPublishStatusDescContent.AsObject;
    static toObject(includeInstance: boolean, msg: TopicPublishStatusDescContent): TopicPublishStatusDescContent.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: TopicPublishStatusDescContent, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): TopicPublishStatusDescContent;
    static deserializeBinaryFromReader(message: TopicPublishStatusDescContent, reader: jspb.BinaryReader): TopicPublishStatusDescContent;
}

export namespace TopicPublishStatusDescContent {
    export type AsObject = {
        topicId: Uint8Array | string,
    }
}

export class SeqInfo extends jspb.Message {
    getId(): Uint8Array | string;
    getId_asU8(): Uint8Array;
    getId_asB64(): string;
    setId(value: Uint8Array | string): void;

    getOffset(): number;
    setOffset(value: number): void;

    getStartSeq(): number;
    setStartSeq(value: number): void;

    clearReceivedSeqsList(): void;
    getReceivedSeqsList(): Array<number>;
    setReceivedSeqsList(value: Array<number>): void;
    addReceivedSeqs(value: number, index?: number): number;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): SeqInfo.AsObject;
    static toObject(includeInstance: boolean, msg: SeqInfo): SeqInfo.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: SeqInfo, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): SeqInfo;
    static deserializeBinaryFromReader(message: SeqInfo, reader: jspb.BinaryReader): SeqInfo;
}

export namespace SeqInfo {
    export type AsObject = {
        id: Uint8Array | string,
        offset: number,
        startSeq: number,
        receivedSeqsList: Array<number>,
    }
}

export class TopicPublishStatusBodyContent extends jspb.Message {
    getTopicId(): Uint8Array | string;
    getTopicId_asU8(): Uint8Array;
    getTopicId_asB64(): string;
    setTopicId(value: Uint8Array | string): void;

    clearDeviceListList(): void;
    getDeviceListList(): Array<Uint8Array | string>;
    getDeviceListList_asU8(): Array<Uint8Array>;
    getDeviceListList_asB64(): Array<string>;
    setDeviceListList(value: Array<Uint8Array | string>): void;
    addDeviceList(value: Uint8Array | string, index?: number): Uint8Array | string;

    getMsgList(): Uint8Array | string;
    getMsgList_asU8(): Uint8Array;
    getMsgList_asB64(): string;
    setMsgList(value: Uint8Array | string): void;

    getMsgLength(): number;
    setMsgLength(value: number): void;

    clearSeqMapList(): void;
    getSeqMapList(): Array<SeqInfo>;
    setSeqMapList(value: Array<SeqInfo>): void;
    addSeqMap(value?: SeqInfo, index?: number): SeqInfo;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): TopicPublishStatusBodyContent.AsObject;
    static toObject(includeInstance: boolean, msg: TopicPublishStatusBodyContent): TopicPublishStatusBodyContent.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: TopicPublishStatusBodyContent, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): TopicPublishStatusBodyContent;
    static deserializeBinaryFromReader(message: TopicPublishStatusBodyContent, reader: jspb.BinaryReader): TopicPublishStatusBodyContent;
}

export namespace TopicPublishStatusBodyContent {
    export type AsObject = {
        topicId: Uint8Array | string,
        deviceListList: Array<Uint8Array | string>,
        msgList: Uint8Array | string,
        msgLength: number,
        seqMapList: Array<SeqInfo.AsObject>,
    }
}

export class TopicPublishDescContent extends jspb.Message {
    getTopicId(): Uint8Array | string;
    getTopicId_asU8(): Uint8Array;
    getTopicId_asB64(): string;
    setTopicId(value: Uint8Array | string): void;

    getTopicOwnerId(): Uint8Array | string;
    getTopicOwnerId_asU8(): Uint8Array;
    getTopicOwnerId_asB64(): string;
    setTopicOwnerId(value: Uint8Array | string): void;

    hasMsgInfo(): boolean;
    clearMsgInfo(): void;
    getMsgInfo(): MsgInfo | undefined;
    setMsgInfo(value?: MsgInfo): void;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): TopicPublishDescContent.AsObject;
    static toObject(includeInstance: boolean, msg: TopicPublishDescContent): TopicPublishDescContent.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: TopicPublishDescContent, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): TopicPublishDescContent;
    static deserializeBinaryFromReader(message: TopicPublishDescContent, reader: jspb.BinaryReader): TopicPublishDescContent;
}

export namespace TopicPublishDescContent {
    export type AsObject = {
        topicId: Uint8Array | string,
        topicOwnerId: Uint8Array | string,
        msgInfo?: MsgInfo.AsObject,
    }
}

export class TopicSubscribeSuccessDescContent extends jspb.Message {
    getTopicId(): Uint8Array | string;
    getTopicId_asU8(): Uint8Array;
    getTopicId_asB64(): string;
    setTopicId(value: Uint8Array | string): void;

    getTopicOwnerId(): Uint8Array | string;
    getTopicOwnerId_asU8(): Uint8Array;
    getTopicOwnerId_asB64(): string;
    setTopicOwnerId(value: Uint8Array | string): void;

    getMemberId(): Uint8Array | string;
    getMemberId_asU8(): Uint8Array;
    getMemberId_asB64(): string;
    setMemberId(value: Uint8Array | string): void;

    getMsgSeq(): number;
    setMsgSeq(value: number): void;

    hasMsgObjId(): boolean;
    clearMsgObjId(): void;
    getMsgObjId(): Uint8Array | string;
    getMsgObjId_asU8(): Uint8Array;
    getMsgObjId_asB64(): string;
    setMsgObjId(value: Uint8Array | string): void;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): TopicSubscribeSuccessDescContent.AsObject;
    static toObject(includeInstance: boolean, msg: TopicSubscribeSuccessDescContent): TopicSubscribeSuccessDescContent.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: TopicSubscribeSuccessDescContent, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): TopicSubscribeSuccessDescContent;
    static deserializeBinaryFromReader(message: TopicSubscribeSuccessDescContent, reader: jspb.BinaryReader): TopicSubscribeSuccessDescContent;
}

export namespace TopicSubscribeSuccessDescContent {
    export type AsObject = {
        topicId: Uint8Array | string,
        topicOwnerId: Uint8Array | string,
        memberId: Uint8Array | string,
        msgSeq: number,
        msgObjId: Uint8Array | string,
    }
}

export class TopicSubscribeDescContent extends jspb.Message {
    getTopicId(): Uint8Array | string;
    getTopicId_asU8(): Uint8Array;
    getTopicId_asB64(): string;
    setTopicId(value: Uint8Array | string): void;

    getTopicOwnerId(): Uint8Array | string;
    getTopicOwnerId_asU8(): Uint8Array;
    getTopicOwnerId_asB64(): string;
    setTopicOwnerId(value: Uint8Array | string): void;

    getMemberId(): Uint8Array | string;
    getMemberId_asU8(): Uint8Array;
    getMemberId_asB64(): string;
    setMemberId(value: Uint8Array | string): void;

    getMsgOffset(): number;
    setMsgOffset(value: number): void;

    hasMsgObjId(): boolean;
    clearMsgObjId(): void;
    getMsgObjId(): Uint8Array | string;
    getMsgObjId_asU8(): Uint8Array;
    getMsgObjId_asB64(): string;
    setMsgObjId(value: Uint8Array | string): void;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): TopicSubscribeDescContent.AsObject;
    static toObject(includeInstance: boolean, msg: TopicSubscribeDescContent): TopicSubscribeDescContent.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: TopicSubscribeDescContent, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): TopicSubscribeDescContent;
    static deserializeBinaryFromReader(message: TopicSubscribeDescContent, reader: jspb.BinaryReader): TopicSubscribeDescContent;
}

export namespace TopicSubscribeDescContent {
    export type AsObject = {
        topicId: Uint8Array | string,
        topicOwnerId: Uint8Array | string,
        memberId: Uint8Array | string,
        msgOffset: number,
        msgObjId: Uint8Array | string,
    }
}

export class TopicUnsubscribeSuccessDescContent extends jspb.Message {
    getTopicId(): Uint8Array | string;
    getTopicId_asU8(): Uint8Array;
    getTopicId_asB64(): string;
    setTopicId(value: Uint8Array | string): void;

    getTopicOwnerId(): Uint8Array | string;
    getTopicOwnerId_asU8(): Uint8Array;
    getTopicOwnerId_asB64(): string;
    setTopicOwnerId(value: Uint8Array | string): void;

    getMemberId(): Uint8Array | string;
    getMemberId_asU8(): Uint8Array;
    getMemberId_asB64(): string;
    setMemberId(value: Uint8Array | string): void;

    hasMsgObjId(): boolean;
    clearMsgObjId(): void;
    getMsgObjId(): Uint8Array | string;
    getMsgObjId_asU8(): Uint8Array;
    getMsgObjId_asB64(): string;
    setMsgObjId(value: Uint8Array | string): void;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): TopicUnsubscribeSuccessDescContent.AsObject;
    static toObject(includeInstance: boolean, msg: TopicUnsubscribeSuccessDescContent): TopicUnsubscribeSuccessDescContent.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: TopicUnsubscribeSuccessDescContent, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): TopicUnsubscribeSuccessDescContent;
    static deserializeBinaryFromReader(message: TopicUnsubscribeSuccessDescContent, reader: jspb.BinaryReader): TopicUnsubscribeSuccessDescContent;
}

export namespace TopicUnsubscribeSuccessDescContent {
    export type AsObject = {
        topicId: Uint8Array | string,
        topicOwnerId: Uint8Array | string,
        memberId: Uint8Array | string,
        msgObjId: Uint8Array | string,
    }
}

export class TopicUnsubscribeDescContent extends jspb.Message {
    getTopicId(): Uint8Array | string;
    getTopicId_asU8(): Uint8Array;
    getTopicId_asB64(): string;
    setTopicId(value: Uint8Array | string): void;

    getTopicOwnerId(): Uint8Array | string;
    getTopicOwnerId_asU8(): Uint8Array;
    getTopicOwnerId_asB64(): string;
    setTopicOwnerId(value: Uint8Array | string): void;

    getMemberId(): Uint8Array | string;
    getMemberId_asU8(): Uint8Array;
    getMemberId_asB64(): string;
    setMemberId(value: Uint8Array | string): void;

    hasMsgObjId(): boolean;
    clearMsgObjId(): void;
    getMsgObjId(): Uint8Array | string;
    getMsgObjId_asU8(): Uint8Array;
    getMsgObjId_asB64(): string;
    setMsgObjId(value: Uint8Array | string): void;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): TopicUnsubscribeDescContent.AsObject;
    static toObject(includeInstance: boolean, msg: TopicUnsubscribeDescContent): TopicUnsubscribeDescContent.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: TopicUnsubscribeDescContent, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): TopicUnsubscribeDescContent;
    static deserializeBinaryFromReader(message: TopicUnsubscribeDescContent, reader: jspb.BinaryReader): TopicUnsubscribeDescContent;
}

export namespace TopicUnsubscribeDescContent {
    export type AsObject = {
        topicId: Uint8Array | string,
        topicOwnerId: Uint8Array | string,
        memberId: Uint8Array | string,
        msgObjId: Uint8Array | string,
    }
}

export class TopicDescContent extends jspb.Message {
    getUniqueId(): Uint8Array | string;
    getUniqueId_asU8(): Uint8Array;
    getUniqueId_asB64(): string;
    setUniqueId(value: Uint8Array | string): void;

    hasUserDataId(): boolean;
    clearUserDataId(): void;
    getUserDataId(): Uint8Array | string;
    getUserDataId_asU8(): Uint8Array;
    getUserDataId_asB64(): string;
    setUserDataId(value: Uint8Array | string): void;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): TopicDescContent.AsObject;
    static toObject(includeInstance: boolean, msg: TopicDescContent): TopicDescContent.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: TopicDescContent, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): TopicDescContent;
    static deserializeBinaryFromReader(message: TopicDescContent, reader: jspb.BinaryReader): TopicDescContent;
}

export namespace TopicDescContent {
    export type AsObject = {
        uniqueId: Uint8Array | string,
        userDataId: Uint8Array | string,
    }
}

export class TopicBodyContent extends jspb.Message {
    hasTopicPublishStatusId(): boolean;
    clearTopicPublishStatusId(): void;
    getTopicPublishStatusId(): Uint8Array | string;
    getTopicPublishStatusId_asU8(): Uint8Array;
    getTopicPublishStatusId_asB64(): string;
    setTopicPublishStatusId(value: Uint8Array | string): void;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): TopicBodyContent.AsObject;
    static toObject(includeInstance: boolean, msg: TopicBodyContent): TopicBodyContent.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: TopicBodyContent, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): TopicBodyContent;
    static deserializeBinaryFromReader(message: TopicBodyContent, reader: jspb.BinaryReader): TopicBodyContent;
}

export namespace TopicBodyContent {
    export type AsObject = {
        topicPublishStatusId: Uint8Array | string,
    }
}

export class TransContextDescContent extends jspb.Message {
    getDecId(): Uint8Array | string;
    getDecId_asU8(): Uint8Array;
    getDecId_asB64(): string;
    setDecId(value: Uint8Array | string): void;

    getContextName(): string;
    setContextName(value: string): void;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): TransContextDescContent.AsObject;
    static toObject(includeInstance: boolean, msg: TransContextDescContent): TransContextDescContent.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: TransContextDescContent, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): TransContextDescContent;
    static deserializeBinaryFromReader(message: TransContextDescContent, reader: jspb.BinaryReader): TransContextDescContent;
}

export namespace TransContextDescContent {
    export type AsObject = {
        decId: Uint8Array | string,
        contextName: string,
    }
}

export class TransContextBodyContent extends jspb.Message {
    hasRefId(): boolean;
    clearRefId(): void;
    getRefId(): Uint8Array | string;
    getRefId_asU8(): Uint8Array;
    getRefId_asB64(): string;
    setRefId(value: Uint8Array | string): void;

    clearDeviceListList(): void;
    getDeviceListList(): Array<Uint8Array | string>;
    getDeviceListList_asU8(): Array<Uint8Array>;
    getDeviceListList_asB64(): Array<string>;
    setDeviceListList(value: Array<Uint8Array | string>): void;
    addDeviceList(value: Uint8Array | string, index?: number): Uint8Array | string;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): TransContextBodyContent.AsObject;
    static toObject(includeInstance: boolean, msg: TransContextBodyContent): TransContextBodyContent.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: TransContextBodyContent, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): TransContextBodyContent;
    static deserializeBinaryFromReader(message: TransContextBodyContent, reader: jspb.BinaryReader): TransContextBodyContent;
}

export namespace TransContextBodyContent {
    export type AsObject = {
        refId: Uint8Array | string,
        deviceListList: Array<Uint8Array | string>,
    }
}

export class NFTFileDesc extends jspb.Message {
    getDesc(): Uint8Array | string;
    getDesc_asU8(): Uint8Array;
    getDesc_asB64(): string;
    setDesc(value: Uint8Array | string): void;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): NFTFileDesc.AsObject;
    static toObject(includeInstance: boolean, msg: NFTFileDesc): NFTFileDesc.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: NFTFileDesc, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): NFTFileDesc;
    static deserializeBinaryFromReader(message: NFTFileDesc, reader: jspb.BinaryReader): NFTFileDesc;
}

export namespace NFTFileDesc {
    export type AsObject = {
        desc: Uint8Array | string,
    }
}

export class NFTListDescContent extends jspb.Message {
    clearNftListList(): void;
    getNftListList(): Array<NFTFileDesc>;
    setNftListList(value: Array<NFTFileDesc>): void;
    addNftList(value?: NFTFileDesc, index?: number): NFTFileDesc;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): NFTListDescContent.AsObject;
    static toObject(includeInstance: boolean, msg: NFTListDescContent): NFTListDescContent.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: NFTListDescContent, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): NFTListDescContent;
    static deserializeBinaryFromReader(message: NFTListDescContent, reader: jspb.BinaryReader): NFTListDescContent;
}

export namespace NFTListDescContent {
    export type AsObject = {
        nftListList: Array<NFTFileDesc.AsObject>,
    }
}

