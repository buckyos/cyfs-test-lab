// Generated by dts-bundle v0.7.3
// Dependencies for this module:
//   ../../jsbi
//   ../../@ethersproject/bignumber
//   ../../@ethersproject/bytes
//   ../../@ethersproject/properties
//   ../../node-fetch
//   ../../ts-results
//   ../../node-rsa
//   ../../long
//   ../../protobufjs

import JSBI from 'jsbi';
import JSBI from "jsbi";
import { BigNumber } from "@ethersproject/bignumber";
import { BytesLike } from "@ethersproject/bytes";
import { BigNumber, BigNumberish } from "@ethersproject/bignumber";
import { Description } from "@ethersproject/properties";
import { Response } from 'node-fetch';
import { Result } from "ts-results";
import { Result } from 'ts-results';
export { Ok, Err, Result } from 'ts-results';
import NodeRSA from 'node-rsa';
import Long from 'long';
import { Writer } from 'protobufjs';
import * as $protobuf from "protobufjs";

export { ConstructorFragment, ErrorFragment, EventFragment, Fragment, FunctionFragment, ParamType, FormatTypes, AbiCoder, defaultAbiCoder, Interface, Indexed, CoerceFunc, JsonFragment, JsonFragmentType, EthAbiResult, checkResultErrors, LogDescription, TransactionDescription };
export function encode_input(abi: string, name_or_signature: string, values: string[]): Uint8Array;
export function encode_constructor(abi: string, code: Uint8Array, values: string[]): Uint8Array;
export function decode_call_output(abi: string, name_or_signature: string, data: Uint8Array): EthAbiResult;
export function decode_log(abi: string, name_or_signature: string, topics: Uint8Array[], data: Uint8Array): EthAbiResult;
export function encode_topic(abi: string, name_or_signature: string, params: (string | null)[]): (Uint8Array | null)[];

export function ensureDirSync(dir: string): void;

export const DataViewJSBIHelper: typeof DataViewJSBIHelperNoBigInt;

export interface LogFileOptions {
    name: string;
    dir?: string;
    file_max_size?: number;
    file_max_count?: number;
}
export const clog: any;

export enum CyfsChannel {
    Nightly = "nightly",
    Beta = "beta",
    Stable = "stable"
}
export function get_channel(): CyfsChannel;

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class BlockDescTypeInfo extends DescTypeInfo {
    obj_type(): number;
    sub_desc_type(): SubDescType;
}
export class BlockDescContent extends DescContent {
    number: JSBI;
    coinbase: ObjectId;
    state_hash: HashValue;
    pre_block_hash: ObjectId;
    transactions_hash: HashValue;
    receipts_hash: HashValue;
    constructor(number: JSBI, coinbase: ObjectId, state_hash: HashValue, pre_block_hash: ObjectId, transactions_hash: HashValue, receipts_hash: HashValue);
    type_info(): DescTypeInfo;
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
}
export class BlockDescContentDecoder extends DescContentDecoder<BlockDescContent> {
    type_info(): DescTypeInfo;
    raw_decode(buf: Uint8Array): BuckyResult<[BlockDescContent, Uint8Array]>;
}
export class BlockBodyContent extends BodyContent {
    transactions: MetaTx[];
    receipts: Receipt[];
    constructor(transactions: MetaTx[], receipts: Receipt[]);
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
}
export class BlockBodyContentDecoder extends BodyContentDecoder<BlockBodyContent> {
    raw_decode(buf: Uint8Array): BuckyResult<[BlockBodyContent, Uint8Array]>;
}
export class BlockDesc extends NamedObjectDesc<BlockDescContent> {
}
export class BlockDescDecoder extends NamedObjectDescDecoder<BlockDescContent> {
    constructor();
}
export class BlockBuilder extends NamedObjectBuilder<BlockDescContent, BlockBodyContent> {
}
export class BlockId extends NamedObjectId<BlockDescContent, BlockBodyContent> {
    constructor(id: ObjectId);
    static default(): BlockId;
    static from_base_58(s: string): BuckyResult<BlockId>;
    static try_from_object_id(id: ObjectId): BuckyResult<BlockId>;
}
export class BlockIdDecoder extends NamedObjectIdDecoder<BlockDescContent, BlockBodyContent> {
    constructor();
}
export class Block extends NamedObject<BlockDescContent, BlockBodyContent> {
    static create(number: JSBI, coinbase: ObjectId, state_hash: HashValue, pre_block_hash: ObjectId, transactions_hash: HashValue, receipts_hash: HashValue, transactions: MetaTx[], receipts: Receipt[]): Block;
    ext(): BlockExt;
}
export class BlockDecoder extends NamedObjectDecoder<BlockDescContent, BlockBodyContent, Block> {
    constructor();
}

export class BlockExt {
    obj: Block;
    constructor(obj: Block);
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class GenesisCoinConfig implements RawEncode {
    coin_id: number;
    pre_balance: PreBalance[];
    constructor(coin_id: number, pre_balance: PreBalance[]);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class GenesisCoinConfigDecoder implements RawDecode<GenesisCoinConfig> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[GenesisCoinConfig, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class GenesisConfig implements RawEncode {
    chain_type: Option<string>;
    coinbase: ObjectId;
    interval: number;
    bfc_spv_node: string;
    coins: GenesisCoinConfig[];
    price: GenesisPriceConfig;
    miner_key_path: Option<string>;
    mg_path: Option<string>;
    miner_desc_path: Option<string>;
    sub_chain_tx: Option<string>;
    constructor(chain_type: Option<string>, coinbase: ObjectId, interval: number, bfc_spv_node: string, coins: GenesisCoinConfig[], price: GenesisPriceConfig, miner_key_path: Option<string>, mg_path: Option<string>, miner_desc_path: Option<string>, sub_chain_tx: Option<string>);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class GenesisConfigDecoder implements RawDecode<GenesisConfig> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[GenesisConfig, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class GenesisPriceConfig implements RawEncode {
    constructor();
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class GenesisPriceConfigDecoder implements RawDecode<GenesisPriceConfig> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[GenesisPriceConfig, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class PreBalance implements RawEncode {
    id: ObjectId;
    balance: JSBI;
    constructor(id: ObjectId, balance: JSBI);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class PreBalanceDecoder implements RawDecode<PreBalance> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[PreBalance, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class BidName implements RawEncode {
    name: string;
    price: JSBI;
    bid_id: ObjectId;
    coin_id: number;
    take_effect_block: JSBI;
    rent_price: JSBI;
    constructor(name: string, price: JSBI, bid_id: ObjectId, coin_id: number, take_effect_block: JSBI, rent_price: JSBI);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class BidNameDecoder implements RawDecode<BidName> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[BidName, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class ChangeNameParam implements RawEncode {
    name: string;
    to: NameState;
    constructor(name: string, to: NameState);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class ChangeNameParamDecoder implements RawDecode<ChangeNameParam> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[ChangeNameParam, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class Event implements RawEncode {
    static Rent(rent: RentParam): Event;
    static NameRent(namerent: NameRentParam): Event;
    static ChangeNameEvent(changenameevent: ChangeNameParam): Event;
    static BidName(bidname: BidName): Event;
    static StopAuction(stopauction: StopAuctionParam): Event;
    static UnionWithdraw(unionwithdraw: UnionWithdraw): Event;
    static Extension(extension: ExtensionEvent): Event;
    match<T>(visitor: {
        Rent?: (rent: RentParam) => T;
        NameRent?: (namerent: NameRentParam) => T;
        ChangeNameEvent?: (changenameevent: ChangeNameParam) => T;
        BidName?: (bidname: BidName) => T;
        StopAuction?: (stopauction: StopAuctionParam) => T;
        UnionWithdraw?: (unionwithdraw: UnionWithdraw) => T;
        Extension?: (extension: ExtensionEvent) => T;
    }): T | undefined;
    eq_type(rhs: Event): boolean;
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class EventDecoder implements RawDecode<Event> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[Event, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export enum EventType {
    Rent = 0,
    ChangeName = 1,
    NameRent = 2,
    BidName = 3,
    StopAuction = 4,
    UnionWithdraw = 5,
    Extension = 6
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class ExtensionEvent implements RawEncode {
    extension_type: MetaExtensionType;
    data: Uint8Array;
    constructor(extension_type: MetaExtensionType, data: Uint8Array);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class ExtensionEventDecoder implements RawDecode<ExtensionEvent> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[ExtensionEvent, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class NameRentParam implements RawEncode {
    name_id: string;
    constructor(name_id: string);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class NameRentParamDecoder implements RawDecode<NameRentParam> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[NameRentParam, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class RentParam implements RawEncode {
    id: ObjectId;
    constructor(id: ObjectId);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class RentParamDecoder implements RawDecode<RentParam> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[RentParam, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class StopAuctionParam implements RawEncode {
    name: string;
    stop_block: JSBI;
    starting_price: JSBI;
    constructor(name: string, stop_block: JSBI, starting_price: JSBI);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class StopAuctionParamDecoder implements RawDecode<StopAuctionParam> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[StopAuctionParam, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class UnionWithdraw implements RawEncode {
    union_id: ObjectId;
    account_id: ObjectId;
    ctid: CoinTokenId;
    value: JSBI;
    height: JSBI;
    constructor(union_id: ObjectId, account_id: ObjectId, ctid: CoinTokenId, value: JSBI, height: JSBI);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class UnionWithdrawDecoder implements RawDecode<UnionWithdraw> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[UnionWithdraw, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class MetaExtensionTx implements RawEncode {
    extension_id: MetaExtensionType;
    tx_data: Uint8Array;
    constructor(extension_id: MetaExtensionType, tx_data: Uint8Array);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class MetaExtensionTxDecoder implements RawDecode<MetaExtensionTx> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[MetaExtensionTx, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class MetaExtensionType implements RawEncode {
    static DSG(): MetaExtensionType;
    match<T>(visitor: {
        DSG?: () => T;
    }): T | undefined;
    eq_type(rhs: MetaExtensionType): boolean;
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class MetaExtensionTypeDecoder implements RawDecode<MetaExtensionType> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[MetaExtensionType, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class ServiceAuthType implements RawEncode {
    static Any(): ServiceAuthType;
    static WhiteList(): ServiceAuthType;
    static BlackList(): ServiceAuthType;
    match<T>(visitor: {
        Any?: () => T;
        WhiteList?: () => T;
        BlackList?: () => T;
    }): T | undefined;
    eq_type(rhs: ServiceAuthType): boolean;
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class ServiceAuthTypeDecoder implements RawDecode<ServiceAuthType> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[ServiceAuthType, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class SNContractBodyContent implements RawEncode {
    auth_type: ServiceAuthType;
    list: ObjectId[];
    constructor(auth_type: ServiceAuthType, list: ObjectId[]);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class SNContractBodyContentDecoder implements RawDecode<SNContractBodyContent> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[SNContractBodyContent, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class SNPurchase implements RawEncode {
    service_id: ObjectId;
    start_time: JSBI;
    stop_time: JSBI;
    auth_type: ServiceAuthType;
    auth_list: ObjectId[];
    constructor(service_id: ObjectId, start_time: JSBI, stop_time: JSBI, auth_type: ServiceAuthType, auth_list: ObjectId[]);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class SNPurchaseDecoder implements RawDecode<SNPurchase> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[SNPurchase, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class SNServiceDescTypeInfo extends DescTypeInfo {
    obj_type(): number;
    sub_desc_type(): SubDescType;
}
export class SNServiceDescContent extends DescContent {
    service_type: number;
    price: JSBI;
    constructor(service_type: number, price: JSBI);
    type_info(): DescTypeInfo;
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
}
export class SNServiceDescContentDecoder extends DescContentDecoder<SNServiceDescContent> {
    type_info(): DescTypeInfo;
    raw_decode(buf: Uint8Array): BuckyResult<[SNServiceDescContent, Uint8Array]>;
}
export class SNServiceBodyContent extends BodyContent {
    constructor();
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
}
export class SNServiceBodyContentDecoder extends BodyContentDecoder<SNServiceBodyContent> {
    raw_decode(buf: Uint8Array): BuckyResult<[SNServiceBodyContent, Uint8Array]>;
}
export class SNServiceDesc extends NamedObjectDesc<SNServiceDescContent> {
}
export class SNServiceDescDecoder extends NamedObjectDescDecoder<SNServiceDescContent> {
    constructor();
}
export class SNServiceBuilder extends NamedObjectBuilder<SNServiceDescContent, SNServiceBodyContent> {
}
export class SNServiceId extends NamedObjectId<SNServiceDescContent, SNServiceBodyContent> {
    constructor(id: ObjectId);
    static default(): SNServiceId;
    static from_base_58(s: string): BuckyResult<SNServiceId>;
    static try_from_object_id(id: ObjectId): BuckyResult<SNServiceId>;
}
export class SNServiceIdDecoder extends NamedObjectIdDecoder<SNServiceDescContent, SNServiceBodyContent> {
    constructor();
}
export class SNService extends NamedObject<SNServiceDescContent, SNServiceBodyContent> {
    static create(owner: ObjectId, service_type: number, price: JSBI): SNService;
}
export class SNServiceDecoder extends NamedObjectDecoder<SNServiceDescContent, SNServiceBodyContent, SNService> {
    constructor();
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class BlockInfo {
    height: JSBI;
    block_hash: string;
    create_time: JSBI;
    tx_list: TxInfo[];
    constructor(height: JSBI, block_hash: string, create_time: JSBI, tx_list: TxInfo[]);
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class BlockSection {
    start: JSBI;
    end: JSBI;
    constructor(start: JSBI, end: JSBI);
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class GetBlocksRequest {
    start_block: JSBI;
    end_block: JSBI;
    constructor(start_block: JSBI, end_block: JSBI);
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class GetTxListRequest {
    address_list: string[];
    block_section: Option<BlockSection>;
    offset: JSBI;
    length: JSBI;
    constructor(address_list: string[], block_section: Option<BlockSection>, offset: JSBI, length: JSBI);
}

export const TX_STATUS_PENDING: number;
export const TX_STATUS_BLOCKED: number;

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class SPVTx implements RawEncode {
    hash: string;
    number: JSBI;
    from: string;
    to: string;
    coin_id: number;
    value: JSBI;
    desc: string;
    create_time: JSBI;
    result: number;
    use_fee: number;
    nonce: JSBI;
    gas_coin_id: number;
    gas_price: number;
    max_fee: number;
    constructor(hash: string, number: JSBI, from: string, to: string, coin_id: number, value: JSBI, desc: string, create_time: JSBI, result: number, use_fee: number, nonce: JSBI, gas_coin_id: number, gas_price: number, max_fee: number);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class SPVTxDecoder implements RawDecode<SPVTx> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[SPVTx, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class TxInfo {
    status: number;
    tx: TxMetaData;
    block_number: Option<string>;
    block_hash: Option<string>;
    block_create_time: Option<string>;
    constructor(status: number, tx: TxMetaData, block_number: Option<string>, block_hash: Option<string>, block_create_time: Option<string>);
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class TxMetaData {
    tx_hash: string;
    create_time: string;
    nonce: string;
    caller: string;
    gas_coin_id: number;
    gas_price: number;
    max_fee: number;
    result: number;
    use_fee: number;
    to: TxMetaItem[];
    constructor(tx_hash: string, create_time: string, nonce: string, caller: string, gas_coin_id: number, gas_price: number, max_fee: number, result: number, use_fee: number, to: TxMetaItem[]);
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class TxMetaItem {
    field_0: string;
    field_1: number;
    field_2: string;
    constructor(field_0: string, field_1: number, field_2: string);
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class AuctionNameTx implements RawEncode {
    name: string;
    price: JSBI;
    constructor(name: string, price: JSBI);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class AuctionNameTxDecoder implements RawDecode<AuctionNameTx> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[AuctionNameTx, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class BidNameTx implements RawEncode {
    name: string;
    owner: Option<ObjectId>;
    name_price: JSBI;
    price: number;
    constructor(name: string, owner: Option<ObjectId>, name_price: JSBI, price: number);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class BidNameTxDecoder implements RawDecode<BidNameTx> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[BidNameTx, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class BTCCoinageRecordTx implements RawEncode {
    height: JSBI;
    list: BTCTxRecord[];
    constructor(height: JSBI, list: BTCTxRecord[]);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class BTCCoinageRecordTxDecoder implements RawDecode<BTCCoinageRecordTx> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[BTCCoinageRecordTx, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class BTCTxRecord implements RawEncode {
    txid: string;
    blockHash: string;
    blockNumber: JSBI;
    confirmed: JSBI;
    received: JSBI;
    exodusAddress: string;
    btcValue: JSBI;
    version: number;
    propertyID: number;
    op: number;
    address: string;
    constructor(txid: string, blockHash: string, blockNumber: JSBI, confirmed: JSBI, received: JSBI, exodusAddress: string, btcValue: JSBI, version: number, propertyID: number, op: number, address: string);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class BTCTxRecordDecoder implements RawDecode<BTCTxRecord> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[BTCTxRecord, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class BuyBackNameTx implements RawEncode {
    name: string;
    constructor(name: string);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class BuyBackNameTxDecoder implements RawDecode<BuyBackNameTx> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[BuyBackNameTx, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class CancelAuctionNameTx implements RawEncode {
    name: string;
    constructor(name: string);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class CancelAuctionNameTxDecoder implements RawDecode<CancelAuctionNameTx> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[CancelAuctionNameTx, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class CoinTokenId implements RawEncode {
    static Coin(coin: number): CoinTokenId;
    static Token(token: ObjectId): CoinTokenId;
    match<T>(visitor: {
        Coin?: (coin: number) => T;
        Token?: (token: ObjectId) => T;
    }): T | undefined;
    eq_type(rhs: CoinTokenId): boolean;
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class CoinTokenIdDecoder implements RawDecode<CoinTokenId> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[CoinTokenId, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class ContractTx implements RawEncode {
    instance_id: ObjectId;
    func_name: string;
    parm_body: Uint8Array;
    constructor(instance_id: ObjectId, func_name: string, parm_body: Uint8Array);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class ContractTxDecoder implements RawDecode<ContractTx> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[ContractTx, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class CreateDescTx implements RawEncode {
    coin_id: number;
    from: Option<ObjectId>;
    value: JSBI;
    desc_hash: HashValue;
    price: number;
    constructor(coin_id: number, from: Option<ObjectId>, value: JSBI, desc_hash: HashValue, price: number);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class CreateDescTxDecoder implements RawDecode<CreateDescTx> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[CreateDescTx, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class CreateUnionBody implements RawEncode {
    account: UnionAccount;
    ctid: CoinTokenId;
    left_balance: JSBI;
    right_balance: JSBI;
    constructor(account: UnionAccount, ctid: CoinTokenId, left_balance: JSBI, right_balance: JSBI);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class CreateUnionBodyDecoder implements RawDecode<CreateUnionBody> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[CreateUnionBody, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class CreateUnionTx implements RawEncode {
    body: CreateUnionBody;
    signs: Signature[];
    constructor(body: CreateUnionBody, signs: Signature[]);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class CreateUnionTxDecoder implements RawDecode<CreateUnionTx> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[CreateUnionTx, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class Data implements RawEncode {
    id: ObjectId;
    data: Uint8Array;
    constructor(id: ObjectId, data: Uint8Array);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class DataDecoder implements RawDecode<Data> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[Data, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class DeviateUnionTx implements RawEncode {
    body: DeviateUnionBody;
    signs: Signature[];
    constructor(body: DeviateUnionBody, signs: Signature[]);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class DeviateUnionTxDecoder implements RawDecode<DeviateUnionTx> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[DeviateUnionTx, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class DeviateUnionBody implements RawEncode {
    ctid: CoinTokenId;
    seq: JSBI;
    deviation: JSBI;
    union: ObjectId;
    constructor(ctid: CoinTokenId, seq: JSBI, deviation: JSBI, union: ObjectId);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class DeviateUnionBodyDecoder implements RawDecode<DeviateUnionBody> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[DeviateUnionBody, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class FlowServiceDescTypeInfo extends DescTypeInfo {
    obj_type(): number;
    sub_desc_type(): SubDescType;
}
export class FlowServiceDescContent extends DescContent {
    constructor();
    type_info(): DescTypeInfo;
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
}
export class FlowServiceDescContentDecoder extends DescContentDecoder<FlowServiceDescContent> {
    type_info(): DescTypeInfo;
    raw_decode(buf: Uint8Array): BuckyResult<[FlowServiceDescContent, Uint8Array]>;
}
export class FlowServiceBodyContent extends BodyContent {
    price: JSBI;
    constructor(price: JSBI);
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
}
export class FlowServiceBodyContentDecoder extends BodyContentDecoder<FlowServiceBodyContent> {
    raw_decode(buf: Uint8Array): BuckyResult<[FlowServiceBodyContent, Uint8Array]>;
}
export class FlowServiceDesc extends NamedObjectDesc<FlowServiceDescContent> {
}
export class FlowServiceDescDecoder extends NamedObjectDescDecoder<FlowServiceDescContent> {
    constructor();
}
export class FlowServiceBuilder extends NamedObjectBuilder<FlowServiceDescContent, FlowServiceBodyContent> {
}
export class FlowServiceId extends NamedObjectId<FlowServiceDescContent, FlowServiceBodyContent> {
    constructor(id: ObjectId);
    static default(): FlowServiceId;
    static from_base_58(s: string): BuckyResult<FlowServiceId>;
    static try_from_object_id(id: ObjectId): BuckyResult<FlowServiceId>;
}
export class FlowServiceIdDecoder extends NamedObjectIdDecoder<FlowServiceDescContent, FlowServiceBodyContent> {
    constructor();
}
export class FlowService extends NamedObject<FlowServiceDescContent, FlowServiceBodyContent> {
    static create(owner: ObjectId, price: JSBI): FlowService;
}
export class FlowServiceDecoder extends NamedObjectDecoder<FlowServiceDescContent, FlowServiceBodyContent, FlowService> {
    constructor();
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class FlowServiceTx implements RawEncode {
    static Create(create: FlowService): FlowServiceTx;
    static Purchase(purchase: number): FlowServiceTx;
    static Settle(): FlowServiceTx;
    match<T>(visitor: {
        Create?: (create: FlowService) => T;
        Purchase?: (purchase: number) => T;
        Settle?: () => T;
    }): T | undefined;
    eq_type(rhs: FlowServiceTx): boolean;
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class FlowServiceTxDecoder implements RawDecode<FlowServiceTx> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[FlowServiceTx, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class InstanceContractTx implements RawEncode {
    contract_id: ObjectId;
    template_parms: Uint8Array;
    constructor(contract_id: ObjectId, template_parms: Uint8Array);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class InstanceContractTxDecoder implements RawDecode<InstanceContractTx> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[InstanceContractTx, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class MetaPrice implements RawEncode {
    coin_id: number;
    price: number;
    constructor(coin_id: number, price: number);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class MetaPriceDecoder implements RawDecode<MetaPrice> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[MetaPrice, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class MetaTxDescTypeInfo extends DescTypeInfo {
    obj_type(): number;
    sub_desc_type(): SubDescType;
}
export class MetaTxDescContent extends DescContent {
    nonce: JSBI;
    caller: TxCaller;
    gas_coin_id: number;
    gas_price: number;
    max_fee: number;
    condition: Option<TxCondition>;
    body: MetaTxBody[];
    constructor(nonce: JSBI, caller: TxCaller, gas_coin_id: number, gas_price: number, max_fee: number, condition: Option<TxCondition>, body: MetaTxBody[]);
    type_info(): DescTypeInfo;
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
}
export class MetaTxDescContentDecoder extends DescContentDecoder<MetaTxDescContent> {
    type_info(): DescTypeInfo;
    raw_decode(buf: Uint8Array): BuckyResult<[MetaTxDescContent, Uint8Array]>;
}
export class MetaTxDesc extends NamedObjectDesc<MetaTxDescContent> {
}
export class MetaTxDescDecoder extends NamedObjectDescDecoder<MetaTxDescContent> {
    constructor();
}
export class MetaTxBuilder extends NamedObjectBuilder<MetaTxDescContent, TxBodyContent> {
}
export class MetaTxId extends NamedObjectId<MetaTxDescContent, TxBodyContent> {
    constructor(id: ObjectId);
    static default(): MetaTxId;
    static from_base_58(s: string): BuckyResult<MetaTxId>;
    static try_from_object_id(id: ObjectId): BuckyResult<MetaTxId>;
}
export class MetaTxIdDecoder extends NamedObjectIdDecoder<MetaTxDescContent, TxBodyContent> {
    constructor();
}
export class MetaTx extends NamedObject<MetaTxDescContent, TxBodyContent> {
    static create(nonce: JSBI, caller: TxCaller, gas_coin_id: number, gas_price: number, max_fee: number, condition: Option<TxCondition>, body: MetaTxBody[], data: Uint8Array): MetaTx;
    ext(): MetaTxExt;
}
export class MetaTxDecoder extends NamedObjectDecoder<MetaTxDescContent, TxBodyContent, MetaTx> {
    constructor();
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class MetaTxBody implements RawEncode {
    static TransBalance(transbalance: TransBalanceTx): MetaTxBody;
    static CreateUnion(createunion: CreateUnionTx): MetaTxBody;
    static DeviateUnion(deviateunion: DeviateUnionTx): MetaTxBody;
    static WithdrawFromUnion(withdrawfromunion: WithdrawFromUnionTx): MetaTxBody;
    static CreateDesc(createdesc: CreateDescTx): MetaTxBody;
    static UpdateDesc(updatedesc: UpdateDescTx): MetaTxBody;
    static RemoveDesc(removedesc: RemoveDescTx): MetaTxBody;
    static BidName(bidname: BidNameTx): MetaTxBody;
    static UpdateName(updatename: UpdateNameTx): MetaTxBody;
    static TransName(transname: TransNameTx): MetaTxBody;
    static Contract(contract: ContractTx): MetaTxBody;
    static SetConfig(setconfig: SetConfigTx): MetaTxBody;
    static AuctionName(auctionname: AuctionNameTx): MetaTxBody;
    static CancelAuctionName(cancelauctionname: CancelAuctionNameTx): MetaTxBody;
    static BuyBackName(buybackname: BuyBackNameTx): MetaTxBody;
    static BTCCoinageRecord(btccoinagerecord: BTCCoinageRecordTx): MetaTxBody;
    static WithdrawToOwner(withdrawtoowner: WithdrawToOwner): MetaTxBody;
    static CreateMinerGroup(createminergroup: MinerGroup): MetaTxBody;
    static UpdateMinerGroup(updateminergroup: MinerGroup): MetaTxBody;
    static CreateSubChainAccount(createsubchainaccount: MinerGroup): MetaTxBody;
    static UpdateSubChainAccount(updatesubchainaccount: MinerGroup): MetaTxBody;
    static SubChainWithdraw(subchainwithdraw: SubChainWithdrawTx): MetaTxBody;
    static WithdrawFromSubChain(withdrawfromsubchain: WithdrawFromSubChainTx): MetaTxBody;
    static SubChainCoinageRecord(subchaincoinagerecord: SubChainCoinageRecordTx): MetaTxBody;
    static Extension(extension: MetaExtensionTx): MetaTxBody;
    static CreateContract(createcontract: CreateContractTx): MetaTxBody;
    static CreateContract2(createcontract2: CreateContract2Tx): MetaTxBody;
    static CallContract(callcontract: CallContractTx): MetaTxBody;
    match<T>(visitor: {
        TransBalance?: (transbalance: TransBalanceTx) => T;
        CreateUnion?: (createunion: CreateUnionTx) => T;
        DeviateUnion?: (deviateunion: DeviateUnionTx) => T;
        WithdrawFromUnion?: (withdrawfromunion: WithdrawFromUnionTx) => T;
        CreateDesc?: (createdesc: CreateDescTx) => T;
        UpdateDesc?: (updatedesc: UpdateDescTx) => T;
        RemoveDesc?: (removedesc: RemoveDescTx) => T;
        BidName?: (bidname: BidNameTx) => T;
        UpdateName?: (updatename: UpdateNameTx) => T;
        TransName?: (transname: TransNameTx) => T;
        Contract?: (contract: ContractTx) => T;
        SetConfig?: (setconfig: SetConfigTx) => T;
        AuctionName?: (auctionname: AuctionNameTx) => T;
        CancelAuctionName?: (cancelauctionname: CancelAuctionNameTx) => T;
        BuyBackName?: (buybackname: BuyBackNameTx) => T;
        BTCCoinageRecord?: (btccoinagerecord: BTCCoinageRecordTx) => T;
        WithdrawToOwner?: (withdrawtoowner: WithdrawToOwner) => T;
        CreateMinerGroup?: (createminergroup: MinerGroup) => T;
        UpdateMinerGroup?: (updateminergroup: MinerGroup) => T;
        CreateSubChainAccount?: (createsubchainaccount: MinerGroup) => T;
        UpdateSubChainAccount?: (updatesubchainaccount: MinerGroup) => T;
        SubChainWithdraw?: (subchainwithdraw: SubChainWithdrawTx) => T;
        WithdrawFromSubChain?: (withdrawfromsubchain: WithdrawFromSubChainTx) => T;
        SubChainCoinageRecord?: (subchaincoinagerecord: SubChainCoinageRecordTx) => T;
        Extension?: (extension: MetaExtensionTx) => T;
        CreateContract?: (tx: CreateContractTx) => T;
        CreateContract2?: (tx: CreateContract2Tx) => T;
        CallContract?: (tx: CallContractTx) => T;
    }): T | undefined;
    eq_type(rhs: MetaTxBody): boolean;
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class MetaTxBodyDecoder implements RawDecode<MetaTxBody> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[MetaTxBody, Uint8Array]>;
}

export class MetaTxExt {
    obj: MetaTx;
    constructor(obj: MetaTx);
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class MinerGroupDescTypeInfo extends DescTypeInfo {
    obj_type(): number;
    sub_desc_type(): SubDescType;
}
export class MinerGroupDescContent extends DescContent {
    constructor();
    type_info(): DescTypeInfo;
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
}
export class MinerGroupDescContentDecoder extends DescContentDecoder<MinerGroupDescContent> {
    type_info(): DescTypeInfo;
    raw_decode(buf: Uint8Array): BuckyResult<[MinerGroupDescContent, Uint8Array]>;
}
export class MinerGroupBodyContent extends BodyContent {
    members: DeviceDesc[];
    constructor(members: DeviceDesc[]);
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
}
export class MinerGroupBodyContentDecoder extends BodyContentDecoder<MinerGroupBodyContent> {
    raw_decode(buf: Uint8Array): BuckyResult<[MinerGroupBodyContent, Uint8Array]>;
}
export class MinerGroupDesc extends NamedObjectDesc<MinerGroupDescContent> {
}
export class MinerGroupDescDecoder extends NamedObjectDescDecoder<MinerGroupDescContent> {
    constructor();
}
export class MinerGroupBuilder extends NamedObjectBuilder<MinerGroupDescContent, MinerGroupBodyContent> {
}
export class MinerGroupId extends NamedObjectId<MinerGroupDescContent, MinerGroupBodyContent> {
    constructor(id: ObjectId);
    static default(): MinerGroupId;
    static from_base_58(s: string): BuckyResult<MinerGroupId>;
    static try_from_object_id(id: ObjectId): BuckyResult<MinerGroupId>;
}
export class MinerGroupIdDecoder extends NamedObjectIdDecoder<MinerGroupDescContent, MinerGroupBodyContent> {
    constructor();
}
export class MinerGroup extends NamedObject<MinerGroupDescContent, MinerGroupBodyContent> {
    static create(members: DeviceDesc[]): MinerGroup;
    ext(): MinerGroupExt;
}
export class MinerGroupDecoder extends NamedObjectDecoder<MinerGroupDescContent, MinerGroupBodyContent, MinerGroup> {
    constructor();
}

export class MinerGroupExt {
    obj: MinerGroup;
    constructor(obj: MinerGroup);
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class ContractLog implements RawEncode {
    address: ObjectId;
    topics: Uint8Array[];
    data: Uint8Array;
    constructor(address: ObjectId, topics: Uint8Array[], data: Uint8Array);
    raw_measure(ctx?: any, purpose?: RawEncodePurpose): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any, purpose?: RawEncodePurpose): BuckyResult<Uint8Array>;
}
export class ContractLogDecoder implements RawDecode<ContractLog> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[ContractLog, Uint8Array]>;
}
export class TxLog implements RawEncode {
    static ContractLog(contractLog: ContractLog): TxLog;
    match<T>(visitor: {
        ContractLog?: (contractLog: ContractLog) => T;
    }): T | undefined;
    eq_type(rhs: TxLog): boolean;
    raw_measure(ctx?: any, purpose?: RawEncodePurpose): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any, purpose?: RawEncodePurpose): BuckyResult<Uint8Array>;
}
export class TxLogDecoder implements RawDecode<TxLog> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[TxLog, Uint8Array]>;
}
export class Receipt implements RawEncode {
    result: number;
    fee_used: number;
    logs: TxLog[];
    address: Option<ObjectId>;
    return_value: Option<Uint8Array>;
    constructor(result: number, fee_used: number, logs: TxLog[], address: Option<ObjectId>, return_value: Option<Uint8Array>);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class ReceiptDecoder implements RawDecode<Receipt> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[Receipt, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class RemoveDescTx implements RawEncode {
    id: ObjectId;
    constructor(id: ObjectId);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class RemoveDescTxDecoder implements RawDecode<RemoveDescTx> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[RemoveDescTx, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class SavedMetaObject implements RawEncode {
    static try_from(object: StandardObject): BuckyResult<SavedMetaObject>;
    static Device(device: Device): SavedMetaObject;
    static People(people: People): SavedMetaObject;
    static UnionAccount(unionaccount: UnionAccount): SavedMetaObject;
    static Group(group: SimpleGroup): SavedMetaObject;
    static File(file: File): SavedMetaObject;
    static Data(data: Data): SavedMetaObject;
    static Org(org: Org): SavedMetaObject;
    static MinerGroup(minergroup: MinerGroup): SavedMetaObject;
    static SNService(snservice: SNService): SavedMetaObject;
    static Contract(contract: Contract): SavedMetaObject;
    match<T>(visitor: {
        Device?: (device: Device) => T;
        People?: (people: People) => T;
        UnionAccount?: (unionaccount: UnionAccount) => T;
        Group?: (group: SimpleGroup) => T;
        File?: (file: File) => T;
        Data?: (data: Data) => T;
        Org?: (org: Org) => T;
        MinerGroup?: (minergroup: MinerGroup) => T;
        SNService?: (snservice: SNService) => T;
        Contract?: (contract: Contract) => T;
    }): T | undefined;
    eq_type(rhs: SavedMetaObject): boolean;
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
    hash(): BuckyResult<HashValue>;
}
export class SavedMetaObjectDecoder implements RawDecode<SavedMetaObject> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[SavedMetaObject, Uint8Array]>;
}

export class SavedMetaObjectExt {
    obj: SavedMetaObject;
    constructor(obj: SavedMetaObject);
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class SetConfigTx implements RawEncode {
    key: string;
    value: string;
    constructor(key: string, value: string);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class SetConfigTxDecoder implements RawDecode<SetConfigTx> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[SetConfigTx, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class SNServiceTx implements RawEncode {
    static Publish(publish: SNService): SNServiceTx;
    static Remove(remove: ObjectId): SNServiceTx;
    static Purchase(purchase: Contract): SNServiceTx;
    static Settle(settle: ProofOfService): SNServiceTx;
    match<T>(visitor: {
        Publish?: (publish: SNService) => T;
        Remove?: (remove: ObjectId) => T;
        Purchase?: (purchase: Contract) => T;
        Settle?: (settle: ProofOfService) => T;
    }): T | undefined;
    eq_type(rhs: SNServiceTx): boolean;
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class SNServiceTxDecoder implements RawDecode<SNServiceTx> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[SNServiceTx, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class SubChainCoinageRecordTx implements RawEncode {
    height: JSBI;
    list: SPVTx[];
    constructor(height: JSBI, list: SPVTx[]);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class SubChainCoinageRecordTxDecoder implements RawDecode<SubChainCoinageRecordTx> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[SubChainCoinageRecordTx, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class SubChainWithdrawTx implements RawEncode {
    subchain_id: ObjectId;
    withdraw_tx: Uint8Array;
    constructor(subchain_id: ObjectId, withdraw_tx: Uint8Array);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class SubChainWithdrawTxDecoder implements RawDecode<SubChainWithdrawTx> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[SubChainWithdrawTx, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class TransBalanceTx implements RawEncode {
    ctid: CoinTokenId;
    to: TransBalanceTxItem[];
    constructor(ctid: CoinTokenId, to: TransBalanceTxItem[]);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class TransBalanceTxDecoder implements RawDecode<TransBalanceTx> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[TransBalanceTx, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class TransBalanceTxItem implements RawEncode {
    id: ObjectId;
    balance: JSBI;
    constructor(id: ObjectId, balance: JSBI);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class TransBalanceTxItemDecoder implements RawDecode<TransBalanceTxItem> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[TransBalanceTxItem, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class TransNameTx implements RawEncode {
    sub_name: Option<string>;
    new_owner: ObjectId;
    constructor(sub_name: Option<string>, new_owner: ObjectId);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class TransNameTxDecoder implements RawDecode<TransNameTx> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[TransNameTx, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class TxDescTypeInfo extends DescTypeInfo {
    obj_type(): number;
    sub_desc_type(): SubDescType;
}
export class TxDescContent<T extends RawEncode> extends DescContent {
    nonce: JSBI;
    caller: TxCaller;
    gas_coin_id: number;
    gas_price: number;
    max_fee: number;
    condition: Option<TxCondition>;
    body: T;
    constructor(nonce: JSBI, caller: TxCaller, gas_coin_id: number, gas_price: number, max_fee: number, condition: Option<TxCondition>, body: T);
    type_info(): DescTypeInfo;
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
}
export class TxDescContentDecoder<T extends RawEncode, D extends RawDecode<T>> extends DescContentDecoder<TxDescContent<T>> {
    constructor(inner_decoder: D);
    type_info(): DescTypeInfo;
    raw_decode(buf: Uint8Array): BuckyResult<[TxDescContent<T>, Uint8Array]>;
}
export class TxBodyContent extends ProtobufBodyContent<protos.ITxBodyContent> {
    data: Uint8Array;
    try_to_proto(): BuckyResult<protos.ITxBodyContent>;
    constructor(data: Uint8Array);
}
export class TxBodyContentDecoder extends BodyContentDecoder<TxBodyContent> {
    raw_decode(buf: Uint8Array): BuckyResult<[TxBodyContent, Uint8Array]>;
}
export type MetaTxDescContentType = TxDescContent<TypeBuffer<Vec<MetaTxBody>>>;
export class TxDesc extends NamedObjectDesc<MetaTxDescContentType> {
}
export class TxBuilder extends NamedObjectBuilder<MetaTxDescContentType, TxBodyContent> {
}
export class TxId extends NamedObjectId<MetaTxDescContentType, TxBodyContent> {
    constructor(id: ObjectId);
    static default(): TxId;
    static from_base_58(s: string): BuckyResult<TxId>;
    static try_from_object_id(id: ObjectId): BuckyResult<TxId>;
}
export class TxIdDecoder extends NamedObjectIdDecoder<MetaTxDescContentType, TxBodyContent> {
    constructor();
}
export class Tx extends NamedObject<MetaTxDescContentType, TxBodyContent> {
    static create(nonce: JSBI, caller: TxCaller, gas_coin_id: number, gas_price: number, max_fee: number, condition: Option<TxCondition>, body: MetaTxBody, data: Uint8Array): Tx;
    ext(): TxExt;
}
export class TxDecoder extends NamedObjectDecoder<MetaTxDescContentType, TxBodyContent, Tx> {
    constructor();
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class TxBody implements RawEncode {
    body: Uint8Array;
    constructor(body: Uint8Array);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class TxBodyDecoder implements RawDecode<TxBody> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[TxBody, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class TxCaller implements RawEncode {
    static try_from(object: StandardObject): BuckyResult<TxCaller>;
    static People(people: PeopleDesc): TxCaller;
    static Device(device: DeviceDesc): TxCaller;
    static Group(group: SimpleGroupDesc): TxCaller;
    static Union(union: UnionAccountDesc): TxCaller;
    static Miner(miner: ObjectId): TxCaller;
    static Id(id: ObjectId): TxCaller;
    match<T>(visitor: {
        People?: (people: PeopleDesc) => T;
        Device?: (device: DeviceDesc) => T;
        Group?: (group: SimpleGroupDesc) => T;
        Union?: (union: UnionAccountDesc) => T;
        Miner?: (miner: ObjectId) => T;
        Id?: (id: ObjectId) => T;
    }): T | undefined;
    eq_type(rhs: TxCaller): boolean;
    ext(): TxCallerExt;
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class TxCallerDecoder implements RawDecode<TxCaller> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[TxCaller, Uint8Array]>;
}

export class TxCallerExt {
    obj: TxCaller;
    constructor(obj: TxCaller);
    id(): BuckyResult<ObjectId>;
    get_public_key(): BuckyResult<PublicKey>;
    is_miner(): boolean;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class TxCondition implements RawEncode {
    static Empty(): TxCondition;
    match<T>(visitor: {
        Empty?: () => T;
    }): T | undefined;
    eq_type(rhs: TxCondition): boolean;
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class TxConditionDecoder implements RawDecode<TxCondition> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[TxCondition, Uint8Array]>;
}

export class TxExt {
    obj: Tx;
    constructor(obj: Tx);
    tx_id(): TxId;
    connect_info(): TxBodyContent;
    verify_signature(public_key: PublicKey): Promise<BuckyResult<boolean>>;
    sign(): Promise<BuckyResult<number>>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class UpdateDescTx implements RawEncode {
    write_flag: number;
    price: Option<MetaPrice>;
    desc_hash: HashValue;
    constructor(write_flag: number, price: Option<MetaPrice>, desc_hash: HashValue);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class UpdateDescTxDecoder implements RawDecode<UpdateDescTx> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[UpdateDescTx, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class UpdateNameTx implements RawEncode {
    name: string;
    info: NameInfo;
    write_flag: number;
    constructor(name: string, info: NameInfo, write_flag: number);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class UpdateNameTxDecoder implements RawDecode<UpdateNameTx> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[UpdateNameTx, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class WithdrawToOwner implements RawEncode {
    ctid: CoinTokenId;
    id: ObjectId;
    value: JSBI;
    constructor(ctid: CoinTokenId, id: ObjectId, value: JSBI);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class WithdrawToOwnerDecoder implements RawDecode<WithdrawToOwner> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[WithdrawToOwner, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class WithdrawFromSubChainTx implements RawEncode {
    coin_id: CoinTokenId;
    value: JSBI;
    constructor(coin_id: CoinTokenId, value: JSBI);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class WithdrawFromSubChainTxDecoder implements RawDecode<WithdrawFromSubChainTx> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[WithdrawFromSubChainTx, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class WithdrawFromUnionTx implements RawEncode {
    ctid: CoinTokenId;
    union: ObjectId;
    value: JSBI;
    constructor(ctid: CoinTokenId, union: ObjectId, value: JSBI);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class WithdrawFromUnionTxDecoder implements RawDecode<WithdrawFromUnionTx> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[WithdrawFromUnionTx, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export enum FFSObjectState {
    Normal = 0,
    Expire = 1
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export enum PeerOfUnion {
    Left = 0,
    Right = 1
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class UnionBalance implements RawEncode {
    total: JSBI;
    left: JSBI;
    right: JSBI;
    deviation: JSBI;
    constructor(total: JSBI, left: JSBI, right: JSBI, deviation: JSBI);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class UnionBalanceDecoder implements RawDecode<UnionBalance> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[UnionBalance, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class ChainStatus implements RawEncode {
    version: number;
    height: JSBI;
    gas_price: GasPrice;
    constructor(version: number, height: JSBI, gas_price: GasPrice);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class ChainStatusDecoder implements RawDecode<ChainStatus> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[ChainStatus, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class GasPrice implements RawEncode {
    low: JSBI;
    medium: JSBI;
    high: JSBI;
    constructor(low: JSBI, medium: JSBI, high: JSBI);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class GasPriceDecoder implements RawDecode<GasPrice> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[GasPrice, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class TxFullInfo implements RawEncode {
    status: number;
    block_number: JSBI;
    tx: MetaTx;
    receipt: Option<Receipt>;
    constructor(status: number, block_number: JSBI, tx: MetaTx, receipt: Option<Receipt>);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class TxFullInfoDecoder implements RawDecode<TxFullInfo> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[TxFullInfo, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class ViewBlockEnum implements RawEncode {
    static Tip(): ViewBlockEnum;
    static Number(number: JSBI): ViewBlockEnum;
    static Hash(hash: ObjectId): ViewBlockEnum;
    match<T>(visitor: {
        Tip?: () => T;
        Number?: (number: JSBI) => T;
        Hash?: (hash: ObjectId) => T;
    }): T | undefined;
    eq_type(rhs: ViewBlockEnum): boolean;
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class ViewBlockEnumDecoder implements RawDecode<ViewBlockEnum> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[ViewBlockEnum, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class ViewMethodEnum implements RawEncode {
    static ViewBalance(viewbalance: ViewBalanceMethod): ViewMethodEnum;
    static ViewName(viewname: ViewNameMethod): ViewMethodEnum;
    static ViewDesc(viewdesc: ViewDescMethod): ViewMethodEnum;
    static ViewRaw(viewraw: ViewRawMethod): ViewMethodEnum;
    static ViewStatus(): ViewMethodEnum;
    static ViewBlock(): ViewMethodEnum;
    static ViewTx(viewtx: ObjectId): ViewMethodEnum;
    static ViewContract(viewtx: ViewContract): ViewMethodEnum;
    static ViewLog(viewtx: ViewLog): ViewMethodEnum;
    match<T>(visitor: {
        ViewBalance?: (viewbalance: ViewBalanceMethod) => T;
        ViewName?: (viewname: ViewNameMethod) => T;
        ViewDesc?: (viewdesc: ViewDescMethod) => T;
        ViewRaw?: (viewraw: ViewRawMethod) => T;
        ViewStatus?: () => T;
        ViewBlock?: () => T;
        ViewTx?: (viewtx: ObjectId) => T;
        ViewContract?: (tx: ViewContract) => T;
        ViewLog?: (tx: ViewLog) => T;
    }): T | undefined;
    eq_type(rhs: ViewMethodEnum): boolean;
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class ViewMethodEnumDecoder implements RawDecode<ViewMethodEnum> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[ViewMethodEnum, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class ViewRequest implements RawEncode {
    block: ViewBlockEnum;
    method: ViewMethodEnum;
    constructor(block: ViewBlockEnum, method: ViewMethodEnum);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class ViewRequestDecoder implements RawDecode<ViewRequest> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[ViewRequest, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class ViewResponse implements RawEncode {
    static ViewBalance(viewbalance: ViewBalanceResult): ViewResponse;
    static ViewName(viewname: ViewNameResult): ViewResponse;
    static ViewDesc(viewdesc: SavedMetaObject): ViewResponse;
    static ViewRaw(viewraw: Uint8Array): ViewResponse;
    static ViewStatus(viewstatus: ChainStatus): ViewResponse;
    static ViewBlock(viewblock: Block): ViewResponse;
    static ViewTx(viewtx: TxFullInfo): ViewResponse;
    static ViewContract(viewtx: ViewContractResult): ViewResponse;
    static ViewLog(viewtx: ViewLogResult): ViewResponse;
    match<T>(visitor: {
        ViewBalance?: (viewbalance: ViewBalanceResult) => T;
        ViewName?: (viewname: ViewNameResult) => T;
        ViewDesc?: (viewdesc: SavedMetaObject) => T;
        ViewRaw?: (viewraw: Uint8Array) => T;
        ViewStatus?: (viewstatus: ChainStatus) => T;
        ViewBlock?: (viewblock: Block) => T;
        ViewTx?: (viewtx: TxFullInfo) => T;
        ViewContract?: (viewtx: ViewContractResult) => T;
        ViewLog?: (viewtx: ViewLogResult) => T;
    }): T | undefined;
    eq_type(rhs: ViewResponse): boolean;
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class ViewResponseDecoder implements RawDecode<ViewResponse> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[ViewResponse, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class ViewBalanceMethod implements RawEncode {
    account: ObjectId;
    ctid: CoinTokenId[];
    constructor(account: ObjectId, ctid: CoinTokenId[]);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class ViewBalanceMethodDecoder implements RawDecode<ViewBalanceMethod> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[ViewBalanceMethod, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class ViewDescMethod implements RawEncode {
    id: ObjectId;
    constructor(id: ObjectId);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class ViewDescMethodDecoder implements RawDecode<ViewDescMethod> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[ViewDescMethod, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class ViewNameMethod implements RawEncode {
    name: string;
    constructor(name: string);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class ViewNameMethodDecoder implements RawDecode<ViewNameMethod> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[ViewNameMethod, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class ViewRawMethod implements RawEncode {
    id: ObjectId;
    constructor(id: ObjectId);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class ViewRawMethodDecoder implements RawDecode<ViewRawMethod> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[ViewRawMethod, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class ViewBalanceResult implements RawEncode {
    static Single(single: ViewSingleBalanceResult): ViewBalanceResult;
    static Union(union: ViewUnionBalanceResult): ViewBalanceResult;
    match<T>(visitor: {
        Single?: (single: ViewSingleBalanceResult) => T;
        Union?: (union: ViewUnionBalanceResult) => T;
    }): T | undefined;
    eq_type(rhs: ViewBalanceResult): boolean;
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class ViewBalanceResultDecoder implements RawDecode<ViewBalanceResult> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[ViewBalanceResult, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class ViewNameResult implements RawEncode {
    results: Option<ViewNameResultItem>;
    constructor(results: Option<ViewNameResultItem>);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class ViewNameResultDecoder implements RawDecode<ViewNameResult> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[ViewNameResult, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class ViewNameResultItem implements RawEncode {
    name_info: NameInfo;
    name_state: NameState;
    constructor(name_info: NameInfo, name_state: NameState);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class ViewNameResultItemDecoder implements RawDecode<ViewNameResultItem> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[ViewNameResultItem, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class ViewSingleBalanceResult implements RawEncode {
    results: ViewSingleBalanceResultItem[];
    constructor(results: ViewSingleBalanceResultItem[]);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class ViewSingleBalanceResultDecoder implements RawDecode<ViewSingleBalanceResult> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[ViewSingleBalanceResult, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class ViewSingleBalanceResultItem implements RawEncode {
    id: CoinTokenId;
    result: JSBI;
    constructor(id: CoinTokenId, result: JSBI);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class ViewSingleBalanceResultItemDecoder implements RawDecode<ViewSingleBalanceResultItem> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[ViewSingleBalanceResultItem, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class ViewUnionBalanceResult implements RawEncode {
    results: ViewUnionBalanceResultItem[];
    constructor(results: ViewUnionBalanceResultItem[]);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class ViewUnionBalanceResultDecoder implements RawDecode<ViewUnionBalanceResult> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[ViewUnionBalanceResult, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class ViewUnionBalanceResultItem implements RawEncode {
    id: CoinTokenId;
    union_balance: UnionBalance;
    result: JSBI;
    constructor(id: CoinTokenId, union_balance: UnionBalance, result: JSBI);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class ViewUnionBalanceResultItemDecoder implements RawDecode<ViewUnionBalanceResultItem> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[ViewUnionBalanceResultItem, Uint8Array]>;
}

export class TextObjectDescTypeInfo extends DescTypeInfo {
    obj_type(): number;
    sub_desc_type(): SubDescType;
}
export class TextObjectDescContent extends ProtobufDescContent<protos.ITextDescContent> {
    id: string;
    header: string;
    constructor(id: string, header: string);
    type_info(): DescTypeInfo;
    set_id(id: string): void;
    set_header(header: string): void;
    try_to_proto(): BuckyResult<protos.ITextDescContent>;
}
export class TextObjectDescContentDecoder extends ProtobufDescContentDecoder<TextObjectDescContent, protos.ITextDescContent> {
    constructor();
    type_info(): DescTypeInfo;
    try_from_proto(value: protos.ITextDescContent): BuckyResult<TextObjectDescContent>;
}
export class TextObjectBodyContent extends ProtobufBodyContent<protos.ITextContent> {
    value: string;
    constructor(value: string);
    set_value(value: string): void;
    try_to_proto(): BuckyResult<protos.ITextContent>;
}
export class TextObjectBodyContentDecoder extends ProtobufBodyContentDecoder<TextObjectBodyContent, protos.ITextContent> {
    constructor();
    try_from_proto(value: protos.ITextContent): BuckyResult<TextObjectBodyContent>;
}
export class TextObjectDesc extends NamedObjectDesc<TextObjectDescContent> {
}
export class TextObjectDescDecoder extends NamedObjectDescDecoder<TextObjectDescContent> {
}
export class TextObjectBuilder extends NamedObjectBuilder<TextObjectDescContent, TextObjectBodyContent> {
}
export class TextObjectId extends NamedObjectId<TextObjectDescContent, TextObjectBodyContent> {
    constructor(id: ObjectId);
    static default(): TextObjectId;
    static from_base_58(s: string): BuckyResult<TextObjectId>;
    static try_from_object_id(id: ObjectId): BuckyResult<TextObjectId>;
}
export class TextObjectIdDecoder extends NamedObjectIdDecoder<TextObjectDescContent, TextObjectBodyContent> {
    constructor();
}
export class TextObject extends NamedObject<TextObjectDescContent, TextObjectBodyContent> {
    static build(owner: Option<ObjectId>, id: string, header: string, value: string): TextObjectBuilder;
    static create(owner: Option<ObjectId>, id: string, header: string, value: string): TextObject;
    get id(): string;
    get header(): string;
    get value(): string;
    set value(value: string);
}
export class TextObjectDecoder extends NamedObjectDecoder<TextObjectDescContent, TextObjectBodyContent, TextObject> {
    constructor();
    static create(): TextObjectDecoder;
}

export class FriendListDescTypeInfo extends DescTypeInfo {
    obj_type(): number;
    sub_desc_type(): SubDescType;
}
export class FriendListDescContent extends ProtobufDescContent<base_proto.IEmptyContent> {
    try_to_proto(): BuckyResult<base_proto.IEmptyContent>;
    constructor();
    type_info(): DescTypeInfo;
}
export class FriendListDescContentDecoder extends ProtobufDescContentDecoder<FriendListDescContent, base_proto.IEmptyContent> {
    try_from_proto(value: base_proto.IEmptyContent): BuckyResult<FriendListDescContent>;
    type_info(): DescTypeInfo;
    constructor();
}
export class FriendContent implements RawEncode {
    raw_measure(ctx?: any, purpose?: RawEncodePurpose): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any, purpose?: RawEncodePurpose): BuckyResult<Uint8Array>;
}
export class FriendListBodyContent extends ProtobufBodyContent<protos.IFriendListContent> {
    friends: BuckyHashMap<ObjectId, FriendContent>;
    auto_confirm: boolean;
    auto_msg: string;
    try_to_proto(): BuckyResult<protos.IFriendListContent>;
    constructor(friends: BuckyHashMap<ObjectId, FriendContent>, auto_confirm: boolean, auto_msg: string);
}
export class FriendListBodyContentDecoder extends ProtobufBodyContentDecoder<FriendListBodyContent, protos.IFriendListContent> {
    try_from_proto(value: protos.IFriendListContent): BuckyResult<FriendListBodyContent>;
    constructor();
}
export class FriendListDesc extends NamedObjectDesc<FriendListDescContent> {
}
export class FriendListDescDecoder extends NamedObjectDescDecoder<FriendListDescContent> {
}
export class FriendListBuilder extends NamedObjectBuilder<FriendListDescContent, FriendListBodyContent> {
}
export class FriendListId extends NamedObjectId<FriendListDescContent, FriendListBodyContent> {
    constructor(id: ObjectId);
    static default(): FriendListId;
    static from_base_58(s: string): BuckyResult<FriendListId>;
    static try_from_object_id(id: ObjectId): BuckyResult<FriendListId>;
}
export class FriendListIdDecoder extends NamedObjectIdDecoder<FriendListDescContent, FriendListBodyContent> {
    constructor();
}
export class FriendList extends NamedObject<FriendListDescContent, FriendListBodyContent> {
    static create(owner: PeopleId, auto_confirm: boolean): FriendList;
    friend_list(): BuckyHashMap<ObjectId, FriendContent>;
    auto_confirm(): boolean;
    auto_msg(): string;
    set_auto_confirm(auto_confirm: boolean): void;
    set_auto_msg(auto_msg: string): void;
}
export class FriendListDecoder extends NamedObjectDecoder<FriendListDescContent, FriendListBodyContent, FriendList> {
    constructor();
}

export class StorageDescTypeInfo extends DescTypeInfo {
    obj_type(): number;
    sub_desc_type(): SubDescType;
}
export class StorageDescContent extends ProtobufDescContent<protos.IStorageDescContent> {
    constructor(id: string);
    id(): string;
    type_info(): DescTypeInfo;
    try_to_proto(): BuckyResult<protos.IStorageDescContent>;
}
export class StorageDescContentDecoder extends ProtobufDescContentDecoder<StorageDescContent, protos.IStorageDescContent> {
    constructor();
    type_info(): DescTypeInfo;
    try_from_proto(value: protos.IStorageDescContent): BuckyResult<StorageDescContent>;
}
export class StorageBodyContent extends ProtobufBodyContent<protos.IStorageBodyContent> {
    constructor(value: Uint8Array);
    value(): Uint8Array;
    try_to_proto(): BuckyResult<protos.IStorageBodyContent>;
}
export class StorageBodyContentDecoder extends ProtobufBodyContentDecoder<StorageBodyContent, protos.IStorageBodyContent> {
    constructor();
    try_from_proto(value: protos.IStorageBodyContent): BuckyResult<StorageBodyContent>;
}
export class StorageDesc extends NamedObjectDesc<StorageDescContent> {
}
export class StorageDescDecoder extends NamedObjectDescDecoder<StorageDescContent> {
}
export class StorageBuilder extends NamedObjectBuilder<StorageDescContent, StorageBodyContent> {
}
export class StorageId extends NamedObjectId<StorageDescContent, StorageBodyContent> {
    constructor(id: ObjectId);
    static default(): DeviceId;
    static from_base_58(s: string): BuckyResult<DeviceId>;
    static try_from_object_id(id: ObjectId): BuckyResult<DeviceId>;
}
export class StorageIdDecoder extends NamedObjectIdDecoder<StorageDescContent, StorageBodyContent> {
    constructor();
}
export class Storage extends NamedObject<StorageDescContent, StorageBodyContent> {
    static create(id: string, value: Uint8Array): Storage;
    id(): string;
    value(): Uint8Array;
    storage_id(): StorageId;
}
export class StorageDecoder extends NamedObjectDecoder<StorageDescContent, StorageBodyContent, Storage> {
    constructor();
}

export class TopicDescTypeInfo extends DescTypeInfo {
    obj_type(): number;
    sub_desc_type(): SubDescType;
}
export class TopicDescContent extends DescContent {
    constructor(unique_id: UniqueId, user_data_id: Option<ObjectId>);
    unique_id(): UniqueId;
    user_data_id(): Option<ObjectId>;
    type_info(): DescTypeInfo;
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
}
export class TopicDescContentDecoder extends DescContentDecoder<TopicDescContent> {
    type_info(): DescTypeInfo;
    raw_decode(buf: Uint8Array): BuckyResult<[TopicDescContent, Uint8Array]>;
}
export class TopicBodyContent extends BodyContent {
    constructor(topic_publish_status_id: Option<TopicPublishStatusId>);
    topic_publish_status_id(): Option<TopicPublishStatusId>;
    set_topic_publish_status_id(id: TopicPublishStatusId): void;
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
}
export class TopicBodyContentDecoder extends BodyContentDecoder<TopicBodyContent> {
    raw_decode(buf: Uint8Array): BuckyResult<[TopicBodyContent, Uint8Array]>;
}
export class TopicDesc extends NamedObjectDesc<TopicDescContent> {
}
export class TopicDescDecoder extends NamedObjectDescDecoder<TopicDescContent> {
}
export class TopicId extends NamedObjectId<TopicDescContent, TopicBodyContent> {
    constructor(id: ObjectId);
    static default(): DeviceId;
    static from_base_58(s: string): BuckyResult<DeviceId>;
    static try_from_object_id(id: ObjectId): BuckyResult<DeviceId>;
}
export class TopicIdDecoder extends NamedObjectIdDecoder<TopicDescContent, TopicBodyContent> {
    constructor();
}
export class Topic extends NamedObject<TopicDescContent, TopicBodyContent> {
    static create(owner_id: ObjectId, unique_id: UniqueId, user_data_id: Option<ObjectId>): Topic;
    topic_id(): TopicId;
    owner_id(): ObjectId;
    topic_publish_status_id(): TopicPublishStatusId;
    set_topic_publish_status_id(id: TopicPublishStatusId): void;
    unique_id(): UniqueId;
    user_data_id(): Option<ObjectId>;
}
export class TopicDecoder extends NamedObjectDecoder<TopicDescContent, TopicBodyContent, Topic> {
    constructor();
}

export const TOPIC_MSG_LIST_NODE_CAPACITY: number;
export const TOPIC_MSG_LIST_CACHE_LIMIT: number;
export class TopicMessageListDescTypeInfo extends DescTypeInfo {
    obj_type(): number;
    sub_desc_type(): SubDescType;
}
export class TopicMessageListDescContent extends DescContent {
    constructor(topic_id: TopicId, slot: number);
    topic_id(): TopicId;
    slot(): number;
    type_info(): DescTypeInfo;
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
}
export class TopicMessageListDescContentDecoder extends DescContentDecoder<TopicMessageListDescContent> {
    type_info(): DescTypeInfo;
    raw_decode(buf: Uint8Array): BuckyResult<[TopicMessageListDescContent, Uint8Array]>;
}
export class TopicMessageListBodyContent extends BodyContent {
    constructor(start: number, msg_list: Vec<MsgInfo>);
    start(): number;
    msg_list(): Vec<MsgInfo>;
    type_info(): DescTypeInfo;
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
}
export class TopicMessageListBodyContentDecoder extends BodyContentDecoder<TopicMessageListBodyContent> {
    raw_decode(buf: Uint8Array): BuckyResult<[TopicMessageListBodyContent, Uint8Array]>;
}
export class TopicMessageListDesc extends NamedObjectDesc<TopicMessageListDescContent> {
}
export class TopicMessageListDescDecoder extends NamedObjectDescDecoder<TopicMessageListDescContent> {
}
export class TopicMessageListBuilder extends NamedObjectBuilder<TopicMessageListDescContent, TopicMessageListBodyContent> {
}
export class TopicMessageListId extends NamedObjectId<TopicMessageListDescContent, TopicMessageListBodyContent> {
    constructor(id: ObjectId);
    static default(): DeviceId;
    static from_base_58(s: string): BuckyResult<DeviceId>;
    static try_from_object_id(id: ObjectId): BuckyResult<DeviceId>;
}
export class TopicMessageListIdDecoder extends NamedObjectIdDecoder<TopicMessageListDescContent, TopicMessageListBodyContent> {
    constructor();
}
export class TopicMessageList extends NamedObject<TopicMessageListDescContent, TopicMessageListBodyContent> {
    static create(topic_id: TopicId, slot: number): TopicMessageList;
    topic_message_list_id(): TopicMessageListId;
    topic_id(): TopicId;
    slot(): number;
    start(): number;
    msg_list(): Vec<MsgInfo>;
}
export class TopicMessageListDecoder extends NamedObjectDecoder<TopicMessageListDescContent, TopicMessageListBodyContent, TopicMessageList> {
    constructor();
}

export class MsgInfo implements RawEncode {
    constructor(orderd: number, seq: JSBI, msg_obj_id: ObjectId, member_id: ObjectId);
    orderd(): number;
    seq(): JSBI;
    seq_number(): number;
    msg_obj_id(): ObjectId;
    member_id(): ObjectId;
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class MsgInfoDecoder implements RawDecode<MsgInfo> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[MsgInfo, Uint8Array]>;
}
export class TopicPublishDescTypeInfo extends DescTypeInfo {
    obj_type(): number;
    sub_desc_type(): SubDescType;
}
export class TopicPublishDescContent extends DescContent {
    constructor(topic_id: TopicId, topic_owner_id: ObjectId, msg_info: MsgInfo);
    topic_id(): TopicId;
    topic_owner_id(): ObjectId;
    msg_info(): MsgInfo;
    type_info(): DescTypeInfo;
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
}
export class TopicPublishDescContentDecoder extends DescContentDecoder<TopicPublishDescContent> {
    type_info(): DescTypeInfo;
    raw_decode(buf: Uint8Array): BuckyResult<[TopicPublishDescContent, Uint8Array]>;
}
export class TopicPublishBodyContent extends BodyContent {
    constructor();
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
}
export class TopicPublishBodyContentDecoder extends BodyContentDecoder<TopicPublishBodyContent> {
    raw_decode(buf: Uint8Array): BuckyResult<[TopicPublishBodyContent, Uint8Array]>;
}
export class TopicPublishDesc extends NamedObjectDesc<TopicPublishDescContent> {
}
export class TopicPublishDescDecoder extends NamedObjectDescDecoder<TopicPublishDescContent> {
}
export class TopicPublishBuilder extends NamedObjectBuilder<TopicPublishDescContent, TopicPublishBodyContent> {
}
export class TopicPublishId extends NamedObjectId<TopicPublishDescContent, TopicPublishBodyContent> {
    constructor(id: ObjectId);
    static default(): DeviceId;
    static from_base_58(s: string): BuckyResult<DeviceId>;
    static try_from_object_id(id: ObjectId): BuckyResult<DeviceId>;
}
export class TopicPublishIdDecoder extends NamedObjectIdDecoder<TopicPublishDescContent, TopicPublishBodyContent> {
    constructor();
}
export class TopicPublish extends NamedObject<TopicPublishDescContent, TopicPublishBodyContent> {
    static create(owner_id: ObjectId, topic_id: TopicId, topic_owner_id: ObjectId, msg_info: MsgInfo): TopicPublish;
    owner_id(): ObjectId;
    topic_publish_id(): TopicPublishId;
    topic_id(): TopicId;
    topic_owner_id(): ObjectId;
    msg_info(): MsgInfo;
}
export class TopicPublishDecoder extends NamedObjectDecoder<TopicPublishDescContent, TopicPublishBodyContent, TopicPublish> {
    constructor();
}

export class TopicPublishReqDescTypeInfo extends DescTypeInfo {
    obj_type(): number;
    sub_desc_type(): SubDescType;
}
export class TopicPublishReqDescContent extends DescContent {
    constructor(topic_id: TopicId, topic_owner_id: ObjectId, member_id: ObjectId, seq: JSBI, count: number);
    topic_id(): TopicId;
    topic_owner_id(): ObjectId;
    member_id(): ObjectId;
    seq(): JSBI;
    count(): number;
    type_info(): DescTypeInfo;
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
}
export class TopicPublishReqDescContentDecoder extends DescContentDecoder<TopicPublishReqDescContent> {
    type_info(): DescTypeInfo;
    raw_decode(buf: Uint8Array): BuckyResult<[TopicPublishReqDescContent, Uint8Array]>;
}
export class TopicPublishReqBodyContent extends BodyContent {
    constructor();
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
}
export class TopicPublishReqBodyContentDecoder extends BodyContentDecoder<TopicPublishReqBodyContent> {
    raw_decode(buf: Uint8Array): BuckyResult<[TopicPublishReqBodyContent, Uint8Array]>;
}
export class TopicPublishReqDesc extends NamedObjectDesc<TopicPublishReqDescContent> {
}
export class TopicPublishReqDescDecoder extends NamedObjectDescDecoder<TopicPublishReqDescContent> {
}
export class TopicPublishReqBuilder extends NamedObjectBuilder<TopicPublishReqDescContent, TopicPublishReqBodyContent> {
}
export class TopicPublishReqId extends NamedObjectId<TopicPublishReqDescContent, TopicPublishReqBodyContent> {
    constructor(id: ObjectId);
    static default(): DeviceId;
    static from_base_58(s: string): BuckyResult<DeviceId>;
    static try_from_object_id(id: ObjectId): BuckyResult<DeviceId>;
}
export class TopicPublishReqIdDecoder extends NamedObjectIdDecoder<TopicPublishReqDescContent, TopicPublishReqBodyContent> {
    constructor();
}
export class TopicPublishReq extends NamedObject<TopicPublishReqDescContent, TopicPublishReqBodyContent> {
    static create(owner_id: ObjectId, topic_id: TopicId, topic_owner_id: ObjectId, member_id: ObjectId, seq: JSBI, count: number): TopicPublishReq;
    owner_id(): ObjectId;
    topic_publish_id(): TopicPublishReqId;
    topic_id(): TopicId;
    topic_owner_id(): ObjectId;
    member_id(): ObjectId;
    seq(): JSBI;
    count(): number;
}
export class TopicPublishReqDecoder extends NamedObjectDecoder<TopicPublishReqDescContent, TopicPublishReqBodyContent, TopicPublishReq> {
    constructor();
}

export class TopicPublishRespDescTypeInfo extends DescTypeInfo {
    obj_type(): number;
    sub_desc_type(): SubDescType;
}
export class TopicPublishRespDescContent extends DescContent {
    constructor(topic_id: TopicId, topic_owner_id: ObjectId, member_id: ObjectId, seq: JSBI);
    topic_id(): TopicId;
    topic_owner_id(): ObjectId;
    member_id(): ObjectId;
    seq(): JSBI;
    type_info(): DescTypeInfo;
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
}
export class TopicPublishRespDescContentDecoder extends DescContentDecoder<TopicPublishRespDescContent> {
    type_info(): DescTypeInfo;
    raw_decode(buf: Uint8Array): BuckyResult<[TopicPublishRespDescContent, Uint8Array]>;
}
export class TopicPublishRespBodyContent extends BodyContent {
    constructor();
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
}
export class TopicPublishRespBodyContentDecoder extends BodyContentDecoder<TopicPublishRespBodyContent> {
    raw_decode(buf: Uint8Array): BuckyResult<[TopicPublishRespBodyContent, Uint8Array]>;
}
export class TopicPublishRespDesc extends NamedObjectDesc<TopicPublishRespDescContent> {
}
export class TopicPublishRespDescDecoder extends NamedObjectDescDecoder<TopicPublishRespDescContent> {
}
export class TopicPublishRespBuilder extends NamedObjectBuilder<TopicPublishRespDescContent, TopicPublishRespBodyContent> {
}
export class TopicPublishRespId extends NamedObjectId<TopicPublishRespDescContent, TopicPublishRespBodyContent> {
    constructor(id: ObjectId);
    static default(): DeviceId;
    static from_base_58(s: string): BuckyResult<DeviceId>;
    static try_from_object_id(id: ObjectId): BuckyResult<DeviceId>;
}
export class TopicPublishRespIdDecoder extends NamedObjectIdDecoder<TopicPublishRespDescContent, TopicPublishRespBodyContent> {
    constructor();
}
export class TopicPublishResp extends NamedObject<TopicPublishRespDescContent, TopicPublishRespBodyContent> {
    static create(owner_id: ObjectId, topic_id: TopicId, topic_owner_id: ObjectId, member_id: ObjectId, seq: JSBI): TopicPublishResp;
    owner_id(): ObjectId;
    topic_publish_id(): TopicPublishRespId;
    topic_id(): TopicId;
    topic_owner_id(): ObjectId;
    member_id(): ObjectId;
    seq(): JSBI;
}
export class TopicPublishRespDecoder extends NamedObjectDecoder<TopicPublishRespDescContent, TopicPublishRespBodyContent, TopicPublishResp> {
    constructor();
}

export class SeqInfo implements RawEncode {
    constructor(offset: JSBI, start_seq: JSBI, seqs?: JSBI[]);
    info(): string;
    next(): JSBI;
    exist(seq: JSBI): boolean;
    insert_received_seq(new_seq: JSBI): BuckyResult<number>;
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
type MsgDict = Map<ObjectId, MsgInfo[]>;
export class SeqInfoDecoder implements RawDecode<SeqInfo> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[SeqInfo, Uint8Array]>;
}
interface StatusEvent {
    fetch: (msg_obj_id: ObjectId) => Promise<BuckyResult<TopicMessageList>>;
    store: (msg_obj_id: ObjectId, msg_list: Uint8Array) => Promise<BuckyResult<number>>;
}
export class TopicPublishStatusDescTypeInfo extends DescTypeInfo {
    obj_type(): number;
    sub_desc_type(): SubDescType;
}
export class TopicPublishStatusDescContent extends DescContent {
    constructor();
    type_info(): DescTypeInfo;
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
}
export class TopicPublishStatusDescContentDecoder extends DescContentDecoder<TopicPublishStatusDescContent> {
    type_info(): DescTypeInfo;
    raw_decode(buf: Uint8Array): BuckyResult<[TopicPublishStatusDescContent, Uint8Array]>;
}
export interface MemberMsg {
    msg_seq: number;
    msg_dict: MsgDict;
}
export class TopicPublishStatusBodyContent extends BodyContent {
    constructor(topic_id: TopicId, device_list: ObjectId[], msg_length?: number, msg_list?: TopicMessageList, seq_map?: BuckyHashMap<ObjectId, SeqInfo>);
    topic_id(): TopicId;
    insert_msg(msg_obj_id: ObjectId, member_id: ObjectId, event: StatusEvent): Promise<BuckyResult<number>>;
    insert_device(device_id: ObjectId, offset: number): void;
    remove_device(device_id: ObjectId): void;
    device_list(): ObjectId[];
    device_list_exclude(device_id: ObjectId): ObjectId[];
    set_msg_offset(device_id: ObjectId, offset: JSBI): void;
    insert_msg_received_seq(device_id: ObjectId, seq: number): BuckyResult<number>;
    fetch_member_msg_list(_device_id: ObjectId, seq: number, count: number, event: StatusEvent): Promise<BuckyResult<MsgInfo[]>>;
    exist_msg_seq(device_id: ObjectId, seq: number): boolean;
    get_msg_rest(trace: string, device_id: ObjectId, event: StatusEvent): Promise<MsgInfo[]>;
    append_member(trace: string, member_id: ObjectId, offset: JSBI, event: StatusEvent): Promise<MsgInfo[]>;
    append_member_msg(trace: string, topic_owner_id: ObjectId, member_id: ObjectId, msg_obj_id: ObjectId, event: StatusEvent): Promise<BuckyResult<[JSBI, BuckyHashMap<ObjectId, Vec<MsgInfo>>]>>;
    dump(_trace: string): void;
    calculate_node(index: number): [number, ObjectId, TopicMessageList];
    get(event: StatusEvent, index: number): Promise<Option<MsgInfo>>;
    range(event: StatusEvent, start: number, end: number): Promise<MsgInfo[]>;
    push(event: StatusEvent, msg: MsgInfo): Promise<BuckyResult<number>>;
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
}
export class TopicPublishStatusBodyContentDecoder extends BodyContentDecoder<TopicPublishStatusBodyContent> {
    raw_decode(buf: Uint8Array): BuckyResult<[TopicPublishStatusBodyContent, Uint8Array]>;
}
export class TopicPublishStatusDesc extends NamedObjectDesc<TopicPublishStatusDescContent> {
}
export class TopicPublishStatusDescDecoder extends NamedObjectDescDecoder<TopicPublishStatusDescContent> {
}
export class TopicPublishStatusBuilder extends NamedObjectBuilder<TopicPublishStatusDescContent, TopicPublishStatusBodyContent> {
}
export class TopicPublishStatusId extends NamedObjectId<TopicPublishStatusDescContent, TopicPublishStatusBodyContent> {
    constructor(id: ObjectId);
    static default(): DeviceId;
    static from_base_58(s: string): BuckyResult<DeviceId>;
    static try_from_object_id(id: ObjectId): BuckyResult<DeviceId>;
}
export class TopicPublishStatusIdDecoder extends NamedObjectIdDecoder<TopicPublishStatusDescContent, TopicPublishStatusBodyContent> {
    constructor();
}
export enum StatusAction {
    AppendMember = 0,
    RemoveMember = 1,
    AppendMemberMsg = 2,
    InsertMemberReceiveSeq = 3,
    FetchMemberMsgList = 4
}
export class StatusResult {
    msg_list?: MsgInfo[];
    member_msg_dict?: BuckyResult<[JSBI, BuckyHashMap<ObjectId, Vec<MsgInfo>>]>;
    result?: BuckyResult<number>;
    member_msg_list?: BuckyResult<MsgInfo[]>;
    static AppendMember(value: MsgInfo[]): StatusResult;
    static RemoveMember(value: BuckyResult<number>): StatusResult;
    static AppendMemberMsg(value: BuckyResult<[JSBI, BuckyHashMap<ObjectId, Vec<MsgInfo>>]>): StatusResult;
    static InsertMemberReceiveSeq(value: BuckyResult<number>): StatusResult;
    static FetchMemberMsgList(value: BuckyResult<MsgInfo[]>): StatusResult;
}
export class StatusRequest {
    action: StatusAction;
    topic_owner_id: ObjectId;
    member_id: Option<ObjectId>;
    msg_obj_id: Option<ObjectId>;
    offset: Option<number>;
    msg_seq: Option<number>;
    msg_start: Option<number>;
    msg_count: Option<number>;
    trace: string;
    static append_member(trace: string, topic_owner_id: ObjectId, member_id: ObjectId, offset: number): StatusRequest;
    static append_member_msg(trace: string, topic_owner_id: ObjectId, member_id: ObjectId, msg_obj_id: ObjectId): StatusRequest;
    static remove_member(trace: string, topic_owner_id: ObjectId, member_id: ObjectId): StatusRequest;
    static insert_member_receive_seq(trace: string, topic_owner_id: ObjectId, member_id: ObjectId, msg_seq: number): StatusRequest;
    static fetch_member_msg_list(trace: string, topic_owner_id: ObjectId, member_id: ObjectId, start: number, count: number): StatusRequest;
}
export class TopicPublishStatus extends NamedObject<TopicPublishStatusDescContent, TopicPublishStatusBodyContent> {
    static create(owner: ObjectId, topic_id: TopicId, init_device_list: ObjectId[]): TopicPublishStatus;
    owner_id(): ObjectId;
    topic_publish_status_id(): TopicPublishStatusId;
    device_list(): ObjectId[];
    device_list_exclude(device_id: ObjectId): ObjectId[];
    exist_msg_seq(device_id: ObjectId, seq: number): boolean;
    reduce(req: StatusRequest, event: StatusEvent): Promise<StatusResult>;
}
export class TopicPublishStatusDecoder extends NamedObjectDecoder<TopicPublishStatusDescContent, TopicPublishStatusBodyContent, TopicPublishStatus> {
    constructor();
}
export {};

export class TopicSubscribeDescTypeInfo extends DescTypeInfo {
    obj_type(): number;
    sub_desc_type(): SubDescType;
}
export class TopicSubscribeDescContent extends DescContent {
    constructor(topic_id: TopicId, topic_owner_id: ObjectId, member_id: ObjectId, msg_offset: JSBI, msg_obj_id: Option<ObjectId>);
    topic_id(): TopicId;
    topic_owner_id(): ObjectId;
    member_id(): ObjectId;
    msg_offset(): JSBI;
    msg_obj_id(): Option<ObjectId>;
    type_info(): DescTypeInfo;
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
}
export class TopicSubscribeDescContentDecoder extends DescContentDecoder<TopicSubscribeDescContent> {
    type_info(): DescTypeInfo;
    raw_decode(buf: Uint8Array): BuckyResult<[TopicSubscribeDescContent, Uint8Array]>;
}
export class TopicSubscribeBodyContent extends BodyContent {
    constructor();
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
}
export class TopicSubscribeBodyContentDecoder extends BodyContentDecoder<TopicSubscribeBodyContent> {
    raw_decode(buf: Uint8Array): BuckyResult<[TopicSubscribeBodyContent, Uint8Array]>;
}
export class TopicSubscribeDesc extends NamedObjectDesc<TopicSubscribeDescContent> {
}
export class TopicSubscribeDescDecoder extends NamedObjectDescDecoder<TopicSubscribeDescContent> {
}
export class TopicSubscribeBuilder extends NamedObjectBuilder<TopicSubscribeDescContent, TopicSubscribeBodyContent> {
}
export class TopicSubscribeId extends NamedObjectId<TopicSubscribeDescContent, TopicSubscribeBodyContent> {
    constructor(id: ObjectId);
    static default(): DeviceId;
    static from_base_58(s: string): BuckyResult<DeviceId>;
    static try_from_object_id(id: ObjectId): BuckyResult<DeviceId>;
}
export class TopicSubscribeIdDecoder extends NamedObjectIdDecoder<TopicSubscribeDescContent, TopicSubscribeBodyContent> {
    constructor();
}
export class TopicSubscribe extends NamedObject<TopicSubscribeDescContent, TopicSubscribeBodyContent> {
    static create(owner_id: ObjectId, topic_id: TopicId, topic_owner_id: ObjectId, member_id: ObjectId, msg_offset: JSBI, msg_obj_id: Option<ObjectId>): TopicSubscribe;
    owner_id(): ObjectId;
    topic_unscribe_id(): TopicSubscribeId;
    topic_id(): TopicId;
    topic_owner_id(): ObjectId;
    msg_offset(): JSBI;
    msg_obj_id(): Option<ObjectId>;
    member_id(): ObjectId;
}
export class TopicSubscribeDecoder extends NamedObjectDecoder<TopicSubscribeDescContent, TopicSubscribeBodyContent, TopicSubscribe> {
    constructor();
}

export class TopicSubscribeSuccessDescTypeInfo extends DescTypeInfo {
    obj_type(): number;
    sub_desc_type(): SubDescType;
}
export class TopicSubscribeSuccessDescContent extends DescContent {
    constructor(topic_id: TopicId, topic_owner_id: ObjectId, member_id: ObjectId, msg_seq: JSBI, msg_obj_id: Option<ObjectId>);
    topic_id(): TopicId;
    topic_owner_id(): ObjectId;
    member_id(): ObjectId;
    msg_seq(): JSBI;
    msg_obj_id(): Option<ObjectId>;
    type_info(): DescTypeInfo;
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
}
export class TopicSubscribeSuccessDescContentDecoder extends DescContentDecoder<TopicSubscribeSuccessDescContent> {
    type_info(): DescTypeInfo;
    raw_decode(buf: Uint8Array): BuckyResult<[TopicSubscribeSuccessDescContent, Uint8Array]>;
}
export class TopicSubscribeSuccessBodyContent extends BodyContent {
    constructor();
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
}
export class TopicSubscribeSuccessBodyContentDecoder extends BodyContentDecoder<TopicSubscribeSuccessBodyContent> {
    raw_decode(buf: Uint8Array): BuckyResult<[TopicSubscribeSuccessBodyContent, Uint8Array]>;
}
export class TopicSubscribeSuccessDesc extends NamedObjectDesc<TopicSubscribeSuccessDescContent> {
}
export class TopicSubscribeSuccessDescDecoder extends NamedObjectDescDecoder<TopicSubscribeSuccessDescContent> {
}
export class TopicSubscribeSuccessBuilder extends NamedObjectBuilder<TopicSubscribeSuccessDescContent, TopicSubscribeSuccessBodyContent> {
}
export class TopicSubscribeSuccessId extends NamedObjectId<TopicSubscribeSuccessDescContent, TopicSubscribeSuccessBodyContent> {
    constructor(id: ObjectId);
    static default(): DeviceId;
    static from_base_58(s: string): BuckyResult<DeviceId>;
    static try_from_object_id(id: ObjectId): BuckyResult<DeviceId>;
}
export class TopicSubscribeSuccessIdDecoder extends NamedObjectIdDecoder<TopicSubscribeSuccessDescContent, TopicSubscribeSuccessBodyContent> {
    constructor();
}
export class TopicSubscribeSuccess extends NamedObject<TopicSubscribeSuccessDescContent, TopicSubscribeSuccessBodyContent> {
    static create(owner_id: ObjectId, topic_id: TopicId, topic_owner_id: ObjectId, member_id: ObjectId, msg_seq: JSBI, msg_obj_id: Option<ObjectId>): TopicSubscribeSuccess;
    owner_id(): ObjectId;
    topic_unscribe_id(): TopicSubscribeSuccessId;
    topic_id(): TopicId;
    topic_owner_id(): ObjectId;
    msg_seq(): JSBI;
    msg_obj_id(): Option<ObjectId>;
    member_id(): ObjectId;
}
export class TopicSubscribeSuccessDecoder extends NamedObjectDecoder<TopicSubscribeSuccessDescContent, TopicSubscribeSuccessBodyContent, TopicSubscribeSuccess> {
    constructor();
}

export class TopicUnsubscribeDescTypeInfo extends DescTypeInfo {
    obj_type(): number;
    sub_desc_type(): SubDescType;
}
export class TopicUnsubscribeDescContent extends DescContent {
    constructor(topic_id: TopicId, topic_owner_id: ObjectId, member_id: ObjectId, msg_obj_id: Option<ObjectId>);
    topic_id(): TopicId;
    topic_owner_id(): ObjectId;
    member_id(): ObjectId;
    msg_obj_id(): Option<ObjectId>;
    type_info(): DescTypeInfo;
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
}
export class TopicUnsubscribeDescContentDecoder extends DescContentDecoder<TopicUnsubscribeDescContent> {
    type_info(): DescTypeInfo;
    raw_decode(buf: Uint8Array): BuckyResult<[TopicUnsubscribeDescContent, Uint8Array]>;
}
export class TopicUnsubscribeBodyContent extends BodyContent {
    constructor();
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
}
export class TopicUnsubscribeBodyContentDecoder extends BodyContentDecoder<TopicUnsubscribeBodyContent> {
    raw_decode(buf: Uint8Array): BuckyResult<[TopicUnsubscribeBodyContent, Uint8Array]>;
}
export class TopicUnsubscribeDesc extends NamedObjectDesc<TopicUnsubscribeDescContent> {
}
export class TopicUnsubscribeDescDecoder extends NamedObjectDescDecoder<TopicUnsubscribeDescContent> {
}
export class TopicUnsubscribeBuilder extends NamedObjectBuilder<TopicUnsubscribeDescContent, TopicUnsubscribeBodyContent> {
}
export class TopicUnsubscribeId extends NamedObjectId<TopicUnsubscribeDescContent, TopicUnsubscribeBodyContent> {
    constructor(id: ObjectId);
    static default(): DeviceId;
    static from_base_58(s: string): BuckyResult<DeviceId>;
    static try_from_object_id(id: ObjectId): BuckyResult<DeviceId>;
}
export class TopicUnsubscribeIdDecoder extends NamedObjectIdDecoder<TopicUnsubscribeDescContent, TopicUnsubscribeBodyContent> {
    constructor();
}
export class TopicUnsubscribe extends NamedObject<TopicUnsubscribeDescContent, TopicUnsubscribeBodyContent> {
    static create(owner_id: ObjectId, topic_id: TopicId, topic_owner_id: ObjectId, member_id: ObjectId, msg_obj_id: Option<ObjectId>): TopicUnsubscribe;
    owner_id(): ObjectId;
    topic_unscribe_id(): TopicUnsubscribeId;
    topic_id(): TopicId;
    topic_owner_id(): ObjectId;
    msg_obj_id(): Option<ObjectId>;
    member_id(): ObjectId;
}
export class TopicUnsubscribeDecoder extends NamedObjectDecoder<TopicUnsubscribeDescContent, TopicUnsubscribeBodyContent, TopicUnsubscribe> {
    constructor();
}

export class TopicUnsubscribeSuccessDescTypeInfo extends DescTypeInfo {
    obj_type(): number;
    sub_desc_type(): SubDescType;
}
export class TopicUnsubscribeSuccessDescContent extends DescContent {
    constructor(topic_id: TopicId, topic_owner_id: ObjectId, member_id: ObjectId, msg_obj_id: Option<ObjectId>);
    topic_id(): TopicId;
    topic_owner_id(): ObjectId;
    member_id(): ObjectId;
    msg_obj_id(): Option<ObjectId>;
    type_info(): DescTypeInfo;
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
}
export class TopicUnsubscribeSuccessDescContentDecoder extends DescContentDecoder<TopicUnsubscribeSuccessDescContent> {
    type_info(): DescTypeInfo;
    raw_decode(buf: Uint8Array): BuckyResult<[TopicUnsubscribeSuccessDescContent, Uint8Array]>;
}
export class TopicUnsubscribeSuccessBodyContent extends BodyContent {
    constructor();
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
}
export class TopicUnsubscribeSuccessBodyContentDecoder extends BodyContentDecoder<TopicUnsubscribeSuccessBodyContent> {
    raw_decode(buf: Uint8Array): BuckyResult<[TopicUnsubscribeSuccessBodyContent, Uint8Array]>;
}
export class TopicUnsubscribeSuccessDesc extends NamedObjectDesc<TopicUnsubscribeSuccessDescContent> {
}
export class TopicUnsubscribeSuccessDescDecoder extends NamedObjectDescDecoder<TopicUnsubscribeSuccessDescContent> {
}
export class TopicUnsubscribeSuccessBuilder extends NamedObjectBuilder<TopicUnsubscribeSuccessDescContent, TopicUnsubscribeSuccessBodyContent> {
}
export class TopicUnsubscribeSuccessId extends NamedObjectId<TopicUnsubscribeSuccessDescContent, TopicUnsubscribeSuccessBodyContent> {
    constructor(id: ObjectId);
    static default(): DeviceId;
    static from_base_58(s: string): BuckyResult<DeviceId>;
    static try_from_object_id(id: ObjectId): BuckyResult<DeviceId>;
}
export class TopicUnsubscribeSuccessIdDecoder extends NamedObjectIdDecoder<TopicUnsubscribeSuccessDescContent, TopicUnsubscribeSuccessBodyContent> {
    constructor();
}
export class TopicUnsubscribeSuccess extends NamedObject<TopicUnsubscribeSuccessDescContent, TopicUnsubscribeSuccessBodyContent> {
    static create(owner_id: ObjectId, topic_id: TopicId, topic_owner_id: ObjectId, member_id: ObjectId, msg_obj_id: Option<ObjectId>): TopicUnsubscribeSuccess;
    owner_id(): ObjectId;
    topic_unscribe_id(): TopicUnsubscribeSuccessId;
    topic_id(): TopicId;
    topic_owner_id(): ObjectId;
    msg_obj_id(): Option<ObjectId>;
    member_id(): ObjectId;
}
export class TopicUnsubscribeSuccessDecoder extends NamedObjectDecoder<TopicUnsubscribeSuccessDescContent, TopicUnsubscribeSuccessBodyContent, TopicUnsubscribeSuccess> {
    constructor();
}

export class ZoneDescTypeInfo extends DescTypeInfo {
    obj_type(): number;
    sub_desc_type(): SubDescType;
}
export class ZoneDescContent extends ProtobufDescContent<protos.IZoneDescContent> {
    constructor(owner: ObjectId);
    type_info(): DescTypeInfo;
    try_to_proto(): BuckyResult<protos.IZoneDescContent>;
    owner(): ObjectId;
}
export class ZoneDescContentDecoder extends ProtobufDescContentDecoder<ZoneDescContent, protos.IZoneDescContent> {
    constructor();
    type_info(): DescTypeInfo;
    try_from_proto(value: protos.IZoneDescContent): BuckyResult<ZoneDescContent>;
}
export class ZoneBodyContent extends ProtobufBodyContent<protos.IZoneBodyContent> {
    constructor(ood_list: DeviceId[], known_device_list: DeviceId[]);
    ood_list(): DeviceId[];
    known_device_list(): DeviceId[];
    try_to_proto(): BuckyResult<protos.IZoneBodyContent>;
}
export class ZoneBodyContentDecoder extends ProtobufBodyContentDecoder<ZoneBodyContent, protos.IZoneBodyContent> {
    constructor();
    try_from_proto(value: protos.IZoneBodyContent): BuckyResult<ZoneBodyContent>;
}
export class ZoneDesc extends NamedObjectDesc<ZoneDescContent> {
}
export class ZoneDescDecoder extends NamedObjectDescDecoder<ZoneDescContent> {
}
export class ZoneBuilder extends NamedObjectBuilder<ZoneDescContent, ZoneBodyContent> {
}
export class ZoneId extends NamedObjectId<ZoneDescContent, ZoneBodyContent> {
    constructor(id: ObjectId);
    static default(): DeviceId;
    static from_base_58(s: string): BuckyResult<DeviceId>;
    static try_from_object_id(id: ObjectId): BuckyResult<DeviceId>;
}
export class ZoneIdDecoder extends NamedObjectIdDecoder<ZoneDescContent, ZoneBodyContent> {
    constructor();
}
export class Zone extends NamedObject<ZoneDescContent, ZoneBodyContent> {
    static create(owner: ObjectId, ood_list: DeviceId[], known_device_list: DeviceId[]): Zone;
    owner(): ObjectId;
    ood_list(): DeviceId[];
    known_device_list(): DeviceId[];
    zone_id(): ZoneId;
}
export class ZoneDecoder extends NamedObjectDecoder<ZoneDescContent, ZoneBodyContent, Zone> {
    constructor();
}

export const APPLIST_APP_CATEGORY: string;
export const APPLIST_SERVICE_CATEGORY: string;
export class AppListDescTypeInfo extends DescTypeInfo {
    obj_type(): number;
    sub_desc_type(): SubDescType;
}
export class AppListDescContent extends ProtobufDescContent<protos.IAppListDescContent> {
    id: string;
    category: string;
    constructor(id: string, category: string);
    type_info(): DescTypeInfo;
    try_to_proto(): BuckyResult<protos.IAppListDescContent>;
}
export class AppListDescContentDecoder extends ProtobufDescContentDecoder<AppListDescContent, protos.IAppListDescContent> {
    constructor();
    type_info(): DescTypeInfo;
    try_from_proto(value: protos.IAppListDescContent): BuckyResult<AppListDescContent>;
}
export class AppListBodyContent extends ProtobufBodyContent<protos.IAppListContent> {
    app_list: BuckyHashMap<DecAppId, AppStatus>;
    constructor(apps: BuckyHashMap<DecAppId, AppStatus>);
    try_to_proto(): BuckyResult<protos.IAppListContent>;
}
export class AppListBodyContentDecoder extends ProtobufBodyContentDecoder<AppListBodyContent, protos.IAppListContent> {
    constructor();
    try_from_proto(value: protos.IAppListContent): BuckyResult<AppListBodyContent>;
}
export class AppListDesc extends NamedObjectDesc<AppListDescContent> {
}
export class AppListDescDecoder extends NamedObjectDescDecoder<AppListDescContent> {
}
export class AppListBuilder extends NamedObjectBuilder<AppListDescContent, AppListBodyContent> {
}
export class AppListId extends NamedObjectId<AppListDescContent, AppListBodyContent> {
    constructor(id: ObjectId);
    static default(): AppListId;
    static from_base_58(s: string): BuckyResult<AppListId>;
    static try_from_object_id(id: ObjectId): BuckyResult<AppListId>;
}
export class AppListIdDecoder extends NamedObjectIdDecoder<AppListDescContent, AppListBodyContent> {
    constructor();
}
export class AppList extends NamedObject<AppListDescContent, AppListBodyContent> {
    static create(owner: ObjectId, id: string, category: string): AppList;
    put(app: AppStatus): void;
    remove(id: DecAppId): void;
    clear(): void;
    app_list(): Map<DecAppId, AppStatus>;
    exists(id: DecAppId): boolean;
}
export class AppListDecoder extends NamedObjectDecoder<AppListDescContent, AppListBodyContent, AppList> {
    constructor();
    static create(): AppListDecoder;
}

export class AppStatusDescTypeInfo extends DescTypeInfo {
    obj_type(): number;
    sub_desc_type(): SubDescType;
}
export class AppStatusDescContent extends ProtobufDescContent<protos.IAppStatusDescContent> {
    id: DecAppId;
    constructor(id: DecAppId);
    type_info(): DescTypeInfo;
    try_to_proto(): BuckyResult<protos.IAppStatusDescContent>;
}
export class AppStatusDescContentDecoder extends ProtobufDescContentDecoder<AppStatusDescContent, protos.IAppStatusDescContent> {
    constructor();
    type_info(): DescTypeInfo;
    try_from_proto(value: protos.IAppStatusDescContent): BuckyResult<AppStatusDescContent>;
}
export class AppStatusBodyContent extends ProtobufBodyContent<protos.IAppStatusContent> {
    version: string;
    status: number;
    constructor(version: string, status: number);
    try_to_proto(): BuckyResult<protos.IAppStatusContent>;
}
export class AppStatusBodyContentDecoder extends ProtobufBodyContentDecoder<AppStatusBodyContent, protos.IAppStatusContent> {
    constructor();
    try_from_proto(value: protos.IAppStatusContent): BuckyResult<AppStatusBodyContent>;
}
export class AppStatusDesc extends NamedObjectDesc<AppStatusDescContent> {
}
export class AppStatusDescDecoder extends NamedObjectDescDecoder<AppStatusDescContent> {
}
export class AppStatusBuilder extends NamedObjectBuilder<AppStatusDescContent, AppStatusBodyContent> {
}
export class AppStatusId extends NamedObjectId<AppStatusDescContent, AppStatusBodyContent> {
    constructor(id: ObjectId);
    static default(): AppStatusId;
    static from_base_58(s: string): BuckyResult<AppStatusId>;
    static try_from_object_id(id: ObjectId): BuckyResult<AppStatusId>;
}
export class AppStatusIdDecoder extends NamedObjectIdDecoder<AppStatusDescContent, AppStatusBodyContent> {
    constructor();
}
export class AppStatus extends NamedObject<AppStatusDescContent, AppStatusBodyContent> {
    static create(owner: ObjectId, id: DecAppId, version: string, status: boolean): AppStatus;
    app_id(): DecAppId;
    version(): string;
    status(): boolean;
}
export class AppStatusDecoder extends NamedObjectDecoder<AppStatusDescContent, AppStatusBodyContent, AppStatus> {
    constructor();
    static create(): AppStatusDecoder;
}

export class AppLocalStatusDescTypeInfo extends DescTypeInfo {
    obj_type(): number;
    sub_desc_type(): SubDescType;
}
export class AppLocalStatusDesc extends ProtobufDescContent<protos.IAppLocalStatusDesc> {
    id: DecAppId;
    constructor(id: DecAppId);
    type_info(): DescTypeInfo;
    try_to_proto(): BuckyResult<protos.IAppLocalStatusDesc>;
}
export class AppLocalStatusDescDecoder extends ProtobufDescContentDecoder<AppLocalStatusDesc, protos.IAppLocalStatusDesc> {
    constructor();
    type_info(): DescTypeInfo;
    try_from_proto(value: protos.IAppLocalStatusDesc): BuckyResult<AppLocalStatusDesc>;
}
export enum AppLocalStatusCode {
    Stop = 0,
    Prepare = 1,
    Installing = 2,
    Running = 3,
    InstallFailed = 4,
    RunFailed = 5,
    NoService = 6,
    ErrStatus = 255
}
export class AppLocalStatusBodyContent extends ProtobufBodyContent<protos.IAppLocalStatusBody> {
    web_dir?: DirId;
    status: AppLocalStatusCode;
    constructor(status: AppLocalStatusCode, web_dir?: DirId);
    try_to_proto(): BuckyResult<protos.IAppLocalStatusBody>;
}
export class AppLocalStatusBodyContentDecoder extends ProtobufBodyContentDecoder<AppLocalStatusBodyContent, protos.IAppLocalStatusBody> {
    constructor();
    try_from_proto(value: protos.IAppLocalStatusBody): BuckyResult<AppLocalStatusBodyContent>;
}
export class AppLocalStatusBuilder extends NamedObjectBuilder<AppLocalStatusDesc, AppLocalStatusBodyContent> {
}
export class AppLocalStatusId extends NamedObjectId<AppLocalStatusDesc, AppLocalStatusBodyContent> {
    constructor(id: ObjectId);
    static default(): AppLocalStatusId;
    static from_base_58(s: string): BuckyResult<AppLocalStatusId>;
    static try_from_object_id(id: ObjectId): BuckyResult<AppLocalStatusId>;
}
export class AppLocalStatusIdDecoder extends NamedObjectIdDecoder<AppLocalStatusDesc, AppLocalStatusBodyContent> {
    constructor();
}
export class AppLocalStatus extends NamedObject<AppLocalStatusDesc, AppLocalStatusBodyContent> {
    static create(owner: ObjectId, id: DecAppId): AppLocalStatus;
    app_id(): DecAppId;
    webdir(): DirId | undefined;
    status(): AppLocalStatusCode;
}
export class AppLocalStatusDecoder extends NamedObjectDecoder<AppLocalStatusDesc, AppLocalStatusBodyContent, AppLocalStatus> {
    constructor();
    static create(): AppLocalStatusDecoder;
}

export class AppStoreListDescTypeInfo extends DescTypeInfo {
    obj_type(): number;
    sub_desc_type(): SubDescType;
}
export class AppStoreListDescContent extends DescContent {
    constructor();
    type_info(): DescTypeInfo;
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
}
export class AppStoreListDescContentDecoder extends DescContentDecoder<AppStoreListDescContent> {
    type_info(): DescTypeInfo;
    raw_decode(buf: Uint8Array): BuckyResult<[AppStoreListDescContent, Uint8Array]>;
}
export class AppStoreListBodyContent extends ProtobufBodyContent<protos.IAppStoreListBodyContent> {
    app_store_list: BuckyHashSet<DecAppId>;
    constructor(list: BuckyHashSet<DecAppId>);
    try_to_proto(): BuckyResult<protos.IAppStoreListBodyContent>;
}
export class AppStoreListBodyContentDecoder extends ProtobufBodyContentDecoder<AppStoreListBodyContent, protos.IAppStoreListBodyContent> {
    constructor();
    try_from_proto(value: protos.IAppStoreListBodyContent): BuckyResult<AppStoreListBodyContent>;
}
export class AppStoreListDesc extends NamedObjectDesc<AppStoreListDescContent> {
}
export class AppStoreListDescDecoder extends NamedObjectDescDecoder<AppStoreListDescContent> {
}
export class AppStoreListBuilder extends NamedObjectBuilder<AppStoreListDescContent, AppStoreListBodyContent> {
}
export class AppStoreListId extends NamedObjectId<AppStoreListDescContent, AppStoreListBodyContent> {
    constructor(id: ObjectId);
    static default(): AppStoreListId;
    static from_base_58(s: string): BuckyResult<AppStoreListId>;
    static try_from_object_id(id: ObjectId): BuckyResult<AppStoreListId>;
}
export class AppStoreListIdDecoder extends NamedObjectIdDecoder<AppStoreListDescContent, AppStoreListBodyContent> {
    constructor();
}
export class AppStoreList extends NamedObject<AppStoreListDescContent, AppStoreListBodyContent> {
    static create(owner: ObjectId): AppStoreList;
    put(id: DecAppId): void;
    remove(id: DecAppId): void;
    clear(): void;
    app_list(): DecAppId[];
}
export class AppStoreListDecoder extends NamedObjectDecoder<AppStoreListDescContent, AppStoreListBodyContent, AppStoreList> {
    constructor();
    static create(): AppStoreListDecoder;
}

export class DecAppDescTypeInfo extends DescTypeInfo {
    obj_type(): number;
    sub_desc_type(): SubDescType;
}
export class DecAppDescContent extends ProtobufDescContent<protos.IDecAppDescContent> {
    id: string;
    constructor(id: string);
    type_info(): DescTypeInfo;
    try_to_proto(): BuckyResult<protos.IDecAppDescContent>;
}
export class DecAppDescContentDecoder extends ProtobufDescContentDecoder<DecAppDescContent, protos.IDecAppDescContent> {
    constructor();
    type_info(): DescTypeInfo;
    try_from_proto(value: protos.IDecAppDescContent): BuckyResult<DecAppDescContent>;
}
export class DecAppBodyContent extends ProtobufBodyContent<protos.IDecAppContent> {
    source: BuckyHashMap<BuckyString, ObjectId>;
    icon: Option<BuckyString>;
    desc: Option<BuckyString>;
    source_desc: BuckyHashMap<BuckyString, BuckyString>;
    tags: BuckyHashMap<BuckyString, BuckyString>;
    constructor(source: BuckyHashMap<BuckyString, ObjectId>, icon: Option<BuckyString>, desc: Option<BuckyString>, source_desc: BuckyHashMap<BuckyString, BuckyString>, tags: BuckyHashMap<BuckyString, BuckyString>);
    try_to_proto(): BuckyResult<protos.IDecAppContent>;
}
export class DecAppBodyContentDecoder extends ProtobufBodyContentDecoder<DecAppBodyContent, protos.IDecAppContent> {
    constructor();
    try_from_proto(value: protos.IDecAppContent): BuckyResult<DecAppBodyContent>;
}
export class DecAppDesc extends NamedObjectDesc<DecAppDescContent> {
}
export class DecAppDescDecoder extends NamedObjectDescDecoder<DecAppDescContent> {
}
export class DecAppBuilder extends NamedObjectBuilder<DecAppDescContent, DecAppBodyContent> {
}
export class DecAppId extends NamedObjectId<DecAppDescContent, DecAppBodyContent> {
    constructor(id: ObjectId);
    static default(): DecAppId;
    static from_base_58(s: string): BuckyResult<DecAppId>;
    static try_from_object_id(id: ObjectId): BuckyResult<DecAppId>;
}
export class DecAppIdDecoder extends NamedObjectIdDecoder<DecAppDescContent, DecAppBodyContent> {
    constructor();
}
export class DecApp extends NamedObject<DecAppDescContent, DecAppBodyContent> {
    static create(owner: ObjectId, id: string): DecApp;
    name(): string;
    set_icon(icon: string | undefined): void;
    icon(): string | undefined;
    set_app_desc(desc: string | undefined): void;
    app_desc(): string | undefined;
    find_source_desc(version: string): BuckyResult<string>;
    find_source(version: string): BuckyResult<ObjectId>;
    remove_source(version: string): void;
    set_source(version: string, source: ObjectId, desc: Option<string>): void;
    source(): BuckyHashMap<BuckyString, ObjectId>;
    find_tag(tag: string): BuckyResult<string>;
    remove_tag(tag: string): void;
    set_tag(tag: string, version: string): void;
    tags(): BuckyHashMap<BuckyString, BuckyString>;
    static generate_id(owner: ObjectId, id: string): ObjectId;
}
export class DecAppDecoder extends NamedObjectDecoder<DecAppDescContent, DecAppBodyContent, DecApp> {
    constructor();
    static create(): DecAppDecoder;
}

export class PutAppDescTypeInfo extends DescTypeInfo {
    obj_type(): number;
    sub_desc_type(): SubDescType;
}
export class PutAppDescContent extends ProtobufDescContent<protos.IPutAppDescContent> {
    constructor(apps: AppStatus[]);
    type_info(): DescTypeInfo;
    try_to_proto(): BuckyResult<protos.IPutAppDescContent>;
}
export class PutAppDescContentDecoder extends ProtobufDescContentDecoder<PutAppDescContent, protos.IPutAppDescContent> {
    constructor();
    type_info(): DescTypeInfo;
    try_from_proto(value: protos.IPutAppDescContent): BuckyResult<PutAppDescContent>;
}
export class PutAppBodyContent extends BodyContent {
    constructor();
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
}
export class PutAppBodyContentDecoder extends BodyContentDecoder<PutAppBodyContent> {
    raw_decode(buf: Uint8Array): BuckyResult<[PutAppBodyContent, Uint8Array]>;
}
export class PutAppDesc extends NamedObjectDesc<PutAppDescContent> {
}
export class PutAppDescDecoder extends NamedObjectDescDecoder<PutAppDescContent> {
}
export class PutAppBuilder extends NamedObjectBuilder<PutAppDescContent, PutAppBodyContent> {
}
export class PutAppId extends NamedObjectId<PutAppDescContent, PutAppBodyContent> {
    constructor(id: ObjectId);
    static default(): PutAppId;
    static from_base_58(s: string): BuckyResult<PutAppId>;
    static try_from_object_id(id: ObjectId): BuckyResult<PutAppId>;
}
export class PutAppIdDecoder extends NamedObjectIdDecoder<PutAppDescContent, PutAppBodyContent> {
    constructor();
}
export class PutApp extends NamedObject<PutAppDescContent, PutAppBodyContent> {
    static create(owner: ObjectId, apps: AppStatus[]): PutApp;
}
export class PutAppDecoder extends NamedObjectDecoder<PutAppDescContent, PutAppBodyContent, PutApp> {
    constructor();
    static create(): PutAppDecoder;
}

export class RemoveAppDescTypeInfo extends DescTypeInfo {
    obj_type(): number;
    sub_desc_type(): SubDescType;
}
export class RemoveAppDescContent extends ProtobufDescContent<protos.IRemoveAppDescContent> {
    constructor(apps: DecAppId[]);
    type_info(): DescTypeInfo;
    try_to_proto(): BuckyResult<protos.IRemoveAppDescContent>;
}
export class RemoveAppDescContentDecoder extends ProtobufDescContentDecoder<RemoveAppDescContent, protos.IRemoveAppDescContent> {
    constructor();
    type_info(): DescTypeInfo;
    try_from_proto(value: protos.IRemoveAppDescContent): BuckyResult<RemoveAppDescContent>;
}
export class RemoveAppBodyContent extends BodyContent {
    constructor();
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
}
export class RemoveAppBodyContentDecoder extends BodyContentDecoder<RemoveAppBodyContent> {
    raw_decode(buf: Uint8Array): BuckyResult<[RemoveAppBodyContent, Uint8Array]>;
}
export class RemoveAppDesc extends NamedObjectDesc<RemoveAppDescContent> {
}
export class RemoveAppDescDecoder extends NamedObjectDescDecoder<RemoveAppDescContent> {
}
export class RemoveAppBuilder extends NamedObjectBuilder<RemoveAppDescContent, RemoveAppBodyContent> {
}
export class RemoveAppId extends NamedObjectId<RemoveAppDescContent, RemoveAppBodyContent> {
    constructor(id: ObjectId);
    static default(): RemoveAppId;
    static from_base_58(s: string): BuckyResult<RemoveAppId>;
    static try_from_object_id(id: ObjectId): BuckyResult<RemoveAppId>;
}
export class RemoveAppIdDecoder extends NamedObjectIdDecoder<RemoveAppDescContent, RemoveAppBodyContent> {
    constructor();
}
export class RemoveApp extends NamedObject<RemoveAppDescContent, RemoveAppBodyContent> {
    static create(owner: ObjectId, apps: DecAppId[]): RemoveApp;
}
export class RemoveAppDecoder extends NamedObjectDecoder<RemoveAppDescContent, RemoveAppBodyContent, RemoveApp> {
    constructor();
    static create(): RemoveAppDecoder;
}

export class AppExtInfoDescTypeInfo extends DescTypeInfo {
    obj_type(): number;
    sub_desc_type(): SubDescType;
}
export class AppExtInfoDescContent extends ProtobufDescContent<protos.IAppExtInfoDescContent> {
    id: string;
    constructor(id: string);
    type_info(): DescTypeInfo;
    try_to_proto(): BuckyResult<protos.IAppExtInfoDescContent>;
}
export class AppExtInfoDescContentDecoder extends ProtobufDescContentDecoder<AppExtInfoDescContent, protos.IAppExtInfoDescContent> {
    constructor();
    type_info(): DescTypeInfo;
    try_from_proto(value: protos.IAppExtInfoDescContent): BuckyResult<AppExtInfoDescContent>;
}
export class AppExtInfoBodyContent extends ProtobufBodyContent<protos.IAppExtInfoBodyContent> {
    info: string;
    constructor(info: string);
    try_to_proto(): BuckyResult<protos.IAppExtInfoBodyContent>;
}
export class AppExtInfoBodyContentDecoder extends ProtobufBodyContentDecoder<AppExtInfoBodyContent, protos.IAppExtInfoBodyContent> {
    constructor();
    try_from_proto(value: protos.IAppExtInfoBodyContent): BuckyResult<AppExtInfoBodyContent>;
}
export class AppExtInfoDesc extends NamedObjectDesc<AppExtInfoDescContent> {
}
export class AppExtInfoDescDecoder extends NamedObjectDescDecoder<AppExtInfoDescContent> {
}
export class AppExtInfoBuilder extends NamedObjectBuilder<AppExtInfoDescContent, AppExtInfoBodyContent> {
}
export class AppExtInfoId extends NamedObjectId<AppExtInfoDescContent, AppExtInfoBodyContent> {
    constructor(id: ObjectId);
    static default(): AppExtInfoId;
    static from_base_58(s: string): BuckyResult<AppExtInfoId>;
    static try_from_object_id(id: ObjectId): BuckyResult<AppExtInfoId>;
}
export class AppExtInfoIdDecoder extends NamedObjectIdDecoder<AppExtInfoDescContent, AppExtInfoBodyContent> {
    constructor();
}
export class AppExtInfo extends NamedObject<AppExtInfoDescContent, AppExtInfoBodyContent> {
    static create(owner: ObjectId, id: string): AppExtInfo;
    static getExtId(app: DecApp): ObjectId;
    info(): string;
    set_info(info: string): void;
}
export class AppExtInfoDecoder extends NamedObjectDecoder<AppExtInfoDescContent, AppExtInfoBodyContent, AppExtInfo> {
    constructor();
    static create(): AppExtInfoDecoder;
}

export class NFTListDescTypeInfo extends DescTypeInfo {
    obj_type(): number;
    sub_desc_type(): SubDescType;
}
export class NFTListDescContent extends DescContent {
    constructor();
    type_info(): DescTypeInfo;
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
}
export class NFTListDescContentDecoder extends DescContentDecoder<NFTListDescContent> {
    type_info(): DescTypeInfo;
    raw_decode(buf: Uint8Array): BuckyResult<[NFTListDescContent, Uint8Array]>;
}
export class NFTListBodyContent extends BodyContent {
    obj_list: BuckyHashMap<ObjectId, BuckyString>;
    constructor(list: BuckyHashMap<ObjectId, BuckyString>);
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
}
export class NFTListBodyContentDecoder extends BodyContentDecoder<NFTListBodyContent> {
    raw_decode(buf: Uint8Array): BuckyResult<[NFTListBodyContent, Uint8Array]>;
}
export class NFTListDesc extends NamedObjectDesc<NFTListDescContent> {
}
export class NFTListDescDecoder extends NamedObjectDescDecoder<NFTListDescContent> {
}
export class NFTListBuilder extends NamedObjectBuilder<NFTListDescContent, NFTListBodyContent> {
}
export class NFTListId extends NamedObjectId<NFTListDescContent, NFTListBodyContent> {
    constructor(id: ObjectId);
    static default(): NFTListId;
    static from_base_58(s: string): BuckyResult<NFTListId>;
    static try_from_object_id(id: ObjectId): BuckyResult<NFTListId>;
}
export class NFTListIdDecoder extends NamedObjectIdDecoder<NFTListDescContent, NFTListBodyContent> {
    constructor();
}
export class NFTList extends NamedObject<NFTListDescContent, NFTListBodyContent> {
    static create(owner: ObjectId): NFTList;
    put(id: ObjectId, comment: BuckyString): void;
    remove(id: ObjectId): void;
    clear(): void;
    obj_list(): Map<ObjectId, BuckyString>;
}
export class NFTListDecoder extends NamedObjectDecoder<NFTListDescContent, NFTListBodyContent, NFTList> {
    constructor();
    static create(): NFTListDecoder;
}

export class AddFriendDescTypeInfo extends DescTypeInfo {
    obj_type(): number;
    sub_desc_type(): SubDescType;
}
export class AddFriendDescContent extends ProtobufDescContent<protos.IAddFriendDescContent> {
    to: PeopleId;
    try_to_proto(): BuckyResult<protos.IAddFriendDescContent>;
    constructor(to: PeopleId);
    type_info(): DescTypeInfo;
}
export class AddFriendDescContentDecoder extends ProtobufDescContentDecoder<AddFriendDescContent, protos.IAddFriendDescContent> {
    constructor();
    try_from_proto(value: protos.IAddFriendDescContent): BuckyResult<AddFriendDescContent>;
    type_info(): DescTypeInfo;
}
export class AddFriendDesc extends NamedObjectDesc<AddFriendDescContent> {
}
export class AddFriendDescDecoder extends NamedObjectDescDecoder<AddFriendDescContent> {
}
export class AddFriendBuilder extends NamedObjectBuilder<AddFriendDescContent, EmptyProtobufBodyContent> {
}
export class AddFriendId extends NamedObjectId<AddFriendDescContent, EmptyProtobufBodyContent> {
    constructor(id: ObjectId);
    static default(): AddFriendId;
    static from_base_58(s: string): BuckyResult<AddFriendId>;
    static try_from_object_id(id: ObjectId): BuckyResult<AddFriendId>;
}
export class AddFriendIdDecoder extends NamedObjectIdDecoder<AddFriendDescContent, EmptyProtobufBodyContent> {
    constructor();
}
export class AddFriend extends NamedObject<AddFriendDescContent, EmptyProtobufBodyContent> {
    static create(owner: PeopleId, to: PeopleId): AddFriend;
    to(): PeopleId;
}
export class AddFriendDecoder extends NamedObjectDecoder<AddFriendDescContent, EmptyProtobufBodyContent, AddFriend> {
    constructor();
}

export class RemoveFriendDescTypeInfo extends DescTypeInfo {
    obj_type(): number;
    sub_desc_type(): SubDescType;
}
export class RemoveFriendDescContent extends ProtobufDescContent<protos.IRemoveFriendDescContent> {
    to: PeopleId;
    try_to_proto(): BuckyResult<protos.IRemoveFriendDescContent>;
    constructor(to: PeopleId);
    type_info(): DescTypeInfo;
}
export class RemoveFriendDescContentDecoder extends ProtobufDescContentDecoder<RemoveFriendDescContent, protos.IRemoveFriendDescContent> {
    constructor();
    try_from_proto(value: protos.IRemoveFriendDescContent): BuckyResult<RemoveFriendDescContent>;
    type_info(): DescTypeInfo;
}
export class RemoveFriendDesc extends NamedObjectDesc<RemoveFriendDescContent> {
}
export class RemoveFriendDescDecoder extends NamedObjectDescDecoder<RemoveFriendDescContent> {
}
export class RemoveFriendBuilder extends NamedObjectBuilder<RemoveFriendDescContent, EmptyProtobufBodyContent> {
}
export class RemoveFriendId extends NamedObjectId<RemoveFriendDescContent, EmptyProtobufBodyContent> {
    constructor(id: ObjectId);
    static default(): RemoveFriendId;
    static from_base_58(s: string): BuckyResult<RemoveFriendId>;
    static try_from_object_id(id: ObjectId): BuckyResult<RemoveFriendId>;
}
export class RemoveFriendIdDecoder extends NamedObjectIdDecoder<RemoveFriendDescContent, EmptyProtobufBodyContent> {
    constructor();
}
export class RemoveFriend extends NamedObject<RemoveFriendDescContent, EmptyProtobufBodyContent> {
    static create(owner: PeopleId, to: PeopleId): RemoveFriend;
    to(): PeopleId;
}
export class RemoveFriendDecoder extends NamedObjectDecoder<RemoveFriendDescContent, EmptyProtobufBodyContent, RemoveFriend> {
    constructor();
}

export class FriendOptionDescTypeInfo extends DescTypeInfo {
    obj_type(): number;
    sub_desc_type(): SubDescType;
}
export class FriendOptionDescContent extends ProtobufDescContent<base_protos.IEmptyContent> {
    try_to_proto(): BuckyResult<base_protos.IEmptyContent>;
    constructor();
    type_info(): DescTypeInfo;
}
export class FriendOptionDescContentDecoder extends ProtobufDescContentDecoder<FriendOptionDescContent, base_protos.IEmptyContent> {
    constructor();
    try_from_proto(value: base_protos.IEmptyContent): BuckyResult<FriendOptionDescContent>;
    type_info(): DescTypeInfo;
}
export class FriendOptionBodyContent extends ProtobufBodyContent<protos.IFriendOptionContent> {
    auto_confirm?: boolean | undefined;
    msg?: string | undefined;
    constructor(auto_confirm?: boolean | undefined, msg?: string | undefined);
    try_to_proto(): BuckyResult<protos.IFriendOptionContent>;
}
export class FriendOptionBodyContentDecoder extends ProtobufBodyContentDecoder<FriendOptionBodyContent, protos.IFriendOptionContent> {
    constructor();
    try_from_proto(value: protos.IFriendOptionContent): BuckyResult<FriendOptionBodyContent>;
}
export class FriendOptionDesc extends NamedObjectDesc<FriendOptionDescContent> {
}
export class FriendOptionDescDecoder extends NamedObjectDescDecoder<FriendOptionDescContent> {
}
export class FriendOptionBuilder extends NamedObjectBuilder<FriendOptionDescContent, FriendOptionBodyContent> {
}
export class FriendOptionId extends NamedObjectId<FriendOptionDescContent, FriendOptionBodyContent> {
    constructor(id: ObjectId);
    static default(): FriendOptionId;
    static from_base_58(s: string): BuckyResult<FriendOptionId>;
    static try_from_object_id(id: ObjectId): BuckyResult<FriendOptionId>;
}
export class FriendOptionIdDecoder extends NamedObjectIdDecoder<FriendOptionDescContent, FriendOptionBodyContent> {
    constructor();
}
export class FriendOption extends NamedObject<FriendOptionDescContent, FriendOptionBodyContent> {
    static create(owner: PeopleId, auto_confirm?: boolean, msg?: string): FriendOption;
}
export class FriendOptionDecoder extends NamedObjectDecoder<FriendOptionDescContent, FriendOptionBodyContent, FriendOption> {
    constructor();
}

export class MsgDescTypeInfo extends DescTypeInfo {
    obj_type(): number;
    sub_desc_type(): SubDescType;
}
export class MsgObjectContent {
    id: ObjectId;
    name: string;
    constructor(id: ObjectId, name: string);
}
export class MsgContent {
    static Text(text: string): MsgContent;
    static Object(object: MsgObjectContent): MsgContent;
    match<T>(visitor: {
        Text?: (text: string) => T;
        Object?: (object: MsgObjectContent) => T;
    }): T | undefined;
}
export class MsgDescContent extends ProtobufDescContent<protos.IMsgDescContent> {
    to: ObjectId;
    content: MsgContent;
    constructor(to: ObjectId, content: MsgContent);
    try_to_proto(): BuckyResult<protos.IMsgDescContent>;
    type_info(): DescTypeInfo;
}
export class MsgDescContentDecoder extends ProtobufDescContentDecoder<MsgDescContent, protos.IMsgDescContent> {
    constructor();
    try_from_proto(value: protos.IMsgDescContent): BuckyResult<MsgDescContent>;
    type_info(): DescTypeInfo;
}
export class MsgDesc extends NamedObjectDesc<MsgDescContent> {
}
export class MsgDescDecoder extends NamedObjectDescDecoder<MsgDescContent> {
}
export class MsgBuilder extends NamedObjectBuilder<MsgDescContent, EmptyProtobufBodyContent> {
}
export class MsgId extends NamedObjectId<MsgDescContent, EmptyProtobufBodyContent> {
    constructor(id: ObjectId);
    static default(): MsgId;
    static from_base_58(s: string): BuckyResult<MsgId>;
    static try_from_object_id(id: ObjectId): BuckyResult<MsgId>;
}
export class MsgIdDecoder extends NamedObjectIdDecoder<MsgDescContent, EmptyProtobufBodyContent> {
    constructor();
}
export class Msg extends NamedObject<MsgDescContent, EmptyProtobufBodyContent> {
    static create(owner: PeopleId, to: ObjectId, content: MsgContent): Msg;
    to(): ObjectId;
    content(): MsgContent;
    belongs(id: ObjectId): boolean;
}
export class MsgDecoder extends NamedObjectDecoder<MsgDescContent, EmptyProtobufBodyContent, Msg> {
    constructor();
}

export enum CoreObjectType {
    Zone = 32,
    Storage = 40,
    Text = 41,
    FriendList = 130,
    Topic = 150,
    TopicSubscribe = 151,
    TopicSubscribeSuccess = 152,
    TopicUnsubscribe = 153,
    TopicUnsubscribeSuccess = 154,
    TopicPublishStatus = 155,
    TopicPublish = 156,
    TopicPublishReq = 157,
    TopicPublishResp = 158,
    TopicMessageList = 159,
    BlockV1 = 300,
    MetaProto = 301,
    MetaMinerGroup = 302,
    BlockV2 = 303,
    DecApp = 400,
    AppStatus = 401,
    AppList = 402,
    PutApp = 403,
    RemoveApp = 404,
    AppStoreList = 405,
    AppExtInfo = 406,
    DefaultAppList = 407,
    SetDefaultApp = 408,
    AppLocalStatus = 409,
    NFTList = 500,
    PerfOperation = 600,
    AddFriend = 1001,
    FriendOption = 1002,
    Msg = 1003,
    RemoveFriend = 1004,
    ErrObjType = 32767
}
export function number_2_core_object_type(x: number): CoreObjectType;
export function number_2_core_object_name(x: number): string;

export interface MetaResult<T> {
    err: number;
    msg: string;
    result: T;
}
export interface RawTxInfo {
    create_time: number;
    nonce: number;
    caller: string;
    gas_coin_id: number;
    gas_price: number;
    max_fee: number;
    result: number;
    use_fee: number;
    to: [string, number, number][];
    block_number: number;
    block_hash: number;
    block_create_time: number;
}
export interface RawTxRecord {
    hash: string;
    number: number;
    from: string;
    to: string;
    coin_id: number;
    value: number;
    desc: string;
}
export interface RawBlock {
    height: number;
    block_hash: string;
    create_time: number;
    tx_list: RawTxInfo[];
}
export interface MetaStatus {
    version: number;
    height: number;
    gas_price: {
        low: number;
        medium: number;
        high: number;
    };
}
export interface Erc20TransferRequest {
    tx_hash?: string;
    start_number?: number;
    end_number?: number;
    from?: string;
    to?: string;
}
export interface Erc20TransferResult {
    address: string;
    tx_hash: string;
    from: string;
    to: string;
    value: number;
    height: number;
    gas_price: number;
    create_time: number;
    result: number;
}
export enum MetaMinerTarget {
    Dev = 0,
    Test = 1,
    Formal = 2
}
export function get_meta_miner_host(target: MetaMinerTarget): string;
export function get_meta_spv_host(target: MetaMinerTarget): string;
export function meta_target_from_str(target?: string): MetaMinerTarget | undefined;
export function get_meta_client(target: MetaMinerTarget): MetaClient;
export function create_meta_client(target_str?: string, spv_str?: string): MetaClient;
export class MetaClient {
    constructor(meta_url: string, meta_spv_url: string);
    stringToUint8Array(str: string): Uint8Array;
    getSpvStatus(): Promise<MetaResult<MetaStatus> | null>;
    getPaymentTxList(address_list: string[], offset: number, length: number, start_block: number | null | undefined, end_block: number | null | undefined, coin_id_list: string[]): Promise<MetaResult<RawTxRecord[]> | null>;
    getCollectTxList(address_list: string[], offset: number, length: number, start_block: number | null | undefined, end_block: number | null | undefined, coin_id_list: string[]): Promise<MetaResult<RawTxRecord[]> | null>;
    getTxList(address_list: string[], offset: number, length: number, start_block: number | null | undefined, end_block: number | null | undefined, coin_id_list: string[]): Promise<MetaResult<RawTxRecord[]> | null>;
    getBlocksByRange(start_block: number, end_block: number): Promise<MetaResult<RawBlock[] | null>>;
    getFileRewardAmount(address: string): Promise<MetaResult<number>>;
    getErc20TransferList(address: string, query: Erc20TransferRequest): Promise<MetaResult<Erc20TransferResult>>;
    getTx(txId: string): Promise<MetaResult<RawTxInfo> | null>;
    getBalance(coidId: number, accountId: string): Promise<MetaResult<number> | null>;
    getBalances(list: [number, string][]): Promise<MetaResult<number[]> | null>;
    getChainStatus(): Promise<MetaResult<MetaStatus> | null>;
    view_request(view: ViewRequest): Promise<BuckyResult<ViewResponse>>;
    getDesc(id: ObjectId): Promise<BuckyResult<SavedMetaObject>>;
    getBalance2(id: ObjectId, coinId: number): Promise<BuckyResult<JSBI>>;
    getRawData(id: ObjectId): Promise<BuckyResult<Uint8Array>>;
    getChainViewStatus(): Promise<BuckyResult<ChainStatus>>;
    getName(name: string): Promise<BuckyResult<Option<ViewNameResultItem>>>;
    getReceipt(id: TxId): Promise<BuckyResult<Option<[Receipt, number]>>>;
    get_nonce(id: ObjectId): Promise<BuckyResult<JSBI>>;
    create_desc(owner: StandardObject, desc: SavedMetaObject, v: JSBI, price: number, coin_id: number, secret: PrivateKey): Promise<BuckyResult<TxId>>;
    update_desc(owner: StandardObject, desc: SavedMetaObject, price: Option<number>, coin_id: Option<number>, secret: PrivateKey): Promise<BuckyResult<TxId>>;
    trans_balance(from: StandardObject, to: ObjectId, v: JSBI, coin_id: number, secret: PrivateKey): Promise<BuckyResult<TxId>>;
    withdraw_from_file(caller: StandardObject, file_id: ObjectId, v: JSBI, coin_id: number, secret: PrivateKey): Promise<BuckyResult<TxId>>;
    create_contract(caller: StandardObject, secret: PrivateKey, value: JSBI, init_data: Uint8Array, gas_price: number, max_fee: number): Promise<BuckyResult<TxId>>;
    call_contract(caller: StandardObject, secret: PrivateKey, address: ObjectId, value: JSBI, data: Uint8Array, gas_price: number, max_fee: number): Promise<BuckyResult<TxId>>;
    view_contract(address: ObjectId, data: Uint8Array): Promise<BuckyResult<ViewContractResult>>;
    get_logs(address: ObjectId, topics: (Uint8Array | null)[], from: number, to: number): Promise<BuckyResult<ViewLogResult>>;
}

export abstract class BaseRequestor {
    abstract remote_addr(): string;
    abstract request(req: HttpRequest): Promise<BuckyResult<Response>>;
}
export class HttpRequestor extends BaseRequestor {
    constructor(service_url: string);
    remote_addr(): string;
    request(req: HttpRequest): Promise<BuckyResult<Response>>;
}
export class WSHttpRequestor extends BaseRequestor {
    constructor(service_url: string);
    remote_addr(): string;
    request(req: HttpRequest): Promise<BuckyResult<Response>>;
}
export class RequestorHelper {
    static decode_str_body<T>(resp: Response, from_str: (s: string) => T): Promise<BuckyResult<T>>;
    static decode_header<T>(resp: Response, name: string, from_str: (s: string) => T): BuckyResult<T>;
    static decode_optional_header<T>(resp: Response, name: string, from_str: (s: string) => T): BuckyResult<Option<T>>;
    static decode_optional_headers<T>(resp: Response, name: string, from_str: (s: string) => T): BuckyResult<Option<T[]>>;
    static trans_status_code(code: number): BuckyErrorCode;
    static insert_device_list_header(http_req: HttpRequest, device_list: DeviceId[]): void;
    static error_from_resp(resp: Response): Promise<BuckyError>;
}

export class HttpRequest {
    url: string;
    init: RequestInit;
    constructor(method: string, url: string);
    insert_header(name: string, value: string): void;
    set_body(buf: Uint8Array): void;
    set_string_body(str: string): void;
    set_json_body(object: any): void;
}

export const NON_STACK_HTTP_URL: string;
export const NON_STACK_WS_URL: string;
export const RUNTIME_NON_STACK_HTTP_URL: string;
export const RUNTIME_NON_STACK_WS_URL: string;
export enum NONProtocol {
    Native = "native",
    Meta = "meta",
    Sync = "sync",
    HttpBdt = "http-bdt",
    HttpLocal = "http-local",
    DatagramBdt = "datagram-bdt",
    DataBdt = "data-bdt"
}
export enum ObjectProtocol {
    Local = "local",
    Meta = "meta",
    HttpBdt = "http_bdt",
    Http = "http",
    DatagramBdt = "datagram_bdt"
}
export const ROUTER_WS_EVENT_CMD_ADD = 1;
export const ROUTER_WS_EVENT_CMD_REMOVE = 2;
export const ROUTER_WS_EVENT_CMD_EVENT = 3;
export const ROUTER_WS_HANDLER_CMD_ADD = 11;
export const ROUTER_WS_HANDLER_CMD_REMOVE = 12;
export const ROUTER_WS_HANDLER_CMD_EVENT = 13;
export const HTTP_CMD_REQUEST = 21;

export class SelectTimeRange {
    begin?: JSBI | undefined;
    end?: JSBI | undefined;
    constructor(begin?: JSBI | undefined, end?: JSBI | undefined);
    toString(): string;
    static fromString(s: string): BuckyResult<SelectTimeRange>;
}
export interface SelectFilter {
    obj_type?: number;
    obj_type_code?: ObjectTypeCode;
    dec_id?: ObjectId;
    owner_id?: ObjectId;
    author_id?: ObjectId;
    create_time?: SelectTimeRange;
    update_time?: SelectTimeRange;
    insert_time?: SelectTimeRange;
    flags?: number;
}
export class SelectOption {
    page_size: number;
    page_index: number;
}
export class SelectEncoder {
    constructor(serviceURL: string);
    encode_select_request(req: SelectFilter, opt: Option<SelectOption>): HttpRequest;
}
export class SelectResponseObjectInfo {
    size: number;
    insert_time: JSBI;
    object?: AnyNamedObject;
    object_raw?: Uint8Array;
    constructor(size: number, insert_time: JSBI);
    static decode_meta_info(o: any): BuckyResult<SelectResponseObjectInfo>;
    bind_object(buf: Uint8Array): BuckyResult<void>;
}
export class SelectResponse {
    objects: SelectResponseObjectInfo[];
    constructor(objects?: SelectResponseObjectInfo[]);
    static from_response(resp: Response): Promise<BuckyResult<SelectResponse>>;
}
export class SelectTimeRangeJsonCodec extends JsonCodec<SelectTimeRange> {
    encode_object(param: SelectTimeRange): any;
    decode_object(o: any): BuckyResult<SelectTimeRange>;
}
export class SelectFilterJsonCodec extends JsonCodec<SelectFilter> {
    time_range_codec: SelectTimeRangeJsonCodec;
    constructor();
    encode_object(param: SelectFilter): any;
    decode_object(o: any): BuckyResult<SelectFilter>;
}
export class SelectOptionJsonCodec extends JsonCodec<SelectOption> {
}
export class SelectResponseObjectInfoJsonCodec extends JsonCodec<SelectResponseObjectInfo> {
    encode_object(param: SelectResponseObjectInfo): any;
    decode_object(o: any): BuckyResult<SelectResponseObjectInfo>;
}
export class SelectOptionCodec {
    static encode(req: HttpRequest, opt?: SelectOption): void;
}
export class SelectFilterUrlCodec {
    static encode(url: string, filter: SelectFilter): string;
}

export interface JsonCodecBase<T> {
    encode_string(param: T): string;
    decode_string(s: string): BuckyResult<T>;
}
export abstract class JsonCodec<T> implements JsonCodecBase<T> {
    encode_object(param: T): any;
    encode_string(param: T): string;
    decode_object(o: any): BuckyResult<T>;
    decode_string(s: string): BuckyResult<T>;
}
export class JsonCodecHelper {
    static decode_number(o: any): BuckyResult<number>;
    static decode_big_int(o: any): BuckyResult<JSBI>;
    static decode_hex_to_buffer(o: any): BuckyResult<Uint8Array>;
}
export class BuckyErrorJsonCodec extends JsonCodec<BuckyError> {
    encode_object(param: BuckyError): any;
    decode_object(o: any): BuckyResult<BuckyError>;
}
export class BuckyResultJsonCodec<T> extends JsonCodec<BuckyResult<T>> {
    constructor(codec: JsonCodec<T>);
    encode_object(param: BuckyResult<T>): any;
    decode_object(o: any): BuckyResult<BuckyResult<T>>;
}

export const CYFS_ROUTER_REQUEST_FLAG_FLUSH: number;
export const CYFS_REQUEST_FLAG_DELETE_WITH_QUERY: number;
export const CYFS_REQUEST_FLAG_LIST_DIR: number;

export enum ZoneDirection {
    LocalToLocal = "local_to_local",
    LocalToRemote = "local_to_remote",
    RemoteToLocal = "remote_to_local"
}
export interface RouterEventResponse {
    err: number;
    msg?: string;
}
export class RouterEventResponseJsonCodec extends JsonCodec<RouterEventResponse> {
    decode_object(o: any): BuckyResult<RouterEventResponse>;
}

export enum NDNAction {
    PutData = "put-data",
    GetData = "get-data",
    DeleteData = "delete-data"
}
export enum NDNAPILevel {
    NDC = "ndc",
    NDN = "ndn",
    Router = "router"
}
export enum NDNPutDataResult {
    Accept = "Accept",
    AlreadyExists = "AlreadyExists"
}
export class NDNDataRefererObject {
    object_id: ObjectId;
    inner_path?: string | undefined;
    constructor(object_id: ObjectId, inner_path?: string | undefined);
    toString(): string;
    toJSON(): string;
}
export class NDNDataRefererObjectJsonCodec extends JsonCodec<NDNDataRefererObject> {
    constructor();
    decode_object(o: any): BuckyResult<NDNDataRefererObject>;
}

export interface NDNInputRequestCommon {
    req_path?: string;
    dec_id?: ObjectId;
    source: DeviceId;
    protocol: NONProtocol;
    level: NDNAPILevel;
    referer_object: NDNDataRefererObject[];
    target?: ObjectId;
    flags: number;
    user_data?: any;
}
export class NDNInputRequestCommonJsonCodec extends JsonCodec<NDNInputRequestCommon> {
    constructor(user_data_codec?: JsonCodec<any> | undefined);
    encode_object(param: NDNInputRequestCommon): any;
    decode_object(o: any): BuckyResult<NDNInputRequestCommon>;
}
export interface NDNGetDataInputRequest {
    common: NDNInputRequestCommon;
    object_id: ObjectId;
    inner_path?: string;
}
export class NDNGetDataInputRequestJsonCodec extends JsonCodec<NDNGetDataInputRequest> {
    constructor(common_user_data_codec?: JsonCodec<any> | undefined);
    encode_object(param: NDNGetDataInputRequest): any;
    decode_object(o: any): BuckyResult<NDNGetDataInputRequest>;
}
export interface NDNGetDataInputResponse {
    object_id: ObjectId;
    attr?: Attributes;
    length: number;
    data: Uint8Array;
}
export class NDNGetDataInputResponseJsonCodec extends JsonCodec<NDNGetDataInputResponse> {
    constructor();
    encode_object(param: NDNGetDataInputResponse): any;
    decode_object(o: any): BuckyResult<NDNGetDataInputResponse>;
}
export interface NDNPutDataInputRequest {
    common: NDNInputRequestCommon;
    object_id: ObjectId;
    length: number;
    data: Uint8Array;
}
export class NDNPutDataInputRequestJsonCodec extends JsonCodec<NDNPutDataInputRequest> {
    constructor(common_user_data_codec?: JsonCodec<any> | undefined);
    encode_object(param: NDNPutDataInputRequest): any;
    decode_object(o: any): BuckyResult<NDNPutDataInputRequest>;
}
export interface NDNPutDataInputResponse {
    result: NDNPutDataResult;
}
export class NDNPutDataInputResponseJsonCodec extends JsonCodec<NDNPutDataInputResponse> {
}
export interface NDNDeleteDataInputRequest {
    common: NDNInputRequestCommon;
    object_id: ObjectId;
    inner_path?: string;
}
export class NDNDeleteDataInputRequestJsonCodec extends JsonCodec<NDNDeleteDataInputRequest> {
    constructor(common_user_data_codec?: JsonCodec<any> | undefined);
    encode_object(param: NDNDeleteDataInputRequest): any;
    decode_object(o: any): BuckyResult<NDNDeleteDataInputRequest>;
}
export interface NDNDeleteDataInputResponse {
    object_id: ObjectId;
}
export class NDNDeleteDataInputResponseJsonCodec extends JsonCodec<NDNDeleteDataInputResponse> {
    constructor();
    encode_object(param: NDNDeleteDataInputResponse): any;
    decode_object(o: any): BuckyResult<NDNDeleteDataInputResponse>;
}

export interface NDNOutputRequestCommon {
    req_path?: string;
    dec_id?: ObjectId;
    level: NDNAPILevel;
    target?: ObjectId;
    referer_object: NDNDataRefererObject[];
    flags: number;
}
export class NDNOutputRequestCommonJsonCodec extends JsonCodec<NDNOutputRequestCommon> {
    constructor();
    decode_object(o: any): BuckyResult<NDNOutputRequestCommon>;
}
export interface NDNPutDataOutputRequest {
    common: NDNOutputRequestCommon;
    object_id: ObjectId;
    length: number;
    data: Uint8Array;
}
export class NDNPutDataOutputRequestJsonCodec extends JsonCodec<NDNPutDataOutputRequest> {
    constructor();
    encode_object(param: NDNPutDataOutputRequest): any;
    decode_object(o: any): BuckyResult<NDNPutDataOutputRequest>;
}
export interface NDNPutDataOutputRequestWithBuffer {
    common: NDNOutputRequestCommon;
    object_id: ObjectId;
    data: Uint8Array;
}
export class NDNPutDataOutputRequestWithBufferJsonCodec extends JsonCodec<NDNPutDataOutputRequestWithBuffer> {
    constructor();
    encode_object(param: NDNPutDataOutputRequestWithBuffer): any;
    decode_object(o: any): BuckyResult<NDNPutDataOutputRequestWithBuffer>;
}
export interface NDNPutDataOutputResponse {
    result: NDNPutDataResult;
}
export class NDNPutDataOutputResponseJsonCodec extends JsonCodec<NDNPutDataOutputResponse> {
}
export interface NDNGetDataOutputRequest {
    common: NDNOutputRequestCommon;
    object_id: ObjectId;
    inner_path?: string;
}
export class NDNGetDataOutputRequestJsonCodec extends JsonCodec<NDNGetDataOutputRequest> {
    constructor();
    encode_object(param: NDNGetDataOutputRequest): any;
    decode_object(o: any): BuckyResult<NDNGetDataOutputRequest>;
}
export interface NDNGetDataOutputResponse {
    object_id: ObjectId;
    attr?: Attributes;
    length: number;
    data: Uint8Array;
}
export class NDNGetDataOutputResponseJsonCodec extends JsonCodec<NDNGetDataOutputResponse> {
    constructor();
    encode_object(param: NDNGetDataOutputResponse): any;
    decode_object(o: any): BuckyResult<NDNGetDataOutputResponse>;
}
export interface NDNDeleteDataOutputRequest {
    common: NDNOutputRequestCommon;
    object_id: ObjectId;
    inner_path?: string;
}
export class NDNDeleteDataOutputRequestJsonCodec extends JsonCodec<NDNDeleteDataOutputRequest> {
    constructor();
    encode_object(param: NDNDeleteDataOutputRequest): any;
    decode_object(o: any): BuckyResult<NDNDeleteDataOutputRequest>;
}
export interface NDNDeleteDataOutputResponse {
    object_id: ObjectId;
}
export class NDNDeleteDataOutputResponseJsonCodec extends JsonCodec<NDNDeleteDataOutputResponse> {
    constructor();
    encode_object(param: NDNDeleteDataOutputResponse): any;
    decode_object(o: any): BuckyResult<NDNDeleteDataOutputResponse>;
}

export type NDNRequestCommon = NDNOutputRequestCommon;
export type NDNPutDataRequest = NDNPutDataOutputRequest;
export type NDNPutDataResponse = NDNPutDataOutputResponse;
export type NDNGetDataRequest = NDNGetDataOutputRequest;
export type NDNGetDataResponse = NDNGetDataOutputResponse;
export type NDNDeleteDataRequest = NDNDeleteDataOutputRequest;
export type NDNDeleteDataResponse = NDNDeleteDataOutputResponse;

export class NDNRequestor {
    service_url: string;
    constructor(requestor: BaseRequestor, dec_id?: ObjectId | undefined);
    format_url(req_path: string | undefined, object_id: ObjectId, inner_path?: string): string;
    encode_common_headers(action: NDNAction, com_req: NDNOutputRequestCommon, http_req: HttpRequest): void;
    encode_common_headers_to_query(action: NDNAction, com_req: NDNOutputRequestCommon): string;
    encode_put_data_request(req: NDNPutDataOutputRequest): HttpRequest;
    decode_put_data_response(resp: Response): Promise<BuckyResult<NDNPutDataOutputResponse>>;
    put_data(req: NDNPutDataOutputRequest): Promise<BuckyResult<NDNPutDataOutputResponse>>;
    prepare_download_data(req: NDNGetDataOutputRequest): string;
    get_data(req: NDNGetDataOutputRequest): Promise<BuckyResult<NDNGetDataOutputResponse>>;
    encode_delete_data_request(req: NDNDeleteDataOutputRequest): HttpRequest;
    decode_delete_data_response(resp: Response): Promise<BuckyResult<NDNDeleteDataOutputResponse>>;
    delete_data(req: NDNDeleteDataOutputRequest): Promise<BuckyResult<NDNDeleteDataOutputResponse>>;
}

export enum NONDataType {
    Object = 0,
    Data = 1
}
export enum NONAction {
    PutObject = "put-object",
    GetObject = "get-object",
    PostObject = "post-object",
    SelectObject = "select-object",
    DeleteObject = "delete-object"
}
export enum NONAPILevel {
    NOC = "noc",
    NON = "non",
    Router = "router"
}
export enum NONPutObjectResult {
    Accept = "Accept",
    AcceptWithSign = "AcceptWithSign",
    AlreadyExists = "AlreadyExists",
    Updated = "Updated",
    Merged = "Merged"
}
export class NONObjectInfo {
    object_id: ObjectId;
    object_raw: Uint8Array;
    object?: AnyNamedObject | undefined;
    constructor(object_id: ObjectId, object_raw: Uint8Array, object?: AnyNamedObject | undefined);
    static new_from_object_raw(object_raw: Uint8Array): BuckyResult<NONObjectInfo>;
    decode(): BuckyResult<null>;
    try_decode(): BuckyResult<null>;
    get_update_time(): BuckyResult<JSBI>;
    get_expired_time(): BuckyResult<Option<JSBI>>;
    verify(): BuckyResult<null>;
    decode_and_verify(): BuckyResult<null>;
}
export class NONObjectInfoJsonCodec extends JsonCodec<NONObjectInfo> {
    constructor();
    encode_object(param: NONObjectInfo): any;
    decode_object(o: any): BuckyResult<NONObjectInfo>;
}
export class NONSlimObjectInfo {
    object_id: ObjectId;
    object_raw?: Uint8Array | undefined;
    object?: AnyNamedObject | undefined;
    constructor(object_id: ObjectId, object_raw?: Uint8Array | undefined, object?: AnyNamedObject | undefined);
    decode(): BuckyResult<null>;
    verify(): BuckyResult<null>;
    decode_and_verify(): BuckyResult<null>;
}
export class NONSlimObjectInfoJsonCodec extends JsonCodec<NONSlimObjectInfo> {
    constructor();
    encode_object(param: NONSlimObjectInfo): any;
    decode_object(o: any): BuckyResult<NONSlimObjectInfo>;
}

export interface NONInputRequestCommon {
    req_path?: string;
    dec_id?: ObjectId;
    source: DeviceId;
    protocol: NONProtocol;
    level: NONAPILevel;
    target?: ObjectId;
    flags: number;
}
export class NONInputRequestCommonJsonCodec extends JsonCodec<NONInputRequestCommon> {
    constructor();
    decode_object(o: any): BuckyResult<NONInputRequestCommon>;
}
export interface NONGetObjectInputRequest {
    common: NONInputRequestCommon;
    object_id: ObjectId;
    inner_path?: string;
}
export class NONGetObjectInputRequestJsonCodec extends JsonCodec<NONGetObjectInputRequest> {
    constructor();
    decode_object(o: any): BuckyResult<NONGetObjectInputRequest>;
}
export interface NONGetObjectInputResponse {
    object_update_time?: JSBI;
    object_expires_time?: JSBI;
    object: NONObjectInfo;
}
export class NONGetObjectInputResponseJsonCodec extends JsonCodec<NONGetObjectInputResponse> {
    constructor();
    encode_object(param: NONGetObjectInputResponse): any;
    decode_object(o: any): BuckyResult<NONGetObjectInputResponse>;
}
export interface NONPutObjectInputRequest {
    common: NONInputRequestCommon;
    object: NONObjectInfo;
}
export class NONPutObjectInputRequestJsonCodec extends JsonCodec<NONPutObjectInputRequest> {
    constructor();
    encode_object(param: NONPutObjectInputRequest): any;
    decode_object(o: any): BuckyResult<NONPutObjectInputRequest>;
}
export interface NONPutObjectInputResponse {
    result: NONPutObjectResult;
    object_update_time?: JSBI;
    object_expires_time?: JSBI;
}
export class NONPutObjectInputResponseJsonCodec extends JsonCodec<NONPutObjectInputResponse> {
    constructor();
    encode_object(param: NONPutObjectInputResponse): any;
    decode_object(o: any): BuckyResult<NONPutObjectInputResponse>;
}
export interface NONPostObjectInputRequest {
    common: NONInputRequestCommon;
    object: NONObjectInfo;
}
export class NONPostObjectInputRequestJsonCodec extends JsonCodec<NONPostObjectInputRequest> {
    constructor();
    encode_object(param: NONPostObjectInputRequest): any;
    decode_object(o: any): BuckyResult<NONPostObjectInputRequest>;
}
export interface NONPostObjectInputResponse {
    object: NONObjectInfo;
}
export class NONPostObjectInputResponseJsonCodec extends JsonCodec<NONPostObjectInputResponse> {
    constructor();
    encode_object(param: NONPostObjectInputResponse): any;
    decode_object(o: any): BuckyResult<NONPostObjectInputResponse>;
}
export interface NONSelectObjectInputRequest {
    common: NONInputRequestCommon;
    filter: SelectFilter;
    opt?: SelectOption;
}
export class NONSelectObjectInputRequestJsonCodec extends JsonCodec<NONSelectObjectInputRequest> {
    constructor();
    encode_object(param: NONSelectObjectInputRequest): any;
    decode_object(o: any): BuckyResult<NONSelectObjectInputRequest>;
}
export interface NONSelectObjectInputResponse {
    objects: SelectResponseObjectInfo[];
}
export class NONSelectObjectInputResponseJsonCodec extends JsonCodec<NONSelectObjectInputResponse> {
    constructor();
    encode_object(param: NONSelectObjectInputResponse): any;
    decode_object(o: any): BuckyResult<NONSelectObjectInputResponse>;
}
export interface NONDeleteObjectInputRequest {
    common: NONInputRequestCommon;
    object_id: ObjectId;
    inner_path?: string;
}
export class NONDeleteObjectInputRequestJsonCodec extends JsonCodec<NONDeleteObjectInputRequest> {
    constructor();
    encode_object(param: NONDeleteObjectInputRequest): any;
    decode_object(o: any): BuckyResult<NONDeleteObjectInputRequest>;
}
export interface NONDeleteObjectInputResponse {
    object?: NONObjectInfo;
}
export class NONDeleteObjectInputResponseJsonCodec extends JsonCodec<NONDeleteObjectInputResponse> {
    constructor();
    encode_object(param: NONDeleteObjectInputResponse): any;
    decode_object(o: any): BuckyResult<NONDeleteObjectInputResponse>;
}

export interface NONOutputRequestCommon {
    req_path?: string;
    dec_id?: ObjectId;
    level: NONAPILevel;
    target?: ObjectId;
    flags: number;
}
export class NONOutputRequestCommonJsonCodec extends JsonCodec<NONOutputRequestCommon> {
    constructor();
    decode_object(o: any): BuckyResult<NONOutputRequestCommon>;
}
export interface NONPutObjectOutputRequest {
    common: NONOutputRequestCommon;
    object: NONObjectInfo;
}
export class NONPutObjectOutputRequestJsonCodec extends JsonCodec<NONPutObjectOutputRequest> {
    constructor();
    encode_object(param: NONPutObjectOutputRequest): any;
    decode_object(o: any): BuckyResult<NONPutObjectOutputRequest>;
}
export interface NONPutObjectOutputResponse {
    result: NONPutObjectResult;
    object_update_time?: JSBI;
    object_expires_time?: JSBI;
}
export class NONPutObjectOutputResponseJsonCodec extends JsonCodec<NONPutObjectOutputResponse> {
    constructor();
    encode_object(param: NONPutObjectOutputResponse): any;
    decode_object(o: any): BuckyResult<NONPutObjectOutputResponse>;
}
export interface NONGetObjectOutputRequest {
    common: NONOutputRequestCommon;
    object_id: ObjectId;
    inner_path?: string;
}
export class NONGetObjectOutputRequestJsonCodec extends JsonCodec<NONGetObjectOutputRequest> {
    constructor();
    decode_object(o: any): BuckyResult<NONGetObjectOutputRequest>;
}
export interface NONGetObjectOutputResponse {
    object_update_time?: JSBI;
    object_expires_time?: JSBI;
    object: NONObjectInfo;
}
export class NONGetObjectOutputResponseJsonCodec extends JsonCodec<NONGetObjectOutputResponse> {
    constructor();
    encode_object(param: NONGetObjectOutputResponse): any;
    decode_object(o: any): BuckyResult<NONGetObjectOutputResponse>;
}
export interface NONPostObjectOutputRequest {
    common: NONOutputRequestCommon;
    object: NONObjectInfo;
}
export class NONPostObjectOutputRequestJsonCodec extends JsonCodec<NONPostObjectOutputRequest> {
    constructor();
    encode_object(param: NONPostObjectOutputRequest): any;
    decode_object(o: any): BuckyResult<NONPostObjectOutputRequest>;
}
export interface NONPostObjectOutputResponse {
    object: NONObjectInfo;
}
export class NONPostObjectOutputResponseJsonCodec extends JsonCodec<NONPostObjectOutputResponse> {
    constructor();
    encode_object(param: NONPostObjectOutputResponse): any;
    decode_object(o: any): BuckyResult<NONPostObjectOutputResponse>;
}
export interface NONSelectObjectOutputRequest {
    common: NONOutputRequestCommon;
    filter: SelectFilter;
    opt?: SelectOption;
}
export class NONSelectObjectOutputRequestJsonCodec extends JsonCodec<NONSelectObjectOutputRequest> {
    constructor();
    encode_object(param: NONSelectObjectOutputRequest): any;
    decode_object(o: any): BuckyResult<NONSelectObjectOutputRequest>;
}
export interface NONSelectObjectOutputResponse {
    objects: SelectResponseObjectInfo[];
}
export class NONSelectObjectOutputResponseJsonCodec extends JsonCodec<NONSelectObjectOutputResponse> {
    constructor();
    encode_object(param: NONSelectObjectOutputResponse): any;
    decode_object(o: any): BuckyResult<NONSelectObjectOutputResponse>;
}
export interface NONDeleteObjectOutputRequest {
    common: NONOutputRequestCommon;
    object_id: ObjectId;
    inner_path?: string;
}
export class NONDeleteObjectOutputRequestJsonCodec extends JsonCodec<NONDeleteObjectOutputRequest> {
    constructor();
    encode_object(param: NONDeleteObjectOutputRequest): any;
    decode_object(o: any): BuckyResult<NONDeleteObjectOutputRequest>;
}
export interface NONDeleteObjectOutputResponse {
    object?: NONObjectInfo;
}
export class NONDeleteObjectOutputResponseJsonCodec extends JsonCodec<NONDeleteObjectOutputResponse> {
    constructor();
    encode_object(param: NONDeleteObjectOutputResponse): any;
    decode_object(o: any): BuckyResult<NONDeleteObjectOutputResponse>;
}

export type NONRequestCommon = NONOutputRequestCommon;
export type NONGetObjectRequest = NONGetObjectOutputRequest;
export type NONGetObjectResponse = NONGetObjectOutputResponse;
export type NONPutObjectRequest = NONPutObjectOutputRequest;
export type NONPutObjectResponse = NONPutObjectOutputResponse;
export type NONPostObjectRequest = NONPostObjectOutputRequest;
export type NONPostObjectResponse = NONPostObjectOutputResponse;
export type NONSelectObjectRequest = NONSelectObjectOutputRequest;
export type NONSelectObjectResponse = NONSelectObjectOutputResponse;
export type NONDeleteObjectRequest = NONDeleteObjectOutputRequest;
export type NONDeleteObjectResponse = NONDeleteObjectOutputResponse;

export class NONRequestorHelper {
    static decode_object_info(req: Response): Promise<BuckyResult<NONObjectInfo>>;
    static encode_object_info(req: HttpRequest, info: NONObjectInfo): void;
}
export class NONRequestor {
    service_url: string;
    constructor(requestor: BaseRequestor, dec_id?: ObjectId | undefined);
    format_url(req_path: string | undefined, object_id: ObjectId, inner_path?: string): string;
    encode_common_headers(action: NONAction, com_req: NONOutputRequestCommon, http_req: HttpRequest): void;
    encode_put_object_request(req: NONPutObjectOutputRequest): HttpRequest;
    decode_put_object_response(resp: Response): Promise<BuckyResult<NONPutObjectOutputResponse>>;
    put_object(req: NONPutObjectOutputRequest): Promise<BuckyResult<NONPutObjectOutputResponse>>;
    encode_get_object_request(req: NONGetObjectOutputRequest): HttpRequest;
    decode_get_object_response(req: NONGetObjectOutputRequest, resp: Response): Promise<BuckyResult<NONGetObjectOutputResponse>>;
    get_object(req: NONGetObjectOutputRequest): Promise<BuckyResult<NONGetObjectOutputResponse>>;
    encode_post_object_request(req: NONPostObjectOutputRequest): HttpRequest;
    decode_post_object_response(object_id: ObjectId, resp: Response): Promise<BuckyResult<NONPostObjectOutputResponse>>;
    post_object(req: NONPostObjectOutputRequest): Promise<BuckyResult<NONPostObjectOutputResponse>>;
    format_select_url(req_path: string | undefined, filter: SelectFilter): string;
    encode_select_request(req: NONSelectObjectOutputRequest): HttpRequest;
    select_object(req: NONSelectObjectOutputRequest): Promise<BuckyResult<NONSelectObjectOutputResponse>>;
    encode_delete_object_request(req: NONDeleteObjectOutputRequest): HttpRequest;
    decode_delete_object_response(req: NONDeleteObjectOutputRequest, resp: Response): Promise<BuckyResult<NONDeleteObjectOutputResponse>>;
    delete_object(req: NONDeleteObjectOutputRequest): Promise<BuckyResult<NONDeleteObjectOutputResponse>>;
}

export enum ObjectStackEventType {
    Http = 0,
    WebSocket = 1
}
export enum ObjectStackRequestorType {
    Http = 0,
    WebSocket = 1
}
export interface ObjectStackRequestorConfig {
    non_service: ObjectStackRequestorType;
    ndn_service: ObjectStackRequestorType;
    util_service: ObjectStackRequestorType;
    trans_service: ObjectStackRequestorType;
    crypto_service: ObjectStackRequestorType;
}
export class SharedCyfsStackParam {
    service_url: string;
    event_type: ObjectStackEventType;
    dec_id?: ObjectId | undefined;
    ws_url?: string | undefined;
    requestor_config?: ObjectStackRequestorConfig | undefined;
    constructor(service_url: string, event_type: ObjectStackEventType, dec_id?: ObjectId | undefined, ws_url?: string | undefined, requestor_config?: ObjectStackRequestorConfig | undefined);
    static default_requestor_config(): ObjectStackRequestorConfig;
    static ws_requestor_config(): ObjectStackRequestorConfig;
    static default(dec_id?: ObjectId): SharedCyfsStackParam;
    static default_with_ws_event(dec_id?: ObjectId): SharedCyfsStackParam;
    static default_runtime(dec_id?: ObjectId): SharedCyfsStackParam;
    static new_with_http_event(service_url: string, dec_id?: ObjectId): BuckyResult<SharedCyfsStackParam>;
    static new_with_http_event_ports(service_http_port: number, dec_id?: ObjectId): BuckyResult<SharedCyfsStackParam>;
    static new_with_ws_event(service_url: string, ws_url: string, dec_id?: ObjectId): BuckyResult<SharedCyfsStackParam>;
    static new_with_ws_event_ports(service_http_port: number, ws_port: number, dec_id?: ObjectId): BuckyResult<SharedCyfsStackParam>;
}
export class SharedCyfsStack {
    static default_with_ws_event(dec_id?: ObjectId): SharedCyfsStack;
    static open_default(dec_id?: ObjectId): SharedCyfsStack;
    static open_default_with_ws_event(dec_id?: ObjectId): SharedCyfsStack;
    static open_runtime(dec_id?: ObjectId): SharedCyfsStack;
    static open(param: SharedCyfsStackParam): SharedCyfsStack;
    wait_online(timeoutInMicroSeconds: Option<JSBI>): Promise<BuckyResult<null>>;
    online(): Promise<BuckyResult<null>>;
    local_device_id(): DeviceId;
    local_device(): Device;
    non_service(): NONRequestor;
    ndn_service(): NDNRequestor;
    crypto(): CryptoRequestor;
    util(): UtilRequestor;
    trans(): TransRequestor;
    router_handlers(): RouterHandlerManager;
}

export type UtilRequestCommon = UtilOutputRequestCommon;
export type UtilGetDeviceRequest = UtilGetDeviceOutputRequest;
export type UtilGetDeviceResponse = UtilGetDeviceOutputResponse;
export type UtilGetZoneRequest = UtilGetZoneOutputRequest;
export type UtilGetZoneResponse = UtilGetZoneOutputResponse;
export type UtilResolveOODRequest = UtilResolveOODOutputRequest;
export type UtilResolveOODResponse = UtilResolveOODOutputResponse;
export type UtilGetOODStatusRequest = UtilGetOODStatusOutputRequest;
export type UtilGetOODStatusResponse = UtilGetOODStatusOutputResponse;
export type UtilGetNOCInfoRequest = UtilGetNOCInfoOutputRequest;
export type UtilGetNOCInfoResponse = UtilGetNOCInfoOutputResponse;
export type UtilGetDeviceStaticInfoRequest = UtilGetDeviceStaticInfoOutputRequest;
export type UtilGetDeviceStaticInfoResponse = UtilGetDeviceStaticInfoOutputResponse;
export type UtilGetNetworkAccessInfoRequest = UtilGetNetworkAccessInfoOutputRequest;
export type UtilGetNetworkAccessInfoResponse = UtilGetNetworkAccessInfoOutputResponse;
export type UtilGetSystemInfoRequest = UtilGetSystemInfoOutputRequest;
export type UtilGetSystemInfoResponse = UtilGetSystemInfoOutputResponse;
export type UtilGetVersionInfoRequest = UtilGetVersionInfoOutputRequest;
export type UtilGetVersionInfoResponse = UtilGetVersionInfoOutputResponse;

export class UtilRequestor {
    service_url: string;
    constructor(requestor: BaseRequestor, dec_id?: ObjectId | undefined);
    format_url(util_path: string, req_path?: string, object_id?: ObjectId): string;
    encode_common_headers(com_req: UtilRequestCommon, http_req: HttpRequest): void;
    encode_get_device_request(req: UtilGetDeviceRequest): HttpRequest;
    decode_get_device_response(resp: Response): Promise<BuckyResult<UtilGetDeviceResponse>>;
    get_device(req: UtilGetDeviceRequest): Promise<BuckyResult<UtilGetDeviceResponse>>;
    encode_get_zone_request(req: UtilGetZoneRequest): HttpRequest;
    decode_get_zone_response(resp: Response): Promise<BuckyResult<UtilGetZoneResponse>>;
    get_zone(req: UtilGetZoneRequest): Promise<BuckyResult<UtilGetZoneOutputResponse>>;
    format_resolve_url(req_path: string | undefined, owner_id: ObjectId | undefined, object_id: ObjectId): string;
    encode_resolve_ood_request(req: UtilResolveOODRequest): HttpRequest;
    resolve_ood(req: UtilResolveOODRequest): Promise<BuckyResult<UtilResolveOODResponse>>;
    encode_get_ood_status_request(req: UtilGetOODStatusRequest): HttpRequest;
    get_ood_status(req: UtilGetOODStatusRequest): Promise<BuckyResult<UtilGetOODStatusResponse>>;
    encode_get_noc_info_request(req: UtilGetNOCInfoRequest): HttpRequest;
    get_noc_info(req: UtilGetNOCInfoRequest): Promise<BuckyResult<UtilGetNOCInfoResponse>>;
    encode_get_network_access_info_request(req: UtilGetNetworkAccessInfoRequest): HttpRequest;
    get_network_access_info(req: UtilGetNetworkAccessInfoRequest): Promise<BuckyResult<UtilGetNetworkAccessInfoResponse>>;
    encode_get_device_static_info_request(req: UtilGetDeviceStaticInfoRequest): HttpRequest;
    get_device_static_info(req: UtilGetDeviceStaticInfoRequest): Promise<BuckyResult<UtilGetDeviceStaticInfoResponse>>;
    encode_get_system_info_request(req: UtilGetSystemInfoRequest): HttpRequest;
    get_system_info(req: UtilGetSystemInfoRequest): Promise<BuckyResult<UtilGetSystemInfoResponse>>;
    encode_get_version_info_request(req: UtilGetVersionInfoRequest): HttpRequest;
    get_version_info(req: UtilGetVersionInfoRequest): Promise<BuckyResult<UtilGetVersionInfoResponse>>;
}

export interface TransTaskOnAirState {
    download_percent: number;
    download_speed: number;
    upload_speed: number;
}
export enum TransTaskState {
    Pending = 0,
    Downloading = 1,
    Paused = 2,
    Canceled = 3,
    Finished = 4,
    Err = 5
}
export class TransTaskStateInfo {
    state: TransTaskState;
    on_air_state?: TransTaskOnAirState;
    upload_speed?: number;
    error_code?: BuckyErrorCodeEx;
    static from_respone(resp: Response): Promise<BuckyResult<TransTaskStateInfo>>;
}
export enum TransTaskControlAction {
    Pause = "Pause",
    Resume = "Resume",
    Cancel = "Cancel"
}
export interface TransStartTaskRequest {
    common: NDNOutputRequestCommon;
    target?: DeviceId;
    object_id: ObjectId;
    local_path: string;
    device_list: DeviceId[];
}
export interface TransControlTaskRequest {
    target?: DeviceId;
    object_id: ObjectId;
    local_path: string;
    action: TransTaskControlAction;
}
export interface TransStopTaskRequest {
    target?: DeviceId;
    object_id: ObjectId;
    user_id: string;
}
export interface TransGetTaskStateRequest {
    target?: DeviceId;
    object_id: ObjectId;
    local_path: string;
}
export interface FileDirRef {
    dir_id: DirId;
    inner_path: string;
}
export interface TransAddFileRequest {
    owner: ObjectId;
    local_path: string;
    chunk_size: number;
    dirs?: FileDirRef[];
}
export class TransAddFileResponse {
    file_id: ObjectId;
    constructor(id: ObjectId);
    static from_respone(resp: Response): Promise<BuckyResult<TransAddFileResponse>>;
}

export class TransRequestor {
    serviceURL: string;
    constructor(requestor: BaseRequestor);
    start_task(req: TransStartTaskRequest): Promise<BuckyResult<null>>;
    control_task(req: TransControlTaskRequest): Promise<BuckyResult<null>>;
    get_task_state(req: TransGetTaskStateRequest): Promise<BuckyResult<TransTaskStateInfo>>;
    add_file(req: TransAddFileRequest): Promise<BuckyResult<TransAddFileResponse>>;
}

class RouterHandlerItem {
    chain: RouterHandlerChain;
    category: RouterHandlerCategory;
    index: number;
    id: string;
    constructor(chain: RouterHandlerChain, category: RouterHandlerCategory, index: number, id: string, filter: string, default_action: RouterHandlerAction, routine: Option<RouterHandlerAnyRoutine>);
    set_routine(routine: Option<RouterHandlerAnyRoutine>): void;
    emit(param: string): Promise<BuckyResult<string>>;
    register(requestor: WebSocketRequestManager): Promise<void>;
}
export class RouterHandlerUnregisterItem {
    id: string;
    constructor(chain: RouterHandlerChain, category: RouterHandlerCategory, id: string);
    unregister(requestor: WebSocketRequestManager): Promise<BuckyResult<boolean>>;
}
export class RouterWSHandlerHandlerManagerImpl {
    handlers: {
        [name: string]: RouterHandlerItem;
    };
    unregister_handlers: {
        [name: string]: RouterHandlerUnregisterItem;
    };
    session: Option<WebSocketSession>;
    add_handler(handler_item: RouterHandlerItem): Promise<BuckyResult<void>>;
    static remove_handler(manager: RouterWSHandlerHandlerManagerImpl, chain: RouterHandlerChain, category: RouterHandlerCategory, id: string): Promise<BuckyResult<boolean>>;
    remove_handler_op(chain: RouterHandlerChain, category: RouterHandlerCategory, id: string): RouterHandlerUnregisterItem;
    static on_event(manager: RouterWSHandlerHandlerManagerImpl, content: string): Promise<BuckyResult<Option<string>>>;
    static on_session_begin(manager: RouterWSHandlerHandlerManagerImpl, session: WebSocketSession): Promise<void>;
    static register_all(manager: RouterWSHandlerHandlerManagerImpl, session: WebSocketSession): Promise<void>;
    static unregister_all(manager: RouterWSHandlerHandlerManagerImpl, session: WebSocketSession): Promise<void>;
    static on_session_end(manager: RouterWSHandlerHandlerManagerImpl, session: WebSocketSession): Promise<void>;
}
export class RouterHandlerWSHandlerManager {
    manager: RouterWSHandlerHandlerManagerImpl;
    client: WebSocketClient;
    constructor(service_url: string);
    start(): void;
    add_handler<REQ, RESP>(chain: RouterHandlerChain, id: string, index: number, category: RouterHandlerCategory, req_codec: JsonCodec<REQ>, resp_codec: JsonCodec<RESP>, filter: string, default_action: RouterHandlerAction, routine: Option<EventListenerAsyncRoutineT<RouterHandlerRequest<REQ, RESP>, RouterHandlerResponse<REQ, RESP>>>): Promise<BuckyResult<void>>;
    remove_handler(chain: RouterHandlerChain, category: RouterHandlerCategory, id: string): Promise<BuckyResult<boolean>>;
}
export {};

export interface RouterAddHandlerParam {
    filter: string;
    index: number;
    default_action: RouterHandlerAction;
    routine?: string;
}
export interface RouterWSAddHandlerParam {
    chain: RouterHandlerChain;
    category: RouterHandlerCategory;
    id: string;
    param: RouterAddHandlerParam;
}
export interface RouterWSRemoveHandlerParam {
    chain: RouterHandlerChain;
    category: RouterHandlerCategory;
    id: string;
}
export type RouterWSHandlerResponse = RouterEventResponse;
export interface RouterWSHandlerEventParam {
    chain: RouterHandlerChain;
    category: RouterHandlerCategory;
    id: string;
    param: string;
}
export interface RouterWSHandlerEventResponse {
    action: RouterHandlerAction;
}

export enum RouterHandlerAction {
    Default = "Default",
    Response = "Response",
    Reject = "Reject",
    Drop = "Drop",
    Pass = "Pass"
}

export enum RouterHandlerCategory {
    PutObject = "put_object",
    GetObject = "get_object",
    PostObject = "post_object",
    SelectObject = "select_object",
    DeleteObject = "delete_object",
    GetData = "get_data",
    PutData = "put_data",
    DeleteData = "delete_data",
    SignObject = "sign_object",
    VerifyObject = "verify_object",
    Acl = "acl"
}

export interface RouterHandlerAnyRoutine {
    emit(param: string): Promise<BuckyResult<string>>;
}
export class RouterHandlerEventRoutineT<REQ, RESP> implements RouterHandlerAnyRoutine {
    constructor(req_codec: JsonCodec<REQ>, resp_codec: JsonCodec<RESP>, listener: EventListenerAsyncRoutineT<RouterHandlerRequest<REQ, RESP>, RouterHandlerResponse<REQ, RESP>>);
    emit(param: string): Promise<BuckyResult<string>>;
}
export class RouterHandlerManager {
    ws: Option<RouterHandlerWSHandlerManager>;
    constructor(event_type: ObjectStackEventType, ws_url?: string);
    add_put_object_handler(chain: RouterHandlerChain, id: string, index: number, filter: string, default_action: RouterHandlerAction, routine: Option<RouterHandlerPutObjectRoutine>): Promise<BuckyResult<void>>;
    add_get_object_handler(chain: RouterHandlerChain, id: string, index: number, filter: string, default_action: RouterHandlerAction, routine: Option<RouterHandlerGetObjectRoutine>): Promise<BuckyResult<void>>;
    add_post_object_handler(chain: RouterHandlerChain, id: string, index: number, filter: string, default_action: RouterHandlerAction, routine: Option<RouterHandlerPostObjectRoutine>): Promise<BuckyResult<void>>;
    add_select_object_handler(chain: RouterHandlerChain, id: string, index: number, filter: string, default_action: RouterHandlerAction, routine: Option<RouterHandlerSelectObjectRoutine>): Promise<BuckyResult<void>>;
    add_delete_object_handler(chain: RouterHandlerChain, id: string, index: number, filter: string, default_action: RouterHandlerAction, routine: Option<RouterHandlerDeleteObjectRoutine>): Promise<BuckyResult<void>>;
    add_put_data_handler(chain: RouterHandlerChain, id: string, index: number, filter: string, default_action: RouterHandlerAction, routine: Option<RouterHandlerPutDataRoutine>): Promise<BuckyResult<void>>;
    add_get_data_handler(chain: RouterHandlerChain, id: string, index: number, filter: string, default_action: RouterHandlerAction, routine: Option<RouterHandlerGetDataRoutine>): Promise<BuckyResult<void>>;
    add_delete_data_handler(chain: RouterHandlerChain, id: string, index: number, filter: string, default_action: RouterHandlerAction, routine: Option<RouterHandlerDeleteDataRoutine>): Promise<BuckyResult<void>>;
    add_sign_object_handler(chain: RouterHandlerChain, id: string, index: number, filter: string, default_action: RouterHandlerAction, routine: Option<RouterHandlerSignObjectRoutine>): Promise<BuckyResult<void>>;
    add_verify_object_handler(chain: RouterHandlerChain, id: string, index: number, filter: string, default_action: RouterHandlerAction, routine: Option<RouterHandlerVerifyObjectRoutine>): Promise<BuckyResult<void>>;
    add_acl_handler(chain: RouterHandlerChain, id: string, index: number, filter: string, default_action: RouterHandlerAction, routine: Option<RouterHandlerAclRoutine>): Promise<BuckyResult<void>>;
    add_handler<REQ, RESP>(chain: RouterHandlerChain, id: string, index: number, category: RouterHandlerCategory, req_codec: JsonCodec<REQ>, resp_codec: JsonCodec<RESP>, filter: string, default_action: RouterHandlerAction, routine: Option<EventListenerAsyncRoutineT<RouterHandlerRequest<REQ, RESP>, RouterHandlerResponse<REQ, RESP>>>): Promise<BuckyResult<void>>;
    remove_handler(chain: RouterHandlerChain, category: RouterHandlerCategory, id: string): Promise<BuckyResult<boolean>>;
}

export interface RouterHandlerRequest<REQ, RESP> {
    request: REQ;
    response?: BuckyResult<RESP>;
}
export interface RouterHandlerResponse<REQ, RESP> {
    action: RouterHandlerAction;
    request?: REQ;
    response?: BuckyResult<RESP>;
}
export type RouterHandlerPutObjectRequest = RouterHandlerRequest<NONPutObjectInputRequest, NONPutObjectInputResponse>;
export type RouterHandlerGetObjectRequest = RouterHandlerRequest<NONGetObjectInputRequest, NONGetObjectInputResponse>;
export type RouterHandlerPostObjectRequest = RouterHandlerRequest<NONPostObjectInputRequest, NONPostObjectInputResponse>;
export type RouterHandlerSelectObjectRequest = RouterHandlerRequest<NONSelectObjectInputRequest, NONSelectObjectInputResponse>;
export type RouterHandlerDeleteObjectRequest = RouterHandlerRequest<NONDeleteObjectInputRequest, NONDeleteObjectInputResponse>;
export type RouterHandlerPutDataRequest = RouterHandlerRequest<NDNPutDataInputRequest, NDNPutDataInputResponse>;
export type RouterHandlerGetDataRequest = RouterHandlerRequest<NDNGetDataInputRequest, NDNGetDataInputResponse>;
export type RouterHandlerDeleteDataRequest = RouterHandlerRequest<NDNDeleteDataInputRequest, NDNDeleteDataInputResponse>;
export type RouterHandlerSignObjectRequest = RouterHandlerRequest<CryptoSignObjectInputRequest, CryptoSignObjectInputResponse>;
export type RouterHandlerVerifyObjectRequest = RouterHandlerRequest<CryptoVerifyObjectInputRequest, CryptoVerifyObjectInputResponse>;
export type RouterHandlerAclRequest = RouterHandlerRequest<AclHandlerRequest, AclHandlerResponse>;
export type RouterHandlerPutObjectResult = RouterHandlerResponse<NONPutObjectInputRequest, NONPutObjectInputResponse>;
export type RouterHandlerGetObjectResult = RouterHandlerResponse<NONGetObjectInputRequest, NONGetObjectInputResponse>;
export type RouterHandlerPostObjectResult = RouterHandlerResponse<NONPostObjectInputRequest, NONPostObjectInputResponse>;
export type RouterHandlerSelectObjectResult = RouterHandlerResponse<NONSelectObjectInputRequest, NONSelectObjectInputResponse>;
export type RouterHandlerDeleteObjectResult = RouterHandlerResponse<NONDeleteObjectInputRequest, NONDeleteObjectInputResponse>;
export type RouterHandlerPutDataResult = RouterHandlerResponse<NDNPutDataInputRequest, NDNPutDataInputResponse>;
export type RouterHandlerGetDataResult = RouterHandlerResponse<NDNGetDataInputRequest, NDNGetDataInputResponse>;
export type RouterHandlerDeleteDataResult = RouterHandlerResponse<NDNDeleteDataInputRequest, NDNDeleteDataInputResponse>;
export type RouterHandlerSignObjectResult = RouterHandlerResponse<CryptoSignObjectInputRequest, CryptoSignObjectInputResponse>;
export type RouterHandlerVerifyObjectResult = RouterHandlerResponse<CryptoVerifyObjectInputRequest, CryptoVerifyObjectInputResponse>;
export type RouterHandlerAclResult = RouterHandlerResponse<AclHandlerRequest, AclHandlerResponse>;
export type RouterHandlerPutObjectRoutine = EventListenerAsyncRoutineT<RouterHandlerPutObjectRequest, RouterHandlerPutObjectResult>;
export type RouterHandlerGetObjectRoutine = EventListenerAsyncRoutineT<RouterHandlerGetObjectRequest, RouterHandlerGetObjectResult>;
export type RouterHandlerPostObjectRoutine = EventListenerAsyncRoutineT<RouterHandlerPostObjectRequest, RouterHandlerPostObjectResult>;
export type RouterHandlerSelectObjectRoutine = EventListenerAsyncRoutineT<RouterHandlerSelectObjectRequest, RouterHandlerSelectObjectResult>;
export type RouterHandlerDeleteObjectRoutine = EventListenerAsyncRoutineT<RouterHandlerDeleteObjectRequest, RouterHandlerDeleteObjectResult>;
export type RouterHandlerPutDataRoutine = EventListenerAsyncRoutineT<RouterHandlerPutDataRequest, RouterHandlerPutDataResult>;
export type RouterHandlerGetDataRoutine = EventListenerAsyncRoutineT<RouterHandlerGetDataRequest, RouterHandlerGetDataResult>;
export type RouterHandlerDeleteDataRoutine = EventListenerAsyncRoutineT<RouterHandlerDeleteDataRequest, RouterHandlerDeleteDataResult>;
export type RouterHandlerSignObjectRoutine = EventListenerAsyncRoutineT<RouterHandlerSignObjectRequest, RouterHandlerSignObjectResult>;
export type RouterHandlerVerifyObjectRoutine = EventListenerAsyncRoutineT<RouterHandlerVerifyObjectRequest, RouterHandlerVerifyObjectResult>;
export type RouterHandlerAclRoutine = EventListenerAsyncRoutineT<RouterHandlerAclRequest, RouterHandlerAclResult>;
export class RouterHandlerRequestJsonCodec<REQ, RESP> extends JsonCodec<RouterHandlerRequest<REQ, RESP>> {
    constructor(req_codec: JsonCodec<REQ>, resp_codec: JsonCodec<RESP>);
    encode_object(param: RouterHandlerRequest<REQ, RESP>): any;
    decode_object(o: any): BuckyResult<RouterHandlerRequest<REQ, RESP>>;
}
export class RouterHandlerResponseJsonCodec<REQ, RESP> extends JsonCodec<RouterHandlerResponse<REQ, RESP>> {
    constructor(req_codec: JsonCodec<REQ>, resp_codec: JsonCodec<RESP>);
    encode_object(param: RouterHandlerResponse<REQ, RESP>): any;
    decode_object(o: any): BuckyResult<RouterHandlerResponse<REQ, RESP>>;
}
export type RouterHandlerPutObjectRequestJsonCodec = RouterHandlerRequestJsonCodec<NONPutObjectInputRequest, NONPutObjectInputResponse>;
export type RouterHandlerGetObjectRequestJsonCodec = RouterHandlerRequestJsonCodec<NONGetObjectInputRequest, NONGetObjectInputResponse>;
export type RouterHandlerPostObjectRequestJsonCodec = RouterHandlerRequestJsonCodec<NONPostObjectInputRequest, NONPostObjectInputResponse>;
export type RouterHandlerSelectObjectRequestJsonCodec = RouterHandlerRequestJsonCodec<NONSelectObjectInputRequest, NONSelectObjectInputResponse>;
export type RouterHandlerDeleteObjectRequestJsonCodec = RouterHandlerRequestJsonCodec<NONDeleteObjectInputRequest, NONDeleteObjectInputResponse>;
export type RouterHandlerSignObjectRequestJsonCodec = RouterHandlerRequestJsonCodec<CryptoSignObjectInputRequest, CryptoSignObjectInputResponse>;
export type RouterHandlerVerifyObjectRequestJsonCodec = RouterHandlerRequestJsonCodec<CryptoVerifyObjectInputRequest, CryptoVerifyObjectInputResponse>;

export enum RouterHandlerChain {
    PreNOC = "pre_noc",
    PostNOC = "post_noc",
    PreRouter = "pre_router",
    PostRouter = "post_router",
    PreForward = "pre_forward",
    PostForward = "post_forward",
    PreCrypto = "pre_crypto",
    PostCrypto = "post_crypto",
    Acl = "acl"
}

export class CryptoRequestor {
    service_url: string;
    constructor(requestor: BaseRequestor, dec_id?: ObjectId | undefined);
    format_url(sign: boolean, req_path: string | undefined, object_id: ObjectId): string;
    encode_common_headers(com_req: CryptoOutputRequestCommon, http_req: HttpRequest): void;
    encode_verify_object_request(req: CryptoVerifyObjectOutputRequest): HttpRequest;
    decode_verify_object_response(object_id: ObjectId, resp: Response): Promise<BuckyResult<CryptoVerifyObjectOutputResponse>>;
    verify_object(req: CryptoVerifyObjectRequest): Promise<BuckyResult<CryptoVerifyObjectOutputResponse>>;
    encode_sign_object_request(req: CryptoSignObjectRequest): HttpRequest;
    decode_sign_object_response(object_id: ObjectId, resp: Response): Promise<BuckyResult<CryptoSignObjectOutputResponse>>;
    sign_object(req: CryptoSignObjectRequest): Promise<BuckyResult<CryptoSignObjectOutputResponse>>;
}

export type CryptoRequestCommon = CryptoOutputRequestCommon;
export type CryptoSignObjectRequest = CryptoSignObjectOutputRequest;
export type CryptoSignObjectResponse = CryptoSignObjectOutputResponse;
export type CryptoVerifyObjectRequest = CryptoVerifyObjectOutputRequest;
export type CryptoVerifyObjectResponse = CryptoVerifyObjectOutputResponse;

export interface CryptoInputRequestCommon {
    req_path?: string;
    dec_id?: ObjectId;
    source: DeviceId;
    protocol: NONProtocol;
    target?: ObjectId;
    flags: number;
}
export class CryptoInputRequestCommonJsonCodec extends JsonCodec<CryptoInputRequestCommon> {
    encode_object(param: CryptoInputRequestCommon): any;
    decode_object(o: any): BuckyResult<CryptoInputRequestCommon>;
}
export interface CryptoSignObjectInputRequest {
    common: CryptoInputRequestCommon;
    object: NONObjectInfo;
    flags: number;
}
export class CryptoSignObjectInputRequestJsonCodec extends JsonCodec<CryptoSignObjectInputRequest> {
    encode_object(param: CryptoSignObjectInputRequest): any;
    decode_object(o: any): BuckyResult<CryptoSignObjectInputRequest>;
}
export type CryptoSignObjectInputResponse = CryptoSignObjectOutputResponse;
export interface CryptoVerifyObjectInputRequest {
    common: CryptoInputRequestCommon;
    sign_type: VerifySignType;
    object: NONObjectInfo;
    sign_object: VerifyObjectType;
}
export class CryptoVerifyObjectInputRequestJsonCodec extends JsonCodec<CryptoVerifyObjectInputRequest> {
    encode_object(param: CryptoVerifyObjectInputRequest): any;
    decode_object(o: any): BuckyResult<CryptoVerifyObjectInputRequest>;
}
export type CryptoVerifyObjectInputResponse = CryptoVerifyObjectOutputResponse;

export interface CryptoOutputRequestCommon {
    req_path?: string;
    dec_id?: ObjectId;
    target?: ObjectId;
    flags: number;
}
export const CRYPTO_REQUEST_FLAG_SIGN_BY_PEOPLE: number;
export const CRYPTO_REQUEST_FLAG_SIGN_BY_DEVICE: number;
export const CRYPTO_REQUEST_FLAG_SIGN_SET_DESC: number;
export const CRYPTO_REQUEST_FLAG_SIGN_SET_BODY: number;
export const CRYPTO_REQUEST_FLAG_SIGN_PUSH_DESC: number;
export const CRYPTO_REQUEST_FLAG_SIGN_PUSH_BODY: number;
export interface CryptoSignObjectOutputRequest {
    common: CryptoOutputRequestCommon;
    object: NONObjectInfo;
    flags: number;
}
export enum SignObjectResult {
    Signed = "signed",
    Pending = "pending"
}
export interface CryptoSignObjectOutputResponse {
    result: SignObjectResult;
    object?: NONObjectInfo;
}
export class CryptoSignObjectOutputResponseJsonCodec extends JsonCodec<CryptoSignObjectOutputResponse> {
    encode_object(param: CryptoSignObjectOutputResponse): any;
    decode_object(o: any): BuckyResult<CryptoSignObjectOutputResponse>;
}
export enum VerifySignType {
    Desc = "desc",
    Body = "body",
    Both = "both"
}
export interface SignObject {
    object_id: ObjectId;
    object_raw?: Uint8Array;
    object?: AnyNamedObject;
}
export class SignObjectJsonCodec extends JsonCodec<SignObject> {
    encode_object(param: SignObject): any;
    decode_object(o: any): BuckyResult<SignObject>;
}
export interface VerifySigns {
    desc_signs?: Uint8Array;
    body_signs?: Uint8Array;
}
export class VerifySignsJsonCodec extends JsonCodec<VerifySigns> {
    constructor();
    encode_object(param: VerifySigns): any;
    decode_object(o: any): BuckyResult<VerifySigns>;
}
export class VerifyObjectType {
    type: string;
    sign_object?: SignObject | undefined;
    verify_signs?: VerifySigns | undefined;
    constructor(type: string, sign_object?: SignObject | undefined, verify_signs?: VerifySigns | undefined);
    static Owner(): VerifyObjectType;
    static Object(sign_object: SignObject): VerifyObjectType;
    static Sign(verify_signs: VerifySigns): VerifyObjectType;
    match(visitor: {
        Owner?: () => void;
        Object?: (object: SignObject) => void;
        Sign?: (sign: VerifySigns) => void;
    }): void;
}
export class VerifyObjectTypeJsonCodec extends JsonCodec<VerifyObjectType> {
    encode_object(param: VerifyObjectType): any;
    decode_object(o: any): BuckyResult<VerifyObjectType>;
}
export interface CryptoVerifyObjectOutputRequest {
    common: CryptoOutputRequestCommon;
    sign_type: VerifySignType;
    object: NONObjectInfo;
    sign_object: VerifyObjectType;
}
export interface VerifySignResult {
    index: number;
    valid: boolean;
    sign_object_id: ObjectId;
}
export class VerifySignResultJsonCodec extends JsonCodec<VerifySignResult> {
    encode_object(param: VerifySignResult): any;
    decode_object(o: any): BuckyResult<VerifySignResult>;
}
export interface VerifyObjectResult {
    valid: boolean;
    desc_signs: VerifySignResult[];
    body_signs: VerifySignResult[];
}
export class VerifyObjectResultJsonCodec extends JsonCodec<VerifyObjectResult> {
    encode_object(param: VerifyObjectResult): any;
    decode_object(o: any): BuckyResult<VerifyObjectResult>;
}
export interface CryptoVerifyObjectOutputResponse {
    result: VerifyObjectResult;
}
export class CryptoVerifyObjectOutputResponseJsonCodec extends JsonCodec<CryptoVerifyObjectOutputResponse> {
    encode_object(param: CryptoVerifyObjectOutputResponse): any;
    decode_object(o: any): BuckyResult<CryptoVerifyObjectOutputResponse>;
}

export enum AclDirection {
    Any = "*",
    In = "in",
    Out = "out"
}
export enum AclOperation {
    Any = "*",
    GetObject = "get-object",
    PutObject = "put-object",
    PostObject = "post-object",
    SelectObject = "select-object",
    DeleteObject = "delete-object",
    SignObject = "sign-object",
    VerifyObject = "verify-object",
    PutData = "put-data",
    GetData = "get-data",
    DeleteData = "delete-data",
    Get = "get",
    Put = "put",
    Delete = "delete",
    Read = "read",
    Write = "write",
    Crypto = "crypto"
}
export interface AclAction {
    direction: AclDirection;
    operation: AclOperation;
}
export enum AclAccess {
    Accept = "accept",
    Reject = "reject",
    Drop = "drop",
    Pass = "pass"
}

export interface AclHandlerRequest {
    protocol: NONProtocol;
    action: AclAction;
    device_id: DeviceId;
    object: NONSlimObjectInfo;
    inner_path?: string;
    dec_id: string;
    req_path?: string;
    referer_object?: NDNDataRefererObject[];
}
export class AclHandlerRequestJsonCodec extends JsonCodec<AclHandlerRequest> {
    encode_object(param: AclHandlerRequest): any;
    decode_object(o: any): BuckyResult<AclHandlerRequest>;
}
export interface AclHandlerResponse {
    access: AclAccess;
}
export class AclHandlerResponseJsonCodec extends JsonCodec<AclHandlerResponse> {
}

export enum SubscriberAction {
    Accept = 0,
    Rejcet = 1,
    Ignore = 2
}
export type Subscriber = (topic_id: TopicId, device_id: DeviceId, msg_obj_id: Option<ObjectId>) => Promise<BuckyResult<number>>;
export type SubscriberReqest = (topic_id: TopicId, device_id: DeviceId, msg_obj_id: Option<ObjectId>) => Promise<BuckyResult<number>>;
export type Unsubscriber = (topic_id: TopicId, device_id: DeviceId, msg_obj_id: Option<ObjectId>) => Promise<BuckyResult<number>>;
export type Publish = (topic_id: TopicId, device_id: DeviceId, msg_obj_id: ObjectId) => Promise<BuckyResult<number>>;
class TopicEventInner {
    constructor(subscriber: Option<Subscriber>, subscriber_req: Option<SubscriberReqest>, unsubscriber: Option<Unsubscriber>, publisher: Option<Publish>);
    emit_subscribe(topic_id: TopicId, device_id: ObjectId, msg_obj_id: Option<ObjectId>): Promise<BuckyResult<number>>;
    emit_subscribe_request(topic_id: TopicId, device_id: ObjectId, msg_obj_id: Option<ObjectId>): Promise<BuckyResult<number>>;
    emit_unsubscribe(topic_id: TopicId, device_id: ObjectId, msg_obj_id: Option<ObjectId>): Promise<BuckyResult<number>>;
    emit_publish(topic_id: TopicId, device_id: ObjectId, msg_obj_id: ObjectId): Promise<BuckyResult<number>>;
}
enum MsgDirection {
    Main2Main = 0,
    Follow2Main = 1,
    Main2Follow = 2,
    Follow2Follow = 3
}
interface MsgDirectionInfo {
    dir: MsgDirection;
    info: string;
}
export class TopicEvent {
    constructor();
    on_subscribe(callback: Subscriber): void;
    on_subscriber_req(callback: SubscriberReqest): void;
    on_unsubscribe(callback: Unsubscriber): void;
    on_publish(callback: Publish): void;
    build(): TopicEventInner;
}
export class TopicManager {
    readonly ood_id: DeviceId;
    constructor(stack: SharedCyfsStack, owner_id: PeopleId, ood_id: DeviceId, last_select_time: JSBI);
    create_topic(unique_id: UniqueId, init_device_list: DeviceId[], user_data_id: Option<ObjectId>): Promise<BuckyResult<TopicId>>;
    subscribe(topic_id: TopicId, msg_seq: number, member_device_id: Option<DeviceId>, topic_owner_id: Option<ObjectId>): Promise<BuckyResult<number>>;
    subscribe_with_msg<DC extends DescContent, BC extends BodyContent>(topic_id: TopicId, msg_seq: number, msg_obj: NamedObject<DC, BC>, member_device_id: Option<DeviceId>, topic_owner_id: Option<ObjectId>): Promise<BuckyResult<number>>;
    subscribe_impl<DC extends DescContent, BC extends BodyContent>(topic_id: TopicId, msg_offset: number, msg_obj: Option<NamedObject<DC, BC>>, member_device_id: Option<DeviceId>, topic_owner_id_: Option<ObjectId>): Promise<BuckyResult<number>>;
    unsubscribe(topic_id: TopicId, member_device_id: Option<DeviceId>, topic_owner_id: Option<ObjectId>): Promise<BuckyResult<number>>;
    unsubscribe_with_msg<DC extends DescContent, BC extends BodyContent>(topic_id: TopicId, msg_obj: NamedObject<DC, BC>, member_device_id: Option<DeviceId>, topic_owner_id: Option<ObjectId>): Promise<BuckyResult<number>>;
    unsubscribe_impl<DC extends DescContent, BC extends BodyContent>(topic_id: TopicId, msg_obj: Option<NamedObject<DC, BC>>, member_device_id: Option<DeviceId>, topic_owner_id_: Option<ObjectId>): Promise<BuckyResult<number>>;
    publish<DC extends DescContent, BC extends BodyContent>(topic_id: TopicId, msg_obj: NamedObject<DC, BC>, topic_owner_id_: Option<ObjectId>): Promise<BuckyResult<number>>;
    fetch(topic_id: TopicId, topic_owner_id_: Option<ObjectId>, start: number, count: number): Promise<BuckyResult<number>>;
    run(event: TopicEvent): Promise<void>;
    msg_direction(topic_owner_id: ObjectId, obj_come_from: ObjectId): MsgDirectionInfo;
    on_get_topic(obj: core.Topic, event_inner: TopicEventInner): Promise<void>;
    on_get_topic_subscribe_success(obj: core.TopicSubscribeSuccess, event_inner: TopicEventInner): Promise<void>;
    on_get_topic_subscribe(obj: core.TopicSubscribe, event_inner: TopicEventInner): Promise<void>;
    on_get_topic_unsubscribe_success(obj: core.TopicUnsubscribeSuccess, event_inner: TopicEventInner): Promise<void>;
    on_get_topic_unsubscribe(obj: core.TopicUnsubscribe, event_inner: TopicEventInner): Promise<void>;
    on_get_topic_publish(obj: core.TopicPublish, event_inner: TopicEventInner): Promise<Ok<number> | undefined>;
    on_get_topic_publish_req(obj: core.TopicPublishReq, event_inner: TopicEventInner): Promise<void>;
    on_get_topic_publish_resp(obj: core.TopicPublishResp, event_inner: TopicEventInner): Promise<void>;
    flush_topic_ood_event(event: TopicEventInner): Promise<void>;
    sign_and_put_object<DC extends DescContent, BC extends BodyContent>(obj: NamedObject<DC, BC>, target: ObjectId): Promise<void>;
    put_object<DC extends DescContent, BC extends BodyContent>(obj: NamedObject<DC, BC>, target: ObjectId): Promise<void>;
    fetch_msg_obj(object_id: ObjectId, owner_id: ObjectId): Promise<BuckyResult<number>>;
    get_topic(topic_id: TopicId, topic_owner_id: ObjectId): Promise<BuckyResult<Topic>>;
    fetch_topic(topic_id: TopicId): Promise<BuckyResult<Topic>>;
    fetch_msg_list(object_id: ObjectId, owner_id: ObjectId): Promise<BuckyResult<TopicMessageList>>;
    put_object_buf(object_id: ObjectId, object_buf: Uint8Array, target: ObjectId): Promise<BuckyResult<number>>;
    reduce_status(topic_status_id: TopicPublishStatusId, req: StatusRequest): Promise<BuckyResult<StatusResult>>;
    flush_status(): Promise<void>;
    put_status(status_object_id: ObjectId): Promise<void>;
}
export {};

export interface JsonFragmentType {
    readonly name?: string;
    readonly indexed?: boolean;
    readonly type?: string;
    readonly components?: ReadonlyArray<JsonFragmentType>;
}
export interface JsonFragment {
    readonly name: string;
    readonly type: string;
    readonly anonymous?: boolean;
    readonly payable?: boolean;
    readonly constant?: boolean;
    readonly stateMutability?: string;
    readonly inputs?: ReadonlyArray<JsonFragmentType>;
    readonly outputs?: ReadonlyArray<JsonFragmentType>;
    readonly gas?: string;
}
export const FormatTypes: {
    [name: string]: string;
};
export class ParamType {
    readonly name?: string;
    readonly type: string;
    readonly baseType: string;
    readonly indexed?: boolean;
    readonly components?: ParamType[];
    readonly arrayLength?: number;
    readonly arrayChildren?: ParamType;
    readonly _isParamType: boolean;
    constructor(constructorGuard: any, params: any);
    format(format?: string): string;
    static from(value: string | JsonFragmentType | ParamType, allowIndexed?: boolean): ParamType;
    static fromObject(value: JsonFragmentType | ParamType): ParamType;
    static fromString(value: string, allowIndexed?: boolean): ParamType;
    static isParamType(value: any): value is ParamType;
}
export abstract class Fragment {
    readonly type: string;
    readonly name?: string;
    readonly inputs: ParamType[];
    readonly _isFragment: boolean;
    constructor(constructorGuard: any, params: any);
    abstract format(format?: string): string;
    static from(value: Fragment | JsonFragment | string): Fragment | undefined;
    static fromObject(value: Fragment | JsonFragment): Fragment | undefined;
    static fromString(value: string): Fragment;
    static isFragment(value: any): value is Fragment;
}
export class EventFragment extends Fragment {
    readonly anonymous?: boolean;
    format(format?: string): string;
    static from(value: EventFragment | JsonFragment | string): EventFragment;
    static fromObject(value: JsonFragment | EventFragment): EventFragment;
    static fromString(value: string): EventFragment;
    static isEventFragment(value: any): value is EventFragment;
}
export class ConstructorFragment extends Fragment {
    stateMutability?: string;
    payable?: boolean;
    gas?: BigNumber;
    format(format?: string): string;
    static from(value: ConstructorFragment | JsonFragment | string): ConstructorFragment;
    static fromObject(value: ConstructorFragment | JsonFragment): ConstructorFragment;
    static fromString(value: string): ConstructorFragment;
    static isConstructorFragment(value: any): value is ConstructorFragment;
}
export class FunctionFragment extends ConstructorFragment {
    constant: boolean;
    outputs?: ParamType[];
    format(format?: string): string;
    static from(value: FunctionFragment | JsonFragment | string): FunctionFragment;
    static fromObject(value: FunctionFragment | JsonFragment): FunctionFragment;
    static fromString(value: string): FunctionFragment;
    static isFunctionFragment(value: any): value is FunctionFragment;
}
export class ErrorFragment extends Fragment {
    format(format?: string): string;
    static from(value: ErrorFragment | JsonFragment | string): ErrorFragment;
    static fromObject(value: ErrorFragment | JsonFragment): ErrorFragment;
    static fromString(value: string): ErrorFragment;
    static isErrorFragment(value: any): value is ErrorFragment;
}

export type CoerceFunc = (type: string, value: any) => any;
export class AbiCoder {
    readonly coerceFunc?: CoerceFunc | undefined;
    constructor(coerceFunc?: CoerceFunc | undefined);
    _getCoder(param: ParamType): Coder;
    _getWordSize(): number;
    _getReader(data: Uint8Array, allowLoose?: boolean): Reader;
    _getWriter(): Writer;
    getDefaultValue(types: ReadonlyArray<string | ParamType>): EthAbiResult;
    encode(types: ReadonlyArray<string | ParamType>, values: ReadonlyArray<any>): string;
    decode(types: ReadonlyArray<string | ParamType>, data: BytesLike, loose?: boolean): EthAbiResult;
}
export const defaultAbiCoder: AbiCoder;

export { checkResultErrors, EthAbiResult };
export class LogDescription extends Description<LogDescription> {
    readonly eventFragment: EventFragment;
    readonly name: string;
    readonly signature: string;
    readonly topic: string;
    readonly args: EthAbiResult;
}
export class TransactionDescription extends Description<TransactionDescription> {
    readonly functionFragment: FunctionFragment;
    readonly name: string;
    readonly args: EthAbiResult;
    readonly signature: string;
    readonly sighash: string;
    readonly value: BigNumber;
}
export class Indexed extends Description<Indexed> {
    readonly hash: string | null;
    readonly _isIndexed: boolean;
    static isIndexed(value: any): value is Indexed;
}
export class Interface {
    readonly fragments: ReadonlyArray<Fragment>;
    readonly errors: {
        [name: string]: ErrorFragment;
    };
    readonly events: {
        [name: string]: EventFragment;
    };
    readonly functions: {
        [name: string]: FunctionFragment;
    };
    readonly structs: {
        [name: string]: any;
    };
    readonly deploy: ConstructorFragment;
    readonly _abiCoder: AbiCoder;
    readonly _isInterface: boolean;
    constructor(fragments: string | ReadonlyArray<Fragment | JsonFragment | string>);
    format(format?: string): string | string[];
    static getAbiCoder(): AbiCoder;
    static getSighash(fragment: ErrorFragment | FunctionFragment): string;
    static getEventTopic(eventFragment: EventFragment): string;
    getFunction(nameOrSignatureOrSighash: string): FunctionFragment;
    getEvent(nameOrSignatureOrTopic: string): EventFragment;
    getError(nameOrSignatureOrSighash: string): ErrorFragment;
    getSighash(functionFragment: FunctionFragment | string): string;
    getEventTopic(eventFragment: EventFragment | string): string;
    _decodeParams(params: ReadonlyArray<ParamType>, data: BytesLike): EthAbiResult;
    _encodeParams(params: ReadonlyArray<ParamType>, values: ReadonlyArray<any>): string;
    encodeDeploy(values?: ReadonlyArray<any>): string;
    decodeFunctionData(functionFragment: FunctionFragment | string, data: BytesLike): EthAbiResult;
    encodeFunctionData(functionFragment: FunctionFragment | string, values?: ReadonlyArray<any>): string;
    decodeFunctionResult(functionFragment: FunctionFragment | string, data: BytesLike): EthAbiResult;
    encodeFunctionResult(functionFragment: FunctionFragment | string, values?: ReadonlyArray<any>): string;
    encodeFilterTopics(eventFragment: EventFragment | string, values: ReadonlyArray<any>): (string | string[] | null)[];
    encodeEventLog(eventFragment: EventFragment | string, values: ReadonlyArray<any>): {
        data: string;
        topics: string[];
    };
    decodeEventLog(eventFragment: EventFragment | string, data: BytesLike, topics?: ReadonlyArray<string>): EthAbiResult;
    parseTransaction(tx: {
        data: string;
        value?: BigNumberish;
    }): TransactionDescription | null;
    parseLog(log: {
        topics: string[];
        data: string;
    }): LogDescription | null;
    static isInterface(value: any): value is Interface;
}

export class AppManager {
    owner: ObjectId;
    app_list_id: ObjectId;
    constructor(stack: SharedCyfsStack);
    is_installed(id: DecAppId): Promise<BuckyResult<boolean>>;
    get_app_local_status(id: DecAppId): Promise<BuckyResult<AppLocalStatus>>;
    install_app(id: DecAppId, version: string, start: boolean): Promise<BuckyResult<null>>;
    remove_app(id: DecAppId): Promise<BuckyResult<null>>;
    get_app_list(): Promise<BuckyResult<AppList>>;
}

export function encodeRequest(request: HttpRequest): Uint8Array;
export function decodeResponse(buf: Uint8Array): Response;

export class DataViewJSBIHelperNoBigInt {
    static setBigInt64(view: DataView, byteOffset: number, value: JSBI, littleEndian?: boolean | undefined): void;
    static getBigInt64(view: DataView, byteOffset: number, littleEndian?: boolean | undefined): JSBI;
    static setBigUint64(view: DataView, byteOffset: number, value: JSBI, littleEndian?: boolean | undefined): void;
    static getBigUint64(view: DataView, byteOffset: number, littleEndian?: boolean | undefined): JSBI;
}
export class DataViewJSBIHelperWithBigInt {
    static setBigInt64(view: DataView, byteOffset: number, value: JSBI, littleEndian?: boolean | undefined): void;
    static getBigInt64(view: DataView, byteOffset: number, littleEndian?: boolean | undefined): JSBI;
    static setBigUint64(view: DataView, byteOffset: number, value: JSBI, littleEndian?: boolean | undefined): void;
    static getBigUint64(view: DataView, byteOffset: number, littleEndian?: boolean | undefined): JSBI;
}

export class BuckyFixedBuffer implements RawEncode {
    buffer: Uint8Array;
    constructor(buffer: Uint8Array);
    raw_measure(ctx?: any, purpose?: RawEncodePurpose): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any, purpose?: RawEncodePurpose): BuckyResult<Uint8Array>;
    value(): Uint8Array;
}
export class BuckyFixedBufferDecoder implements RawDecode<BuckyFixedBuffer> {
    size: number;
    constructor(size: number);
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[BuckyFixedBuffer, Uint8Array]>;
}
export class BuckyBuffer implements RawEncode {
    buffer: Uint8Array;
    size: BuckySize;
    constructor(buf: Uint8Array);
    value(): Uint8Array;
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
}
export class BuckyBufferDecoder implements RawDecode<BuckyBuffer> {
    raw_decode(buf: Uint8Array): BuckyResult<[BuckyBuffer, Uint8Array]>;
}
export function fromHexString(hexString: string): Uint8Array;
export function toHexString(bytes: Uint8Array): string;

export class BuckyHashMapKeys<K, V> implements Iterable<K> {
    values: IterableIterator<[K, V]>;
    constructor(values: IterableIterator<[K, V]>);
    [Symbol.iterator](): this;
    next(): IteratorResult<K>;
}
export class BuckyHashMapValues<K, V> implements Iterable<V> {
    values: IterableIterator<[K, V]>;
    constructor(values: IterableIterator<[K, V]>);
    [Symbol.iterator](): this;
    next(): IteratorResult<V>;
}
export class BuckyHashMapEntries<K, V> implements Iterable<[K, V]> {
    values: IterableIterator<[K, V]>;
    constructor(values: IterableIterator<[K, V]>);
    [Symbol.iterator](): this;
    next(): IteratorResult<[K, V]>;
}
export class BuckyHashMap<K extends RawEncode & Compareable<K>, V extends RawEncode> implements RawEncode {
    constructor();
    get size(): number;
    clear(): void;
    delete(key: K): void;
    has(key: K): boolean;
    set(key: K, v: V): void;
    get(key: K): V | undefined;
    keys(): IterableIterator<K>;
    values(): IterableIterator<V>;
    entries(): IterableIterator<[K, V]>;
    forEach(callback: (value: V, key: K, map: BuckyHashMap<K, V>) => void): void;
    to<K1, V1>(ke: (k: K) => K1, ve: (v: V) => V1): Map<K1, V1>;
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
}
export class BuckyHashMapDecoder<K extends RawEncode & Compareable<K>, V extends RawEncode> implements RawDecode<BuckyHashMap<K, V>> {
    readonly size_decoder: BuckySizeDecoder;
    readonly key_decoder: RawDecode<K>;
    readonly value_decoder: RawDecode<V>;
    constructor(key_decoder: RawDecode<K>, value_decoder: RawDecode<V>);
    raw_decode(buf: Uint8Array): BuckyResult<[BuckyHashMap<K, V>, Uint8Array]>;
}

export class BuckyHashSetValues<V> implements Iterable<V> {
    values: IterableIterator<V>;
    constructor(values: IterableIterator<V>);
    [Symbol.iterator](): this;
    next(): IteratorResult<V>;
}
export class BuckyHashSetEntries<V> implements Iterable<[V, V]> {
    values: IterableIterator<V>;
    constructor(values: IterableIterator<V>);
    [Symbol.iterator](): this;
    next(): IteratorResult<[V, V]>;
}
export class BuckyHashSet<T extends RawEncode & Compareable<T>> implements RawEncode {
    constructor();
    get size(): number;
    add(v: T): BuckyHashSet<T>;
    clear(): void;
    delete(v: T): boolean;
    has(v: T): boolean;
    keys(): IterableIterator<T>;
    values(): IterableIterator<T>;
    entries(): IterableIterator<[T, T]>;
    forEach(callback: (value: T, value2: T, set: BuckyHashSet<T>) => void): void;
    to<K1>(ke: (k: T) => K1): Set<K1>;
    array(): T[];
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
}
export class BuckyHashSetDecoder<T extends RawEncode & Compareable<T>> implements RawDecode<BuckyHashSet<T>> {
    readonly decoder: RawDecode<T>;
    readonly size_decoder: BuckySizeDecoder;
    constructor(decoder: RawDecode<T>);
    raw_decode(buf: Uint8Array): BuckyResult<[BuckyHashSet<T>, Uint8Array]>;
}

export class BuckyMap<K extends RawEncode, V extends RawEncode> implements RawEncode {
    constructor(val: Map<K, V>);
    static from<K extends RawEncode, V extends RawEncode, K1, V1>(val: Map<K1, V1>, ke: (k: K1) => K, ve: (v: V1) => V): BuckyMap<K, V>;
    value(): Map<K, V>;
    to<K1, V1>(ke: (k: K) => K1, ve: (v: V) => V1): Map<K1, V1>;
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
}
export class BuckyMapDecoder<K extends RawEncode, V extends RawEncode> implements RawDecode<BuckyMap<K, V>> {
    readonly size_decoder: BuckySizeDecoder;
    readonly key_decoder: RawDecode<K>;
    readonly value_decoder: RawDecode<V>;
    constructor(key_decoder: RawDecode<K>, value_decoder: RawDecode<V>);
    raw_decode(buf: Uint8Array): BuckyResult<[BuckyMap<K, V>, Uint8Array]>;
}

/**
    * 基础类型的编解码实现，经过探索，最合适的实现方式
    * 1. 实现一个类，扩展RawEcode
    * 2. 这个类内部持有基础类型
    * 3. 编解码保持和Rust对应类型的一致实现
    * 4. 使用方式全部采用先构造编解码对象，再调用编解码方法
    * 5. 构造编解码对象，构造函数可以传入额外的上下文，相当于每个编解码对象都是带上下文的
    * 6. JavaScript/TypeScript提供了灵活性，有些地方可以大幅度合并
    */
type Int = "u8" | "i8" | "u16" | "i16" | "u32" | "i32" | "u64" | "i64" | "u128";
/**
    * JavaScript真不是一个严肃的语言，整形都能搞的这么麻烦，玩具啊
    */
export class BuckyNumber implements RawEncode {
        readonly type: Int;
        val: JSBI;
        constructor(type: Int, val: JSBI | number | string);
        value(): JSBI;
        raw_measure(): BuckyResult<number>;
        raw_encode(buf: Uint8Array, littleEndian?: boolean): BuckyResult<Uint8Array>;
        toBigInt(): JSBI;
        toNumber(): number;
}
export class BuckyNumberDecoder implements RawDecode<BuckyNumber> {
        readonly type: Int;
        constructor(type: Int);
        raw_decode(buf: Uint8Array, littleEndian?: boolean): BuckyResult<[BuckyNumber, Uint8Array]>;
}
export {};

export class BuckyResultEncoder<T extends RawEncode, E extends RawEncode> implements RawEncode {
    result: Result<T, E>;
    constructor(result: Result<T, E>);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class BuckyResultDecoder<T extends RawEncode, D extends RawDecode<T>, E extends RawEncode, ED extends RawDecode<E>> implements RawDecode<Result<T, E>> {
    decoder: D;
    error_decoder: ED;
    constructor(decoder: D, error_decoder: ED);
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[Result<T, E>, Uint8Array]>;
}

export class BuckySet<T extends RawEncode> implements RawEncode {
    constructor(val: Set<T>);
    value(): Set<T>;
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
}
export class BuckySetDecoder<T extends RawEncode> implements RawDecode<BuckySet<T>> {
    readonly decoder: RawDecode<T>;
    readonly size_decoder: BuckySizeDecoder;
    constructor(decoder: RawDecode<T>);
    raw_decode(buf: Uint8Array): BuckyResult<[BuckySet<T>, Uint8Array]>;
}

export class BuckyString implements RawEncode, Compareable<BuckyString> {
    constructor(value: string);
    hashCode(): symbol;
    equals(other: BuckyString): boolean;
    value(): string;
    toString(): string;
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class BuckyStringDecoder implements RawDecode<BuckyString> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[BuckyString, Uint8Array]>;
}
export class BuckyVarString implements RawEncode, Compareable<BuckyVarString> {
    constructor(value: string);
    hashCode(): symbol;
    equals(other: BuckyVarString): boolean;
    value(): string;
    toString(): string;
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class BuckyVarStringDecoder implements RawDecode<BuckyVarString> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[BuckyVarString, Uint8Array]>;
}

export class BuckySize implements RawEncode {
    constructor(size: number | JSBI | string);
    raw_measure(ctx?: any, purpose?: RawEncodePurpose): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any, purpose?: RawEncodePurpose): BuckyResult<Uint8Array>;
}
export class BuckySizeDecoder implements RawDecode<number> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[number, Uint8Array]>;
}

export class BuckyTuple implements RawEncode {
    members: RawEncode[];
    constructor(members: RawEncode[]);
    raw_measure(ctx?: any, purpose?: RawEncodePurpose): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any, purpose?: RawEncodePurpose): BuckyResult<Uint8Array>;
    index<T extends RawEncode>(index: number): T;
}
export class BuckyTupleDecoder<U extends RawEncode, T extends RawDecode<U>> implements RawDecode<BuckyTuple> {
    decoders: T[];
    constructor(decoders: T[]);
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[BuckyTuple, Uint8Array]>;
}

global {
    interface Uint8Array {
        offset(offset: number): Uint8Array;
        offsetUint16Array(offset: number): Uint16Array;
        offsetUint32Array(offset: number): Uint32Array;
        offsetView(offset: number): DataView;
        toHex(): string;
        fromHex(hex: string): BuckyResult<Uint8Array>;
    }
}
export {};

export enum Protocol {
    Unk = 0,
    Tcp = 1,
    Udp = 2
}
export class IpAddr implements RawEncode {
    is_ipv4: boolean;
    ip: string;
    static V4(ip: string): IpAddr;
    static V6(ip: string): IpAddr;
    match<T>(visitor: {
        V4?: (ip: string) => T;
        V6?: (ip: string) => T;
    }): T | undefined;
    toString(): string;
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class IpAddrDecoder implements RawDecode<IpAddr> {
    raw_decode(buf: Uint8Array): BuckyResult<[IpAddr, Uint8Array]>;
}
export class SocketAddr implements RawEncode {
    is_ipv4: boolean;
    ip: string;
    port: number;
    constructor(is_ipv4: boolean, ip: string, port: number);
    toString(): string;
    static fromString(is_ipv4: boolean, addr: string): BuckyResult<SocketAddr>;
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class Endpoint implements RawEncode {
    is_static_wan: boolean;
    protocol: Protocol;
    addr: SocketAddr;
    constructor(is_static_wan: boolean, protocol: Protocol, addr: SocketAddr);
    static fromString(endpoint: string): BuckyResult<Endpoint>;
    toString(): string;
    flag(): number;
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class EndPointDecoder implements RawDecode<Endpoint> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[Endpoint, Uint8Array]>;
}

export function log(...args: any[]): void;
export function warn(...args: any[]): void;
export function error(...args: any[]): void;
export const cyfs_log_config: {
    enable_base_log: boolean;
    enable_base_trace: boolean;
    enable_base_warn: boolean;
    enable_base_error: boolean;
};
export function base_log(...args: any[]): void;
export function base_trace(...args: any[]): void;
export function base_warn(...args: any[]): void;
export function base_error(...args: any[]): void;

export const CYFS_OBJECT_ID = "cyfs-object-id";
export const CYFS_OBJECT = "cyfs-object";
export const CYFS_RESULT = "cyfs-result";
export const CYFS_API_LEVEL = "cyfs-api-level";
export const CYFS_NON_ACTION = "cyfs-non-action";
export const CYFS_NDN_ACTION = "cyfs-ndn-action";
export const CYFS_DEC_ID = "cyfs-dec-id";
export const CYFS_FILTER_DEC_ID = "cyfs-filter-dec-id";
export const CYFS_INNER_PATH = "cyfs-inner-path";
export const CYFS_OWNER_ID = "cyfs-owner-id";
export const CYFS_AUTHOR_ID = "cyfs-author-id";
export const CYFS_DEVICE_ID = "cyfs-device-id";
export const CYFS_OOD_DEVICE_ID = "cyfs-ood-device-id";
export const CYFS_ZONE_ID = "cyfs-zone-id";
export const CYFS_ATTRIBUTES = "cyfs-attributes";
export const CYFS_FILE_TYPE = "cyfs-file-type";
export const CYFS_SIGN_OBJ_ID = "cyfs-sign-obj-id";
export const CYFS_SIGN_OBJ = "cyfs-sign-obj";
export const CYFS_VERIFY_SIGNS = "cyfs-verify-signs";
export const CYFS_VERIFY_TYPE = "cyfs-verify-type";
export const CYFS_SIGN_TYPE = "cyfs-sign-type";
export const CYFS_SIGN_FLAGS = "cyfs-sign-flags";
export const CYFS_VERIFY_RET = "cyfs-verify-ret";
export const CYFS_SIGN_RET = "cyfs-sign-ret";
export const CYFS_FLAGS = "cyfs-flags";
export const CYFS_TARGET = "cyfs-target";
export const CYFS_REFERER_OBJECT = "cyfs-referer-object";
export const CYFS_FILTER_FLAGS = "cyfs-filter-flags";
export const CYFS_TIMEOUT = "cyfs-timeout";
export const CYFS_OBJ_TYPE = "cyfs-obj-type";
export const CYFS_OBJ_TYPE_CODE = "cyfs-obj-type-code";
export const CYFS_CREATE_TIME = "cyfs-create-time";
export const CYFS_UPDATE_TIME = "cyfs-update-time";
export const CYFS_INSERT_TIME = "cyfs-insert-time";
export const CYFS_PAGE_SIZE = "cyfs-page-size";
export const CYFS_PAGE_INDEX = "cyfs-page-index";
export const CYFS_OBJECTS = "cyfs-objects";
export const CYFS_OBJECT_UPDATE_TIME = "cyfs-object-update-time";
export const CYFS_OBJECT_EXPIRES_TIME = "cyfs-object-expires-time";
export const CYFS_CHUNK_STATE = "cyfs-chunk-state";
export const CYFS_CHUNK_EXIST = "cyfs-chunk-exist";
export const CYFS_REMOTE_DEVICE = "cyfs-remote-device";
export const CYFS_REMOTE_VPORT = "cyfs-remote-vport";

export interface BaseOption<T> {
    is_some(): boolean;
    is_none(): boolean;
    unwrap(): T;
    ok_or(): BuckyResult<T>;
    to<V1>(ve: (v: T) => V1): Option<V1>;
    map(mapper: (obj: T) => T): void;
}
export class SomeOption<T> implements BaseOption<T> {
    constructor(value: T);
    is_some(): boolean;
    is_none(): boolean;
    unwrap(): T;
    ok_or(): BuckyResult<T>;
    to<V1>(ve: (v: T) => V1): Option<V1>;
    map(mapper: (obj: T) => T): void;
}
export class NoneOption implements BaseOption<never> {
    constructor();
    is_some(): boolean;
    is_none(): boolean;
    unwrap(): never;
    ok_or(): BuckyResult<never>;
    to<V1>(ve: (v: never) => V1): NoneOption;
    map(mapper: (obj: never) => never): void;
}
export type Option<T> = (SomeOption<T> | NoneOption) & BaseOption<T>;
export function Some<T>(val: T): Option<T>;
export const None: NoneOption;
export class OptionEncoder<T extends RawEncode> implements RawEncode {
    val: Option<T>;
    constructor(val: Option<T>);
    value(): Option<T>;
    static from<V extends RawEncode, V1>(val: Option<V1>, ve: (v: V1) => V): OptionEncoder<V>;
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
}
export class OptionWrapper<T extends RawEncode> implements RawEncode {
    constructor(v: Option<T>);
    value(): Option<T>;
    to<V1>(ve: (v: T) => V1): Option<V1>;
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class OptionDecoder<T extends RawEncode> implements RawDecode<OptionWrapper<T>> {
    readonly decoder: RawDecode<T>;
    constructor(decoder: RawDecode<T>);
    raw_decode(buf: Uint8Array): BuckyResult<[OptionWrapper<T>, Uint8Array]>;
}

export const CHUNK_MANAGER_PORT: number;
export const FILE_MANAGER_PORT: number;
export const ACC_SERVICE_PORT: number;
export const GATEWAY_CONTROL_PORT: number;
export const NON_STACK_HTTP_PORT: number;
export const NON_STACK_WS_PORT: number;
export const OOD_DAEMON_CONTROL_PORT: number;
export const CYFS_RUNTIME_DAEMON_CONTROL_PORT: number;
export const CYFS_RUNTIME_NON_STACK_HTTP_PORT: number;
export const CYFS_RUNTIME_NON_STACK_WS_PORT: number;
export const OOD_BDT_STACK_PORT: number;
export const CYFS_RUNTIME_BDT_STACK_PORT: number;
export const NON_STACK_BDT_VPORT: number;
export const NON_STACK_SYNC_BDT_VPORT: number;
export const PROXY_MINER_SOCKS5_PORT: number;
export const IP_RELAY_MINER_PORT: number;
export const CYFS_META_MINER_PORT: number;
export const CACHE_MINER_PORT: number;
export const DNS_PROXY_MINER_PORT: number;
export const ALWAYS_RUN_MINER_PORT: number;
export const DSG_CHAIN_MINER_PORT: number;

/**
    * 编码接口
    */
export enum RawEncodePurpose {
        Serialize = 0,
        Hash = 1
}
export interface RawEncode {
        raw_measure(ctx?: any, purpose?: RawEncodePurpose): BuckyResult<number>;
        raw_encode(buf: Uint8Array, ctx?: any, purpose?: RawEncodePurpose): BuckyResult<Uint8Array>;
        encode_to_buf?: (purpose?: RawEncodePurpose) => BuckyResult<Uint8Array>;
        raw_hash_encode?: () => BuckyResult<HashValue>;
}
/**
    * 编码类型构造器
    */
export type EncodeBuilder<T extends RawEncode> = new (...constructorArgs: any[]) => T;
/**
    * 解码接口
    */
export class ContentRawDecodeContext {
        readonly version: number;
        readonly format: number;
        constructor(version: number, format: number);
}
export interface RawDecode<T> {
        raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[T, Uint8Array]>;
}
export abstract class RawHexDecode<T> implements RawDecode<T> {
        raw_decode_from_hex(hex: string): BuckyResult<[T, Uint8Array]>;
        abstract raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[T, Uint8Array]>;
}
/**
    * 解码类型构造器
    */
export type DecodeBuilder<T extends RawEncode, D extends RawDecode<T>> = new (...constructorArgs: any[]) => D;
export interface Compareable<T> {
        hashCode(): symbol;
        equals(other: T): boolean;
}
export function to_buf<T extends RawEncode>(self: T): BuckyResult<Uint8Array>;
export function to_vec<T extends RawEncode>(self: T): BuckyResult<Uint8Array>;
export function to_hex<T extends RawEncode>(self: T): BuckyResult<string>;
export function from_buf<T>(buf: Uint8Array, decoder: RawDecode<T>): BuckyResult<T>;
export function from_hex<T extends RawEncode, D extends RawDecode<T>>(decoder: D, hex: string): BuckyResult<T>;
export function buffer_from_hex(hex: string): BuckyResult<Uint8Array>;

/**
    * 编码并计算哈希
    * @param t 实现了RawEncode的对象
    */
export function raw_hash_encode<T extends RawEncode>(t: T): BuckyResult<HashValue>;
/**
    * 计算哈希并解码
    * @param decoder 解码器
    * @param buf 待解码的Buffer
    */
export function raw_hash_decode<T, D extends RawDecode<T>>(decoder: D, buf: Uint8Array): BuckyResult<[HashValue, Uint8Array]>;

export const BUCKY_SYSTEM_ERROR_CODE_START = 0;
export const BUCKY_SYSTEM_ERROR_CODE_END = 5000;
export const BUCKY_META_ERROR_CODE_START = 5000;
export const BUCKY_META_ERROR_CODE_END = 6000;
export const BUCKY_META_ERROR_CODE_MAX: number;
export const BUCKY_DEC_ERROR_CODE_START = 15000;
export const BUCKY_DEC_ERROR_CODE_END = 65535;
export const BUCKY_DEC_ERROR_CODE_MAX: number;
export enum BuckyErrorCode {
    Ok = 0,
    Failed = 1,
    InvalidParam = 2,
    Timeout = 3,
    NotFound = 4,
    AlreadyExists = 5,
    NotSupport = 6,
    ErrorState = 7,
    InvalidFormat = 8,
    Expired = 9,
    OutOfLimit = 10,
    InternalError = 11,
    PermissionDenied = 12,
    ConnectionRefused = 13,
    ConnectionReset = 14,
    ConnectionAborted = 15,
    NotConnected = 16,
    AddrInUse = 18,
    AddrNotAvailable = 19,
    Interrupted = 20,
    InvalidInput = 21,
    InvalidData = 22,
    WriteZero = 23,
    UnexpectedEof = 24,
    BrokenPipe = 25,
    WouldBlock = 26,
    UnSupport = 27,
    Unmatch = 28,
    ExecuteError = 29,
    Reject = 30,
    Ignored = 31,
    InvalidSignature = 32,
    AlreadyExistsAndSignatureMerged = 33,
    ConnectFailed = 40,
    ConnectInterZoneFailed = 41,
    MongoDBError = 99,
    SqliteError = 100,
    UrlError = 101,
    ZipError = 102,
    HttpError = 103,
    JsonError = 104,
    HexError = 105,
    RsaError = 106,
    CryptoError = 107,
    MpscSendError = 108,
    MpscRecvError = 109,
    CodeError = 250,
    UnknownBdtError = 253,
    UnknownIOError = 254,
    Unknown = 255,
    Pending = 256,
    NotChange = 257,
    NotMatch = 258,
    NotImplement = 259,
    NotInit = 260,
    ParseError = 261,
    MetaError = 5000,
    DecError = 15000
}
export class BuckyErrorCodeEx {
    readonly m_code: BuckyErrorCode;
    readonly m_value: number;
    get code(): BuckyErrorCode;
    get value(): number;
    is_system_error(): boolean;
    is_meta_error(): boolean;
    is_dec_error(): boolean;
    to_number(): number;
    static parse(code: number | string): BuckyErrorCodeEx;
    constructor(code: BuckyErrorCode, value: number);
}
export function is_system_error_code(code: number): boolean;
export function is_meta_error_code(code: number): boolean;
export function is_dec_error_code(code: number): boolean;
export function new_meta_error(meta_err: number): BuckyErrorCodeEx;
export function new_dec_error(dec_err: number): BuckyErrorCodeEx;
export function error_code_from_number(err: number): BuckyErrorCodeEx;
export class BuckyError {
    readonly m_code: BuckyErrorCodeEx;
    readonly m_msg: string;
    readonly m_origin?: string;
    constructor(code: number | string | BuckyErrorCodeEx, msg: string, origin?: string);
    static new_meta_error(meta_err: number, msg: string, origin?: string): BuckyError;
    static new_dec_error(dec_err: number, msg: string, origin?: string): BuckyError;
    static from(arg: string | BuckyErrorCode): BuckyError;
    get code(): BuckyErrorCode;
    get code_ex(): BuckyErrorCodeEx;
    is_system_error(): boolean;
    is_meta_error(): boolean;
    is_dec_error(): boolean;
    get value(): number;
    get msg(): string;
    get origin(): string | undefined;
    format(): string;
    error_with_log<T>(msg: string): BuckyResult<T>;
    toString(): string;
}
export type BuckyResult<T> = Result<T, BuckyError>;

export function bucky_time_now(): JSBI;
export function bucky_time(date: Date): JSBI;
export function bucky_time_2_js_time(val: JSBI): number;
export function bucky_time_2_js_date(val: JSBI): Date;
export function js_time_to_bucky_time(val: number): JSBI;
export function js_date_to_bucky_time(date: Date): JSBI;
export function sleep(ms: number): Promise<unknown>;

export class Vec<T extends RawEncode> implements RawEncode {
    constructor(val: T[]);
    value(): T[];
    static from<V extends RawEncode, V1>(val: V1[], ve: (v: V1) => V): Vec<V>;
    to<V1>(ve: (v: T) => V1): V1[];
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
}
export class VecDecoder<T extends RawEncode> implements RawDecode<Vec<T>> {
    readonly size_decoder: BuckySizeDecoder;
    readonly decoder: RawDecode<T>;
    constructor(decoder: RawDecode<T>);
    raw_decode(buf: Uint8Array): BuckyResult<[Vec<T>, Uint8Array]>;
}

export function get_country_list(): any;
export function get_area_info(country_id: string, city_id: string): {
    country_name: string;
    state_name: string;
    city_name: string;
} | null;

export const CFYS_ROOT_NAME: string;
export function default_cyfs_root_path(): string;
export function bind_cyfs_root_path(root_path: string): void;
export function get_cyfs_root_path(): string;
export function get_temp_path(): string;
export function get_log_dir(service_name: string): string;
export function get_app_log_dir(app_name: string): string;
export function get_app_data_dir(app_name: string): string;

export interface EventListenerAsyncRoutine<R> {
    call(param: any): Promise<BuckyResult<R>>;
}
export interface EventListenerAsyncRoutineT<P, R> {
    call(param: P): Promise<BuckyResult<R>>;
}

export const OBJECT_CONTENT_CODEC_FORMAT_RAW: number;
export const OBJECT_CONTENT_CODEC_FORMAT_PROTOBUF: number;
export const OBJECT_CONTENT_CODEC_FORMAT_JSON: number;

export { protos };

/**
    * KeyMixHash
    */
export const KEY_MIX_LEN: number;
export class KeyMixHash implements RawEncode {
        m_buf: Uint8Array;
        constructor(buf: Uint8Array);
        as_slice(): Uint8Array;
        length(): number;
        static default(): KeyMixHash;
        static copy_from_slice(buf: Uint8Array): KeyMixHash;
        raw_measure(): BuckyResult<number>;
        raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
}
export class KeyMixHashDecoder implements RawDecode<KeyMixHash> {
        raw_decode(buf: Uint8Array): BuckyResult<[KeyMixHash, Uint8Array]>;
}
/**
    * AesKey
    */
export const AES_KEY_LEN: number;
export class AesKey implements RawEncode {
        m_buf: Uint8Array;
        constructor(buf: Uint8Array);
        as_slice(): Uint8Array;
        length(): number;
        static default(): AesKey;
        static random(): AesKey;
        static mix_hash(salt: Option<JSBI>): KeyMixHash;
        static copy_from_slice(buf: Uint8Array): AesKey;
        raw_measure(): BuckyResult<number>;
        raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
}
export class AesKeyDecoder implements RawDecode<AesKey> {
        raw_decode(buf: Uint8Array): BuckyResult<[AesKey, Uint8Array]>;
}

export const HASH_VALUE_LEN = 32;
export class HashValue implements RawEncode {
    m_buf: Uint8Array;
    constructor(buf: Uint8Array);
    as_slice(): Uint8Array;
    length(): number;
    static default(): HashValue;
    static copy_from_slice(buf: Uint8Array): HashValue;
    static hash_data(data: Uint8Array): HashValue;
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
    to_base_58(): string;
}
export class HashValueDecoder implements RawDecode<HashValue> {
    raw_decode(buf: Uint8Array): BuckyResult<[HashValue, Uint8Array]>;
}

export abstract class PrivateKey implements RawEncode {
    readonly type: number;
    constructor(type: number);
    abstract raw_measure(ctx?: any, purpose?: RawEncodePurpose): BuckyResult<number>;
    abstract raw_encode(buf: Uint8Array, ctx?: any, purpose?: RawEncodePurpose): BuckyResult<Uint8Array>;
    toString(): string;
    static generate_rsa(bits: number): BuckyResult<PrivateKey>;
    static generate_secp256k1(): BuckyResult<PrivateKey>;
    static generate_sm2(): BuckyResult<PrivateKey>;
    abstract public(): PublicKey;
    abstract sign(data: Uint8Array, sign_source: SignatureSource): Signature;
    abstract decrypt(input: Uint8Array, out: Uint8Array): BuckyResult<number>;
    to_vec(): BuckyResult<Uint8Array>;
}
export class RSAPrivateKey extends PrivateKey {
    code: number;
    value: NodeRSA;
    constructor(code: number, value: NodeRSA);
    raw_measure(ctx?: any, purpose?: RawEncodePurpose): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any, purpose?: RawEncodePurpose): BuckyResult<Uint8Array>;
    public(): PublicKey;
    sign(data: Uint8Array, sign_source: SignatureSource): Signature;
    decrypt(input: Uint8Array, out: Uint8Array): BuckyResult<number>;
}
export class Secp256k1PrivateKey extends PrivateKey {
    constructor();
    raw_measure(ctx?: any, purpose?: RawEncodePurpose): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any, purpose?: RawEncodePurpose): BuckyResult<Uint8Array>;
    public(): PublicKey;
    sign(data: Uint8Array, sign_source: SignatureSource): Signature;
    decrypt(input: Uint8Array, out: Uint8Array): BuckyResult<number>;
}
export class SM2PrivateKey extends PrivateKey {
    constructor();
    raw_measure(ctx?: any, purpose?: RawEncodePurpose): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any, purpose?: RawEncodePurpose): BuckyResult<Uint8Array>;
    public(): PublicKey;
    sign(data: Uint8Array, sign_source: SignatureSource): Signature;
    decrypt(input: Uint8Array, out: Uint8Array): BuckyResult<number>;
}
export class PrivatekeyDecoder implements RawDecode<PrivateKey> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[PrivateKey, Uint8Array]>;
}

/*************************************
    * 签名
    *************************************/
export const SIGNATURE_REF_INDEX: number;
export const SIGNATURE_OBJECT: number;
export const SIGNATURE_KEY: number;
export const SIGNATURE_SOURCE_REFINDEX_REF_OBJ_BEGIN: number;
export const SIGNATURE_SOURCE_REFINDEX_REF_OBJ_END: number;
export const SIGNATURE_SOURCE_REFINDEX_SELF: number;
export const SIGNATURE_SOURCE_REFINDEX_OWNER: number;
export const SIGNATURE_SOURCE_REFINDEX_AUTHOR: number;
export const SIGNATURE_SOURCE_REFINDEX_ZONE_OOD_BEGIN: number;
export const SIGNATURE_SOURCE_REFINDEX_ZONE_OOD_END: number;
export const SIGN_DATA_FLAG_RSA1024: number;
export const SIGN_DATA_FLAG_RSA2048: number;
export const SIGN_DATA_FLAG_ECC: number;
export const SIGN_DATA_LEN_RSA1024: number;
export const SIGN_DATA_LEN_RSA2048: number;
export const SIGN_DATA_LEN_ECC: number;
export const SIGN_DATA_UNIT = 4;
export const SIGN_DATA_SIZE_RSA1024: number;
export const SIGN_DATA_SIZE_RSA2048: number;
export const SIGN_DATA_SIZE_ECC: number;
export interface SignDataPartten<T> {
        Rsa1024SignData: (obj: Rsa1024SignData) => T;
        Rsa2048SignData: (obj: Rsa2048SignData) => T;
        EccSignData: (obj: EccSignData) => T;
}
export interface SignDataVisitor {
        match<T>(p: SignDataPartten<T>): T;
}
export abstract class SignDataBase implements RawEncode {
        type: number;
        value: Uint8Array;
        constructor(type: number, value: Uint8Array);
        as_slice(): Uint8Array;
        raw_measure(): BuckyResult<number>;
        raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
        to_base_58(): string;
}
export class SignDataDecoder implements RawDecode<SignData> {
        constructor();
        raw_decode(buf: Uint8Array): BuckyResult<[SignData, Uint8Array]>;
}
export class Rsa1024SignData extends SignDataBase implements SignDataVisitor {
        constructor(value: Uint8Array);
        match<T>(p: SignDataPartten<T>): T;
}
export class Rsa2048SignData extends SignDataBase implements SignDataVisitor {
        constructor(value: Uint8Array);
        match<T>(p: SignDataPartten<T>): T;
}
export class EccSignData extends SignDataBase implements SignDataVisitor {
        constructor(value: Uint8Array);
        match<T>(p: SignDataPartten<T>): T;
}
export type SignData = Rsa1024SignData | Rsa2048SignData | EccSignData;
export interface SignatureSourcePattern<T> {
        RefIndex: (s: number) => T;
        Object: (s: ObjectLink) => T;
        Key: (s: PublicKeyValue) => T;
}
export interface SignatureSourceMatch {
        match<T>(p: SignatureSourcePattern<T>): T;
}
export class SignatureRefIndex implements SignatureSourceMatch {
        s: number;
        constructor(s: number);
        match<T>(p: SignatureSourcePattern<T>): T;
}
export class SignatureObject implements SignatureSourceMatch {
        s: ObjectLink;
        constructor(s: ObjectLink);
        match<T>(p: SignatureSourcePattern<T>): T;
}
export class SignatureKey implements SignatureSourceMatch {
        s: PublicKeyValue;
        constructor(s: PublicKeyValue);
        match<T>(p: SignatureSourcePattern<T>): T;
}
export type SignatureSource = SignatureRefIndex | SignatureObject | SignatureKey;
export type SignatureSourceLite = number | ObjectLink | PublicKeyValue;
export class Signature implements RawEncode {
        m_sign_source: SignatureSource;
        m_sign_key_index: number;
        m_sign_time: JSBI;
        m_sign: SignData;
        constructor(sign_source: SignatureSource, sign_key_index: number, sign_time: JSBI, sign: SignData);
        get sign_key_index(): number;
        get sign_time(): JSBI;
        get sign_source(): SignatureSource;
        get sign(): SignData;
        sign_source_with_ref_index(): number;
        raw_measure(): BuckyResult<number>;
        raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
}
export class SignatureDecoder implements RawDecode<Signature> {
        raw_decode(buf: Uint8Array): BuckyResult<[Signature, Uint8Array]>;
}
/*************************************
    * 公玥
    *************************************/
export const RAW_PUBLIC_KEY_RSA_1024_CODE: number;
export const RAW_PUBLIC_KEY_RSA_1024_LENGTH: number;
export const RAW_PUBLIC_KEY_RSA_2048_CODE: number;
export const RAW_PUBLIC_KEY_RSA_2048_LENGTH: number;
export const RAW_PUBLIC_KEY_RSA_3072_CODE: number;
export const RAW_PUBLIC_KEY_RSA_3072_LENGTH: number;
export const RAW_PUBLIC_KEY_SECP256K1_CODE: number;
export const RAW_PUBLIC_KEY_SECP256K1_LENGTH: number;
export const RAW_PUBLIC_KEY_SM2_CODE: number;
export const RAW_PUBLIC_KEY_SM2_LENGTH: number;
export const KEY_TYPE_RSA: number;
export const KEY_TYPE_RSA2048: number;
export const KEY_TYPE_SECP256K1: number;
export const KEY_TYPE_SM2: number;
export interface PublicKeyPattern<T> {
        RSAPublicKey: (obj: RSAPublicKey) => T;
        Secp256k1PublicKey: (obj: Secp256k1PublicKey) => T;
        SM2PublicKey: (obj: SM2PublicKey) => T;
}
export interface PublicKeyMatcher {
        match<T>(p: PublicKeyPattern<T>): T;
}
export abstract class PublicKeyBase implements RawEncode {
        threshold: number;
        code: number;
        constructor(code: number, buffer: Uint8Array);
        abstract key_size(): number;
        abstract encrypt(data: Uint8Array, output: Uint8Array): BuckyResult<number>;
        abstract gen_aeskey_and_encrypt(): BuckyResult<[AesKey, Uint8Array]>;
        abstract verify(data: Uint8Array, sign: Signature): boolean;
        toJSON(): string;
        raw_measure(): BuckyResult<number>;
        raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
        abstract as_public_value(): PublicKeyValue;
        to_base_58(): string;
}
export class RSAPublicKey extends PublicKeyBase implements PublicKeyMatcher {
        constructor(code: number, buffer: Uint8Array);
        key_size(): number;
        encrypt(data: Uint8Array, output: Uint8Array): BuckyResult<number>;
        gen_aeskey_and_encrypt(): BuckyResult<[AesKey, Uint8Array]>;
        verify(data: Uint8Array, sign: Signature): boolean;
        match<T>(p: PublicKeyPattern<T>): T;
        as_public_value(): PublicKeyValue;
}
export class Secp256k1PublicKey extends PublicKeyBase implements PublicKeyMatcher {
        constructor(buffer: Uint8Array);
        key_size(): number;
        encrypt(data: Uint8Array, output: Uint8Array): BuckyResult<number>;
        gen_aeskey_and_encrypt(): BuckyResult<[AesKey, Uint8Array]>;
        verify(data: Uint8Array, sign: Signature): boolean;
        match<T>(p: PublicKeyPattern<T>): T;
        as_public_value(): PublicKeyValue;
}
export class SM2PublicKey extends PublicKeyBase implements PublicKeyMatcher {
        constructor(buffer: Uint8Array);
        key_size(): number;
        encrypt(data: Uint8Array, output: Uint8Array): BuckyResult<number>;
        gen_aeskey_and_encrypt(): BuckyResult<[AesKey, Uint8Array]>;
        verify(data: Uint8Array, sign: Signature): boolean;
        match<T>(p: PublicKeyPattern<T>): T;
        as_public_value(): PublicKeyValue;
}
export type PublicKey = RSAPublicKey | Secp256k1PublicKey | SM2PublicKey;
export class PublicKeyDecoder implements RawDecode<PublicKey> {
        constructor();
        raw_decode(buf: Uint8Array): BuckyResult<[PublicKey, Uint8Array]>;
}
export class MNPublicKey implements RawEncode {
        threshold: number;
        keys: Vec<PublicKey>;
        constructor(threshold: number, keys: Vec<PublicKey>);
        raw_measure(): BuckyResult<number>;
        raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
        as_public_value(): PublicKeyValue;
}
export class MNPublicKeyDecoder implements RawDecode<MNPublicKey> {
        constructor();
        raw_decode(buf: Uint8Array): BuckyResult<[MNPublicKey, Uint8Array]>;
}
export interface PublicKeyValuePattern<T> {
        PublicKey: (key: PublicKey) => T;
        MNPublicKey: (key: MNPublicKey) => T;
}
export interface PublicKeyValueMatch {
        match<T>(p: PublicKeyValuePattern<T>): T;
}
export class PublicKeyWithTag implements PublicKeyValueMatch, RawEncode {
        key: PublicKey;
        constructor(key: PublicKey);
        raw_measure(): BuckyResult<number>;
        raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
        match<T>(p: PublicKeyValuePattern<T>): T;
}
export class MNPublicKeyWithTag implements PublicKeyValueMatch, RawEncode {
        key: MNPublicKey;
        constructor(key: MNPublicKey);
        raw_measure(): BuckyResult<number>;
        raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
        match<T>(p: PublicKeyValuePattern<T>): T;
}
export type PublicKeyValue = PublicKeyWithTag | MNPublicKeyWithTag;
export class PublicKeyValueDecoder implements RawDecode<PublicKeyValue> {
        constructor();
        raw_decode(buf: Uint8Array): BuckyResult<[PublicKeyValue, Uint8Array]>;
}

export function sign_named_object_desc<DC extends DescContent, BC extends BodyContent>(private_key: PrivateKey, obj: NamedObject<DC, BC>, sign_source: SignatureSource): BuckyResult<Signature>;
export function sign_named_object_body<DC extends DescContent, BC extends BodyContent>(private_key: PrivateKey, obj: NamedObject<DC, BC>, sign_source: SignatureSource): BuckyResult<Signature>;
export function sign_and_push_named_object<DC extends DescContent, BC extends BodyContent>(private_key: PrivateKey, obj: NamedObject<DC, BC>, sign_source: SignatureSource): BuckyResult<{}>;
export function sign_and_set_named_object<DC extends DescContent, BC extends BodyContent>(private_key: PrivateKey, obj: NamedObject<DC, BC>, sign_source: SignatureSource): BuckyResult<{}>;

export class ActionDescTypeInfo extends DescTypeInfo {
    obj_type(): number;
    sub_desc_type(): SubDescType;
}
export class ActionDescContent extends DescContent {
    type_info(): DescTypeInfo;
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
}
export class ActionDescContentDecoder extends DescContentDecoder<ActionDescContent> {
    type_info(): DescTypeInfo;
    raw_decode(buf: Uint8Array): BuckyResult<[ActionDescContent, Uint8Array]>;
}
export class ActionBodyContent extends BodyContent {
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
}
export class ActionBodyContentDecoder extends BodyContentDecoder<ActionBodyContent> {
    raw_decode(buf: Uint8Array): BuckyResult<[ActionBodyContent, Uint8Array]>;
}
export class ActionDesc extends NamedObjectDesc<ActionDescContent> {
}
export class ActionDescDecoder extends NamedObjectDescDecoder<ActionDescContent> {
    constructor();
}
export class ActionBuilder extends NamedObjectBuilder<ActionDescContent, ActionBodyContent> {
}
export class ActionId extends NamedObjectId<ActionDescContent, ActionBodyContent> {
    constructor(id: ObjectId);
    static default(): ActionId;
    static from_base_58(s: string): BuckyResult<ActionId>;
    static try_from_object_id(id: ObjectId): BuckyResult<ActionId>;
}
export class ActionIdDecoder extends NamedObjectIdDecoder<ActionDescContent, ActionBodyContent> {
    constructor();
}
export class Action extends NamedObject<ActionDescContent, ActionBodyContent> {
    static create(build?: (builder: ActionBuilder) => void): Action;
    action_id(): ActionId;
    connect_info(): ActionBodyContent;
}
export class ActionDecoder extends NamedObjectDecoder<ActionDescContent, ActionBodyContent, Action> {
    constructor();
}

export type StandardObject = Device | People | SimpleGroup | Org | AppGroup | UnionAccount | ChunkId | Dir | File | Action | Relation | Contract;
export type CoreObject = TypelessCoreObject;
export type DECAppObject = TypelessDECAppObject;
export type AnyNamedObject = StandardObject | CoreObject | DECAppObject;
export interface AnyNamedObjectVisitor<T> {
    Standard?: (obj: StandardObject) => T;
    Core?: (obj: CoreObject) => T;
    DECApp?: (obj: DECAppObject) => T;
}
export interface StandardObjectVisitor<T> {
    Device?: (obj: Device) => T;
    People?: (obj: People) => T;
    SimpleGroup?: (obj: SimpleGroup) => T;
    Org?: (obj: Org) => T;
    AppGroup?: (obj: AppGroup) => T;
    UnionAccount?: (obj: UnionAccount) => T;
    ChunkId?: (obj: ChunkId) => T;
    File?: (obj: File) => T;
    Dir?: (obj: Dir) => T;
    Action?: (obj: Action) => T;
    Relation?: (obj: Relation) => T;
    Contract?: (obj: Contract) => T;
}
export function match_any_obj<T>(a: AnyNamedObject, visitor: AnyNamedObjectVisitor<T>): T | undefined;
export function match_standard_obj<T>(s: StandardObject, visitor: StandardObjectVisitor<T>): T | undefined;
export class StandardObjectDecoder implements RawDecode<StandardObject> {
    constructor();
    raw_decode(buf: Uint8Array): BuckyResult<[StandardObject, Uint8Array]>;
}
export class AnyNamedObjectDecoder extends RawHexDecode<AnyNamedObject> {
    constructor();
    raw_decode(buf: Uint8Array): BuckyResult<[AnyNamedObject, Uint8Array]>;
    from_raw(buf: Uint8Array): BuckyResult<AnyNamedObject>;
}

export class AppGroupDescTypeInfo extends DescTypeInfo {
    obj_type(): number;
    sub_desc_type(): SubDescType;
}
export class AppGroupDescContent extends DescContent {
    type_info(): DescTypeInfo;
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
}
export class AppGroupDescContentDecoder extends DescContentDecoder<AppGroupDescContent> {
    type_info(): DescTypeInfo;
    raw_decode(buf: Uint8Array): BuckyResult<[AppGroupDescContent, Uint8Array]>;
}
export class AppGroupBodyContent extends BodyContent {
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
}
export class AppGroupBodyContentDecoder extends BodyContentDecoder<AppGroupBodyContent> {
    raw_decode(buf: Uint8Array): BuckyResult<[AppGroupBodyContent, Uint8Array]>;
}
export class AppGroupDesc extends NamedObjectDesc<AppGroupDescContent> {
}
export class AppGroupDescDecoder extends NamedObjectDescDecoder<AppGroupDescContent> {
    constructor();
}
export class AppGroupBuilder extends NamedObjectBuilder<AppGroupDescContent, AppGroupBodyContent> {
}
export class AppGroupId extends NamedObjectId<AppGroupDescContent, AppGroupBodyContent> {
    constructor(id: ObjectId);
    static default(): AppGroupId;
    static from_base_58(s: string): BuckyResult<AppGroupId>;
    static try_from_object_id(id: ObjectId): BuckyResult<AppGroupId>;
}
export class AppGroupIdDecoder extends NamedObjectIdDecoder<AppGroupDescContent, AppGroupBodyContent> {
    constructor();
}
export class AppGroup extends NamedObject<AppGroupDescContent, AppGroupBodyContent> {
    static create(build?: (builder: AppGroupBuilder) => void): AppGroup;
    appgroup_id(): AppGroupId;
    connect_info(): AppGroupBodyContent;
}
export class AppGroupDecoder extends NamedObjectDecoder<AppGroupDescContent, AppGroupBodyContent, AppGroup> {
    constructor();
}

export class Area implements RawEncode {
    m_country: number;
    m_carrier: number;
    m_city: number;
    m_inner: number;
    constructor(country: number, carrier: number, city: number, inner: number);
    get country(): number;
    get carrier(): number;
    get city(): number;
    get inner(): number;
    static default(): Area;
    static from_str(s: string): BuckyResult<Area>;
    clone(): Area;
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
    get_area_info(): {
        country_name: string;
        state_name: string;
        city_name: string;
    } | null;
    toString(): string;
}
export class AreaDecoder implements RawDecode<Area> {
    constructor();
    raw_decode(buf: Uint8Array): BuckyResult<[Area, Uint8Array]>;
}

export const CHUNK_ID_LEN = 32;
export class ChunkIdDesc extends ObjectDesc {
    constructor(chunk_id: ChunkId);
    chunk_id(): ChunkId;
    calculate_id(): ObjectId;
    dec_id(): Option<ObjectId>;
    ref_objs(): Option<Vec<ObjectLink>>;
    prev(): Option<ObjectId>;
    create_timestamp(): Option<HashValue>;
    create_time(): JSBI;
    expired_time(): Option<JSBI>;
    owner(): Option<ObjectId> | undefined;
    area(): Option<Area> | undefined;
    author(): Option<ObjectId> | undefined;
    public_key(): PublicKey | undefined;
    mn_key(): MNPublicKey | undefined;
}
export class ChunkDescTypeInfo extends DescTypeInfo {
    obj_type(): number;
    sub_desc_type(): SubDescType;
}
export const CHUNK_DESC_TYPE_INFO: ChunkDescTypeInfo;
export class ChunkDescContent extends DescContent {
    type_info(): DescTypeInfo;
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
}
export class ChunkBodyContent extends BodyContent {
    type_info(): DescTypeInfo;
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
}
export class ChunkId implements RawEncode {
    constructor(buf: Uint8Array);
    calculate_id(): ObjectId;
    obj_type(): number;
    obj_type_code(): number;
    as_slice(): Uint8Array;
    length(): number;
    toString(): string;
    to_string(): string;
    to_base_58(): string;
    static from_base_58(s: string): ChunkId;
    static default(): ChunkId;
    static copy_from_slice(buf: Uint8Array): ChunkId;
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
    encode_to_buf(): BuckyResult<Uint8Array>;
    desc(): ObjectDesc;
    body(): Option<ObjectMutBody<ChunkDescContent, ChunkBodyContent>>;
    signs(): ObjectSigns;
    nonce(): Option<JSBI>;
    static calculate(data: Uint8Array): BuckyResult<ChunkId>;
}
export class ChunkIdDecoder implements RawDecode<ChunkId> {
    raw_decode(buf: Uint8Array): BuckyResult<[ChunkId, Uint8Array]>;
}

export class ContractDescTypeInfo extends DescTypeInfo {
    obj_type(): number;
    sub_desc_type(): SubDescType;
}
export class ContractDescContent extends DescContent {
    packageValue: HashValue;
    constructor(packageValue: HashValue);
    type_info(): DescTypeInfo;
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
}
export class ContractDescContentDecoder extends DescContentDecoder<ContractDescContent> {
    type_info(): DescTypeInfo;
    raw_decode(buf: Uint8Array): BuckyResult<[ContractDescContent, Uint8Array]>;
}
export class ContractBodyContent extends BodyContent {
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
}
export class ContractBodyContentDecoder extends BodyContentDecoder<ContractBodyContent> {
    raw_decode(buf: Uint8Array): BuckyResult<[ContractBodyContent, Uint8Array]>;
}
export class ContractDesc extends NamedObjectDesc<ContractDescContent> {
}
export class ContractDescDecoder extends NamedObjectDescDecoder<ContractDescContent> {
    constructor();
}
export class ContractBuilder extends NamedObjectBuilder<ContractDescContent, ContractBodyContent> {
}
export class ContractId extends NamedObjectId<ContractDescContent, ContractBodyContent> {
    constructor(id: ObjectId);
    static default(): ContractId;
    static from_base_58(s: string): BuckyResult<ContractId>;
    static try_from_object_id(id: ObjectId): BuckyResult<ContractId>;
}
export class ContractIdDecoder extends NamedObjectIdDecoder<ContractDescContent, ContractBodyContent> {
    constructor();
}
export class Contract extends NamedObject<ContractDescContent, ContractBodyContent> {
    static create(packageValue: HashValue, build?: (builder: ContractBuilder) => void): Contract;
    contract_id(): ContractId;
    connect_info(): ContractBodyContent;
}
export class ContractDecoder extends NamedObjectDecoder<ContractDescContent, ContractBodyContent, Contract> {
    constructor();
}

export enum DeviceCategory {
    OOD = 0,
    Server = 1,
    PC = 2,
    Router = 3,
    AndroidMobile = 4,
    AndroidPad = 5,
    AndroidWatch = 6,
    AndroidTV = 7,
    IOSMobile = 8,
    IOSPad = 9,
    IOSWatch = 10,
    SmartSpeakers = 11,
    Browser = 12,
    IoT = 13,
    SmartHome = 14,
    Unknown = 15
}
export function number_2_devicecategory(x: number): DeviceCategory;
export class DeviceDescTypeInfo extends DescTypeInfo {
    obj_type(): number;
    sub_desc_type(): SubDescType;
}
export class DeviceDescContent extends DescContent {
    constructor(unique_id: UniqueId);
    type_info(): DescTypeInfo;
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
    unique_id(): UniqueId;
}
export class DeviceDescContentDecoder extends DescContentDecoder<DeviceDescContent> {
    type_info(): DescTypeInfo;
    raw_decode(buf: Uint8Array): BuckyResult<[DeviceDescContent, Uint8Array]>;
}
export class DeviceBodyContent extends ProtobufBodyContent<protos.IDeviceBodyContent> {
    constructor(endpoints: Endpoint[], sn_list: DeviceId[], passive_pn_list: DeviceId[], name?: string);
    endpoints(): Endpoint[];
    sn_list(): DeviceId[];
    passive_pn_list(): DeviceId[];
    name(): string | undefined;
    set_name(name?: string): void;
    try_to_proto(): BuckyResult<protos.IDeviceBodyContent>;
}
export class DeviceBodyContentDecoder extends ProtobufBodyContentDecoder<DeviceBodyContent, protos.IDeviceBodyContent> {
    constructor();
    try_from_proto(value: protos.DeviceBodyContent): BuckyResult<DeviceBodyContent>;
}
export class DeviceDesc extends NamedObjectDesc<DeviceDescContent> {
}
export class DeviceDescDecoder extends NamedObjectDescDecoder<DeviceDescContent> {
    constructor();
}
export class DeviceBuilder extends NamedObjectBuilder<DeviceDescContent, DeviceBodyContent> {
}
export class DeviceId extends NamedObjectId<DeviceDescContent, DeviceBodyContent> {
    constructor(id: ObjectId);
    static default(): DeviceId;
    static from_base_58(s: string): BuckyResult<DeviceId>;
    static try_from_object_id(id: ObjectId): BuckyResult<DeviceId>;
}
export class DeviceIdDecoder extends NamedObjectIdDecoder<DeviceDescContent, DeviceBodyContent> {
    constructor();
}
export class Device extends NamedObject<DeviceDescContent, DeviceBodyContent> {
    static create(owner: Option<ObjectId>, unique_id: UniqueId, endpoints: Endpoint[], sn_list: DeviceId[], passive_sn_list: DeviceId[], public_key: PublicKey, area: Area, category: DeviceCategory, build?: (builder: DeviceBuilder) => void): Device;
    device_id(): DeviceId;
    connect_info(): DeviceBodyContent;
    name(): string | undefined;
    set_name(name?: string): void;
    category(): BuckyResult<DeviceCategory>;
}
export class DeviceDecoder extends NamedObjectDecoder<DeviceDescContent, DeviceBodyContent, Device> {
    constructor();
}

export class DirDescTypeInfo extends DescTypeInfo {
    obj_type(): number;
    sub_desc_type(): SubDescType;
}
export class Attributes implements RawEncode {
    flags: number;
    constructor(flags: number);
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
}
export class AttributesDecoder implements RawDecode<Attributes> {
    constructor();
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[Attributes, Uint8Array]>;
}
export class InnerNode implements RawEncode {
    constructor(id: {
        object_id?: ObjectId;
        chunk_id?: ChunkId;
        index?: {
            offset: number;
            size: number;
        };
    });
    is_object_id(): boolean;
    is_chunk_id(): boolean;
    is_index_in_parent_chunk(): boolean;
    match<T>(visitor: {
        ObjId: (object_id: ObjectId) => T;
        Chunk: (chunk_id: ChunkId) => T;
        IndexInParentChunk: (offset: number, size: number) => T;
    }): T;
    object_id(): ObjectId | undefined;
    chunk_id(): ChunkId | undefined;
    index_in_parent_chunk(): {
        offset: number;
        size: number;
    } | undefined;
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
}
export class InnerNodeDecoder implements RawDecode<InnerNode> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[InnerNode, Uint8Array]>;
}
export class InnerNodeInfo implements RawEncode {
    constructor(attributes: Attributes, node: InnerNode);
    attributes(): Attributes;
    node(): InnerNode;
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class InnerNodeInfoDecoder implements RawDecode<InnerNodeInfo> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[InnerNodeInfo, Uint8Array]>;
}
export class NDNObjectList implements RawEncode {
    constructor(parent_chunk: Option<ChunkId>, object_map?: BuckyHashMap<BuckyString, InnerNodeInfo>);
    parent_chunk(): Option<ChunkId>;
    object_map(): BuckyHashMap<BuckyString, InnerNodeInfo>;
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class NDNObjectListDecoder implements RawDecode<NDNObjectList> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[NDNObjectList, Uint8Array]>;
}
export class NDNObjectInfo implements RawEncode {
    constructor(info: {
        chunk_id?: ChunkId;
        obj_list?: NDNObjectList;
    });
    match<T>(visitor: {
        Chunk: (chunk_id: ChunkId) => T;
        ObjList: (obj_list: NDNObjectList) => T;
    }): T;
    match_async<T>(visitor: {
        Chunk: (chunk_id: ChunkId) => Promise<T>;
        ObjList: (obj_list: NDNObjectList) => Promise<T>;
    }): Promise<T>;
    raw_measure(ctx?: any, purpose?: RawEncodePurpose): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any, purpose?: RawEncodePurpose): BuckyResult<Uint8Array>;
}
export class NDNObjectInfoDecoder implements RawDecode<NDNObjectInfo> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[NDNObjectInfo, Uint8Array]>;
}
export class DirDescContent extends DescContent {
    constructor(attributes: Attributes, obj_list: NDNObjectInfo);
    attributes(): Attributes;
    obj_list(): NDNObjectInfo;
    set_obj_list(list: NDNObjectInfo): void;
    type_info(): DescTypeInfo;
    raw_measure(ctx?: any, purpose?: RawEncodePurpose): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any, purpose?: RawEncodePurpose): BuckyResult<Uint8Array>;
}
export class DirDescContentDecoder extends DescContentDecoder<DirDescContent> {
    type_info(): DescTypeInfo;
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[DirDescContent, Uint8Array]>;
}
export class DirBodyContent extends ProtobufBodyContent<protos.IDirBodyContent> {
    constructor(member: {
        chunk_id?: ChunkId;
        obj_list?: BuckyHashMap<ObjectId, BuckyBuffer>;
    });
    match<T>(visitor: {
        Chunk: (chunk_id: ChunkId) => T;
        ObjList: (obj_list: BuckyHashMap<ObjectId, BuckyBuffer>) => T;
    }): T;
    match_async<T>(visitor: {
        Chunk: (chunk_id: ChunkId) => Promise<T>;
        ObjList: (obj_list: BuckyHashMap<ObjectId, BuckyBuffer>) => Promise<T>;
    }): Promise<T>;
    try_to_proto(): BuckyResult<protos.IDirBodyContent>;
}
export class DirBodyContentDecoder extends ProtobufBodyContentDecoder<DirBodyContent, protos.DirBodyContent> {
    constructor();
    try_from_proto(value: protos.DirBodyContent): BuckyResult<DirBodyContent>;
}
export class DirDesc extends NamedObjectDesc<DirDescContent> {
}
export class DirDescDecoder extends NamedObjectDescDecoder<DirDescContent> {
    constructor();
}
export class DirBuilder extends NamedObjectBuilder<DirDescContent, DirBodyContent> {
}
export class DirId extends NamedObjectId<DirDescContent, DirBodyContent> {
    constructor(id: ObjectId);
    static default(): DirId;
    static from_base_58(s: string): BuckyResult<DirId>;
    static try_from_object_id(id: ObjectId): BuckyResult<DirId>;
}
export class DirIdDecoder extends NamedObjectIdDecoder<DirDescContent, DirBodyContent> {
    constructor();
}
export class Dir extends NamedObject<DirDescContent, DirBodyContent> {
    static create(owner: ObjectId, attributes: Attributes, obj_list: NDNObjectInfo, body: {
        chunk_id?: ChunkId;
        obj_list?: BuckyHashMap<ObjectId, BuckyBuffer>;
    }, build?: (builder: DirBuilder) => void): Dir;
    dir_id(): DirId;
    get_data_from_body(id: ObjectId): Option<Uint8Array>;
    check_and_fix_desc_limit(): BuckyResult<{}>;
}
export class DirDecoder extends NamedObjectDecoder<DirDescContent, DirBodyContent, Dir> {
    constructor();
}

export class FileDescTypeInfo extends DescTypeInfo {
    obj_type(): number;
    sub_desc_type(): SubDescType;
}
export class FileDescContent extends DescContent {
    len: JSBI;
    hash: HashValue;
    constructor(len: JSBI, hash: HashValue);
    type_info(): DescTypeInfo;
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
}
export class FileDescContentDecoder extends DescContentDecoder<FileDescContent> {
    type_info(): DescTypeInfo;
    raw_decode(buf: Uint8Array): BuckyResult<[FileDescContent, Uint8Array]>;
}
export class ChunkList {
    chunkInList?: ChunkId[] | undefined;
    fileId?: FileId | undefined;
    constructor(chunkInList?: ChunkId[] | undefined, fileId?: FileId | undefined);
    match<T>(visitor: {
        ChunkInList?: (list: ChunkId[]) => T;
        FileId?: (id: FileId) => T;
    }): T | undefined;
}
export class FileBodyContent extends ProtobufBodyContent<protos.IFileBodyContent> {
    chunk_list: ChunkList;
    constructor(chunk_list: ChunkList);
    try_to_proto(): BuckyResult<protos.IFileBodyContent>;
}
export class FileBodyContentDecoder extends ProtobufBodyContentDecoder<FileBodyContent, protos.IFileBodyContent> {
    constructor();
    try_from_proto(value: protos.IFileBodyContent): BuckyResult<FileBodyContent>;
}
export class FileDesc extends NamedObjectDesc<FileDescContent> {
}
export class FileDescDecoder extends NamedObjectDescDecoder<FileDescContent> {
    constructor();
}
export class FileBuilder extends NamedObjectBuilder<FileDescContent, FileBodyContent> {
}
export class FileId extends NamedObjectId<FileDescContent, FileBodyContent> {
    constructor(id: ObjectId);
    static default(): FileId;
    static from_base_58(s: string): BuckyResult<FileId>;
    static try_from_object_id(id: ObjectId): BuckyResult<FileId>;
}
export class FileIdDecoder extends NamedObjectIdDecoder<FileDescContent, FileBodyContent> {
    constructor();
}
export class File extends NamedObject<FileDescContent, FileBodyContent> {
    static create(owner: ObjectId, len: JSBI, hash: HashValue, chunk_list: ChunkList, build?: (builder: FileBuilder) => void): File;
    file_id(): FileId;
}
export class FileDecoder extends NamedObjectDecoder<FileDescContent, FileBodyContent, File> {
    constructor();
}

export class ObjectIdBuilder<T extends RawEncode & ObjectDesc> {
        m_t: T;
        m_obj_type_code: ObjectTypeCode;
        m_area: Option<Area>;
        m_has_owner: boolean;
        m_has_single_key: boolean;
        m_has_mn_key: boolean;
        constructor(t: T, obj_type_code: ObjectTypeCode);
        area(area: Option<Area>): ObjectIdBuilder<T>;
        owner(value: boolean): ObjectIdBuilder<T>;
        single_key(value: boolean): ObjectIdBuilder<T>;
        mn_key(value: boolean): ObjectIdBuilder<T>;
        build(): ObjectId;
}
export const OBJECT_FLAG_CTYPTO: number;
export const OBJECT_FLAG_MUT_BODY: number;
export const OBJECT_FLAG_DESC_SIGNS: number;
export const OBJECT_FLAG_BODY_SIGNS: number;
export const OBJECT_FLAG_NONCE: number;
export const OBJECT_FLAG_DESC_ID: number;
export const OBJECT_FLAG_REF_OBJECTS: number;
export const OBJECT_FLAG_PREV: number;
export const OBJECT_FLAG_CREATE_TIMESTAMP: number;
export const OBJECT_FLAG_CREATE_TIME: number;
export const OBJECT_FLAG_EXPIRED_TIME: number;
export const OBJECT_FLAG_OWNER: number;
export const OBJECT_FLAG_AREA: number;
export const OBJECT_FLAG_AUTHOR: number;
export const OBJECT_FLAG_PUBLIC_KEY: number;
export const OBJECT_FLAG_EXT: number;
export const OBJECT_TYPE_ANY: number;
export const OBJECT_TYPE_STANDARD_START: number;
export const OBJECT_TYPE_STANDARD_END: number;
export const OBJECT_TYPE_CORE_START: number;
export const OBJECT_TYPE_CORE_END: number;
export const OBJECT_TYPE_DECAPP_START: number;
export const OBJECT_TYPE_DECAPP_END: number;
export const OBJECT_PUBLIC_KEY_NONE: number;
export const OBJECT_PUBLIC_KEY_SINGLE: number;
export const OBJECT_PUBLIC_KEY_MN: number;
export const OBJECT_BODY_FLAG_PREV: number;
export const OBJECT_BODY_FLAG_USER_DATA: number;
export const OBJECT_BODY_FLAG_EXT: number;
export function is_standard_object(object_type: number): boolean;
export function is_core_object(object_type: number): boolean;
export function is_dec_app_object(object_type: number): boolean;
export abstract class ObjectDesc {
        constructor(obj_type: number);
        obj_type(): number;
        obj_type_code(): ObjectTypeCode;
        is_standard_object(): boolean;
        is_core_object(): boolean;
        is_dec_app_object(): boolean;
        abstract calculate_id(): ObjectId;
        abstract dec_id(): Option<ObjectId>;
        abstract ref_objs(): Option<Vec<ObjectLink>>;
        abstract prev(): Option<ObjectId>;
        abstract create_timestamp(): Option<HashValue>;
        abstract create_time(): JSBI;
        abstract expired_time(): Option<JSBI>;
        abstract owner(): Option<ObjectId> | undefined;
}
export class NamedObjectBodyContext {
        constructor();
        cache_body_content_size(size: number): NamedObjectBodyContext;
        get_body_content_cached_size(): number;
}
export class NamedObjectContext implements RawEncode {
        constructor(obj_type: number, obj_flags: number);
        get obj_type_code(): ObjectTypeCode;
        get obj_type(): number;
        get obj_flags(): number;
        is_standard_object(): boolean;
        is_core_object(): boolean;
        is_dec_app_object(): boolean;
        has_flag(flag_pos: number): boolean;
        with_crypto(): NamedObjectContext;
        has_crypto(): boolean;
        with_mut_body(): NamedObjectContext;
        has_mut_body(): boolean;
        with_desc_signs(): NamedObjectContext;
        has_desc_signs(): boolean;
        with_body_signs(): NamedObjectContext;
        has_body_signs(): boolean;
        with_nonce(): NamedObjectContext;
        has_nonce(): boolean;
        with_dec_id(): NamedObjectContext;
        has_dec_id(): boolean;
        with_ref_objects(): NamedObjectContext;
        has_ref_objects(): boolean;
        with_prev(): NamedObjectContext;
        has_prev(): boolean;
        with_create_timestamp(): NamedObjectContext;
        has_create_time_stamp(): boolean;
        with_create_time(): NamedObjectContext;
        has_create_time(): boolean;
        with_expired_time(): NamedObjectContext;
        has_expired_time(): boolean;
        with_owner(): NamedObjectContext;
        has_owner(): boolean;
        with_area(): NamedObjectContext;
        has_area(): boolean;
        with_public_key(): NamedObjectContext;
        has_public_key(): boolean;
        with_author(): NamedObjectContext;
        has_author(): boolean;
        has_ext(): boolean;
        cache_desc_content_size(size: number): NamedObjectContext;
        get_desc_content_cached_size(): number;
        body_context(): NamedObjectBodyContext;
        raw_measure(): BuckyResult<number>;
        raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
}
export class NamedObjectContextDecoder extends RawHexDecode<NamedObjectContext> {
        constructor();
        raw_decode(buf: Uint8Array): BuckyResult<[NamedObjectContext, Uint8Array]>;
}
/**
    * NamedObject的可变Body部分的建构器
    */
export class ObjectMutBodyBuilder<DC extends DescContent, BC extends BodyContent> {
        constructor(obj_type: number, content: BC);
        update_time(value: JSBI): ObjectMutBodyBuilder<DescContent, BC>;
        option_update_time(value: Option<JSBI>): ObjectMutBodyBuilder<DC, BC>;
        prev_version(value: HashValue): ObjectMutBodyBuilder<DC, BC>;
        option_prev_version(value: Option<HashValue>): ObjectMutBodyBuilder<DC, BC>;
        user_data(value: Uint8Array): ObjectMutBodyBuilder<DC, BC>;
        option_user_data(value: Option<Uint8Array>): ObjectMutBodyBuilder<DC, BC>;
        build(): ObjectMutBody<DC, BC>;
}
/**
    * NamedObject的可变Body部分
    */
export class ObjectMutBody<DC extends DescContent, BC extends BodyContent> implements RawEncode {
        toString(): string;
        constructor(obj_type: number, prev_version: Option<HashValue>, update_time: JSBI, content: BC, user_data: Option<Uint8Array>);
        set_trace_id(trace: number): void;
        trace_id(): number | undefined;
        convert_to<RBC extends BodyContent>(map: (t: BC) => BuckyResult<RBC>): BuckyResult<ObjectMutBody<DC, RBC>>;
        prev_version(): Option<HashValue>;
        update_time(): JSBI;
        content(): BC;
        user_data(): Option<Uint8Array>;
        set_update_time(value: JSBI): void;
        increase_update_time(value: JSBI): void;
        set_userdata(user_data: Uint8Array): void;
        raw_measure(ctx: NamedObjectBodyContext, purpose?: RawEncodePurpose): BuckyResult<number>;
        raw_encode(buf: Uint8Array, ctx: NamedObjectBodyContext, purpose?: RawEncodePurpose): BuckyResult<Uint8Array>;
        encode_to_buf(purpose?: RawEncodePurpose): BuckyResult<Uint8Array>;
        raw_hash_encode(): BuckyResult<HashValue>;
}
/**
    * NamedObject的可变Body部分的解码器
    */
export class ObjectMutBodyDecoder<DC extends DescContent, BC extends BodyContent> implements RawDecode<ObjectMutBody<DC, BC>> {
        constructor(obj_type: number, content_decoder: BodyContentDecoder<BC>);
        set_trace_id(trace: number): void;
        trace_id(): number | undefined;
        raw_decode(buf: Uint8Array): BuckyResult<[ObjectMutBody<DC, BC>, Uint8Array]>;
}
/**
    * NamedObject 的签名建构器
    */
export class ObjectSignsBuilder {
        constructor();
        reset_desc_sign(sign: Signature): ObjectSignsBuilder;
        reset_body_sign(sign: Signature): ObjectSignsBuilder;
        push_desc_sign(sign: Signature): ObjectSignsBuilder;
        push_body_sign(sign: Signature): ObjectSignsBuilder;
        build(): ObjectSigns;
}
/**
    * NamedObject 的签名部分
    */
export class ObjectSigns implements RawEncode {
        constructor(desc_signs: Option<Vec<Signature>>, body_signs: Option<Vec<Signature>>);
        desc_signs(): Option<Signature[]>;
        body_signs(): Option<Signature[]>;
        reset_desc_sign(sign: Signature): void;
        reset_body_sign(sign: Signature): void;
        push_desc_sign(sign: Signature): void;
        push_body_sign(sign: Signature): void;
        latest_desc_sign_time(): JSBI;
        latest_body_sign_time(): JSBI;
        raw_measure(ctx: NamedObjectContext): BuckyResult<number>;
        raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
        static default(): ObjectSigns;
}
/**
    * NamedObject 的签名解码器
    */
export class ObjectSignsDecoder implements RawDecode<ObjectSigns> {
        raw_decode(buf: Uint8Array, ctx: NamedObjectContext): BuckyResult<[ObjectSigns, Uint8Array]>;
}
/**
    * 强类型命名对象Id
    */
export class NamedObjectId<DC extends DescContent, BC extends BodyContent> implements RawEncode, Compareable<NamedObjectId<DC, BC>> {
        constructor(obj_type: number, object_id: ObjectId);
        get object_id(): ObjectId;
        hashCode(): symbol;
        equals<ODC extends DescContent, OBC extends BodyContent>(other: NamedObjectId<ODC, OBC>): boolean;
        into(): ObjectId;
        gen(object_id: ObjectId): void;
        toString(): string;
        toJSON(): string;
        to_string(): string;
        to_base_58(): string;
        raw_measure(ctx?: any): BuckyResult<number>;
        raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export function named_id_gen_default<DC extends DescContent, BC extends BodyContent, O extends NamedObjectId<DC, BC>>(obj_type: number): O;
export function named_id_from_base_58<DC extends DescContent, BC extends BodyContent>(obj_type: number, s: string): BuckyResult<NamedObjectId<DC, BC>>;
export function named_id_try_from_object_id<DC extends DescContent, BC extends BodyContent>(obj_type: number, id: ObjectId): BuckyResult<NamedObjectId<DC, BC>>;
/**
    * NamedObjectId 解码器
    */
export class NamedObjectIdDecoder<DC extends DescContent, BC extends BodyContent> implements RawDecode<NamedObjectId<DC, BC>> {
        readonly m_obj_type: number;
        constructor(obj_type: number);
        raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[NamedObjectId<DC, BC>, Uint8Array]>;
}
export interface SubDescType {
        owner_type: "disable" | "option";
        area_type: "disable" | "option";
        author_type: "disable" | "option";
        key_type: "disable" | "single_key" | "mn_key" | "any";
}
export class ContentCodecInfo {
        version: number;
        format: number;
        constructor(version: number, format: number);
        static default(): ContentCodecInfo;
}
export abstract class DescTypeInfo {
        get_sub_obj_type(): number;
        set_sub_obj_type(v: number): void;
        abstract obj_type(): number;
        abstract sub_desc_type(): SubDescType;
}
export abstract class DescContent implements RawEncode {
        abstract type_info(): DescTypeInfo;
        codec_info(): ContentCodecInfo;
        abstract raw_measure(ctx?: any, purpose?: RawEncodePurpose): BuckyResult<number>;
        abstract raw_encode(buf: Uint8Array, ctx?: any, purpose?: RawEncodePurpose): BuckyResult<Uint8Array>;
}
export abstract class DescContentDecoder<T extends DescContent> implements RawDecode<T> {
        abstract type_info(): DescTypeInfo;
        abstract raw_decode(buf: Uint8Array, ctx: ContentRawDecodeContext): BuckyResult<[T, Uint8Array]>;
}
export class EmptyDescContent extends DescContent {
        constructor(m_type_info: DescTypeInfo);
        type_info(): DescTypeInfo;
        raw_measure(): BuckyResult<number>;
        raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
}
export class EmptyDescContentDecoder extends DescContentDecoder<EmptyDescContent> {
        constructor(m_type_info: DescTypeInfo);
        type_info(): DescTypeInfo;
        raw_decode(buf: Uint8Array): BuckyResult<[EmptyDescContent, Uint8Array]>;
}
export abstract class BodyContent implements RawEncode {
        codec_info(): ContentCodecInfo;
        abstract raw_measure(ctx?: any, purpose?: RawEncodePurpose): BuckyResult<number>;
        abstract raw_encode(buf: Uint8Array, ctx?: any, purpose?: RawEncodePurpose): BuckyResult<Uint8Array>;
}
export abstract class BodyContentDecoder<T extends BodyContent> implements RawDecode<T> {
        abstract raw_decode(buf: Uint8Array, ctx: ContentRawDecodeContext): BuckyResult<[T, Uint8Array]>;
}
export class NamedObjectDescBuilder<T extends DescContent> {
        constructor(obj_type: number, desc_content: T);
        dec_id(value: ObjectId): NamedObjectDescBuilder<T>;
        option_dec_id(value: Option<ObjectId>): NamedObjectDescBuilder<T>;
        ref_objects(value: Vec<ObjectLink>): NamedObjectDescBuilder<T>;
        option_ref_objects(value: Option<Vec<ObjectLink>>): NamedObjectDescBuilder<T>;
        prev(value: ObjectId): NamedObjectDescBuilder<T>;
        option_prev(value: Option<ObjectId>): NamedObjectDescBuilder<T>;
        create_timestamp(value: HashValue): NamedObjectDescBuilder<T>;
        option_create_timestamp(value: Option<HashValue>): NamedObjectDescBuilder<T>;
        create_time(value: JSBI): NamedObjectDescBuilder<T>;
        option_create_time(value: Option<JSBI>): NamedObjectDescBuilder<T>;
        expired_time(value: JSBI): NamedObjectDescBuilder<T>;
        option_expired_time(value: Option<JSBI>): NamedObjectDescBuilder<T>;
        owner(value: ObjectId): NamedObjectDescBuilder<T>;
        option_owner(value: Option<ObjectId>): NamedObjectDescBuilder<T>;
        area(value: Area): NamedObjectDescBuilder<T>;
        option_area(value: Option<Area>): NamedObjectDescBuilder<T>;
        author(value: ObjectId): NamedObjectDescBuilder<T>;
        option_author(value: Option<ObjectId>): NamedObjectDescBuilder<T>;
        single_key(value: PublicKey): NamedObjectDescBuilder<T>;
        option_single_key(value: Option<PublicKey>): NamedObjectDescBuilder<T>;
        mn_key(value: MNPublicKey): NamedObjectDescBuilder<T>;
        option_mn_key(value: Option<MNPublicKey>): NamedObjectDescBuilder<T>;
        option_key(value: Option<PublicKey | MNPublicKey | undefined>): NamedObjectDescBuilder<T>;
        key(value: PublicKey | MNPublicKey | undefined): NamedObjectDescBuilder<T>;
        build(): NamedObjectDesc<T>;
}
export class NamedObjectDesc<T extends DescContent> extends ObjectDesc implements RawEncode {
        constructor(dec_id: Option<ObjectId>, ref_objects: Option<Vec<ObjectLink>>, prev: Option<ObjectId>, create_timestamp: Option<HashValue>, create_time: Option<JSBI>, expired_time: Option<JSBI>, desc_content: T, owner?: Option<ObjectId>, area?: Option<Area>, author?: Option<ObjectId>, public_key?: PublicKey | MNPublicKey);
        trace_id(): number;
        convert_to<U extends DescContent>(map: (t: T) => BuckyResult<U>): BuckyResult<NamedObjectDesc<U>>;
        content(): T;
        dec_id(): Option<ObjectId>;
        ref_objs(): Option<Vec<ObjectLink>>;
        prev(): Option<ObjectId>;
        create_timestamp(): Option<HashValue>;
        create_time(): JSBI;
        expired_time(): Option<JSBI>;
        object_id(): ObjectId;
        calculate_id(): ObjectId;
        owner(): Option<ObjectId> | undefined;
        area(): Option<Area> | undefined;
        author(): Option<ObjectId> | undefined;
        public_key(): PublicKey | undefined;
        mn_key(): MNPublicKey | undefined;
        raw_measure(ctx?: NamedObjectContext, purpose?: RawEncodePurpose): BuckyResult<number>;
        raw_measure_with_context(ctx: NamedObjectContext, purpose?: RawEncodePurpose): BuckyResult<number>;
        raw_encode(buf: Uint8Array, ctx?: NamedObjectContext, purpose?: RawEncodePurpose): BuckyResult<Uint8Array>;
        raw_encode_with_context(buf: Uint8Array, ctx: NamedObjectContext, purpose?: RawEncodePurpose): BuckyResult<Uint8Array>;
        encode_to_buf(purpose?: RawEncodePurpose): BuckyResult<Uint8Array>;
        raw_hash_encode(): BuckyResult<HashValue>;
}
export class NamedObjectDescDecoder<T extends DescContent> implements RawDecode<NamedObjectDesc<T>> {
        constructor(desc_content_decoder: DescContentDecoder<T>);
        trace_id(): number;
        raw_decode(buf: Uint8Array, ctx?: NamedObjectContext): BuckyResult<[NamedObjectDesc<T>, Uint8Array]>;
}
export class NamedObject<DC extends DescContent, BC extends BodyContent> implements RawEncode {
        constructor(desc: NamedObjectDesc<DC>, body: Option<ObjectMutBody<DC, BC>>, signs: ObjectSigns, nonce: Option<JSBI>);
        obj_type(): number;
        obj_type_code(): number;
        calculate_id(): ObjectId;
        protected obj_flags(): number;
        to_vec(): BuckyResult<Uint8Array>;
        to_hex(): BuckyResult<string>;
        toString(): string;
        to_string(): string;
        toJSON(): string;
        desc(): NamedObjectDesc<DC>;
        body(): Option<ObjectMutBody<DC, BC>>;
        set_body(body: Option<ObjectMutBody<DC, BC>>): void;
        body_expect(): ObjectMutBody<DC, BC>;
        signs(): ObjectSigns;
        nonce(): Option<JSBI>;
        raw_measure(_ctx?: any, purpose?: RawEncodePurpose): BuckyResult<number>;
        raw_encode(buf: Uint8Array, ctx?: NamedObjectContext, purpose?: RawEncodePurpose): BuckyResult<Uint8Array>;
        encode_to_buf(purpose?: RawEncodePurpose): BuckyResult<Uint8Array>;
        raw_hash_encode(): BuckyResult<HashValue>;
}
export class NamedObjectDecoder<DC extends DescContent, BC extends BodyContent, O extends NamedObject<DC, BC>> implements RawDecode<NamedObject<DC, BC>> {
        constructor(desc_content_decoer: DescContentDecoder<DC>, body_content_decoder: BodyContentDecoder<BC>, obj_builder: new (...constructorArgs: any[]) => O);
        raw_decode(buf: Uint8Array): BuckyResult<[O, Uint8Array]>;
        from_raw(buf: Uint8Array): BuckyResult<O>;
        from_hex(hex: string): BuckyResult<O>;
}
export class NamedObjectBuilder<DC extends DescContent, BC extends BodyContent> {
        constructor(desc_content: DC, body_content: BC);
        dec_id(dec_id: ObjectId): NamedObjectBuilder<DC, BC>;
        option_dec_id(dec_id: Option<ObjectId>): NamedObjectBuilder<DC, BC>;
        ref_objects(ref_objects: Vec<ObjectLink>): NamedObjectBuilder<DC, BC>;
        option_ref_objects(ref_objects: Option<Vec<ObjectLink>>): NamedObjectBuilder<DC, BC>;
        prev(prev: ObjectId): NamedObjectBuilder<DC, BC>;
        option_prev(prev: Option<ObjectId>): NamedObjectBuilder<DC, BC>;
        create_timestamp(create_timestamp: HashValue): NamedObjectBuilder<DC, BC>;
        option_create_timestamp(create_timestamp: Option<HashValue>): NamedObjectBuilder<DC, BC>;
        no_create_time(): NamedObjectBuilder<DC, BC>;
        create_time(create_time: JSBI): NamedObjectBuilder<DC, BC>;
        option_create_time(create_time: Option<JSBI>): NamedObjectBuilder<DC, BC>;
        expired_time(expired_time: JSBI): NamedObjectBuilder<DC, BC>;
        option_expired_time(expired_time: Option<JSBI>): NamedObjectBuilder<DC, BC>;
        owner(value: ObjectId): NamedObjectBuilder<DC, BC>;
        option_owner(value: Option<ObjectId>): NamedObjectBuilder<DC, BC>;
        area(value: Area): NamedObjectBuilder<DC, BC>;
        option_area(value: Option<Area>): NamedObjectBuilder<DC, BC>;
        author(value: ObjectId): NamedObjectBuilder<DC, BC>;
        option_author(value: Option<ObjectId>): NamedObjectBuilder<DC, BC>;
        single_key(value: PublicKey): NamedObjectBuilder<DC, BC>;
        option_single_key(value: Option<PublicKey>): NamedObjectBuilder<DC, BC>;
        mn_key(value: MNPublicKey): NamedObjectBuilder<DC, BC>;
        option_mn_key(value: Option<MNPublicKey>): NamedObjectBuilder<DC, BC>;
        no_body(): NamedObjectBuilder<DC, BC>;
        update_time(update_time: JSBI): NamedObjectBuilder<DC, BC>;
        prev_version(prev_version: HashValue): NamedObjectBuilder<DC, BC>;
        user_data(user_data: Uint8Array): NamedObjectBuilder<DC, BC>;
        reset_desc_sign(sign: Signature): NamedObjectBuilder<DC, BC>;
        reset_body_sign(sign: Signature): NamedObjectBuilder<DC, BC>;
        push_desc_sign(sign: Signature): NamedObjectBuilder<DC, BC>;
        push_body_sign(sign: Signature): NamedObjectBuilder<DC, BC>;
        nonce(nonce: JSBI): NamedObjectBuilder<DC, BC>;
        build_ex(): [
                NamedObjectDesc<DC>,
                Option<ObjectMutBody<DC, BC>>,
                ObjectSigns,
                Option<JSBI>
        ];
        build<T extends NamedObject<DC, BC>>(obj_constructor: new (desc: NamedObjectDesc<DC>, body: Option<ObjectMutBody<DC, BC>>, signs: ObjectSigns, nonce: Option<JSBI>) => T): T;
}

export enum ObjectCategory {
    Standard = "standard",
    Core = "core",
    DecApp = "dec_app"
}
export const OBJECT_ID_LEN: number;
export const OBJECT_ID_STANDARD: number;
export const OBJECT_ID_CORE: number;
export const OBJECT_ID_DEC_APP: number;
export const OBJECT_ID_FLAG_AREA: number;
export const OBJECT_ID_FLAG_PK: number;
export const OBJECT_ID_FLAG_MN_PK: number;
export const OBJECT_ID_FLAG_OWNER: number;
export interface ObjectIdInfoPartten<T> {
    StandardObjectIdInfo: (info: StandardObjectIdInfo) => T;
    CoreObjectIdInfo: (info: CoreObjectIdInfo) => T;
    DecAppObjectIdInfo: (info: DecAppObjectIdInfo) => T;
}
export interface ObjectIdInfoMatcher {
    match<T>(p: ObjectIdInfoPartten<T>): T;
}
export class StandardObjectIdInfo implements ObjectIdInfoMatcher {
    obj_type_code: ObjectTypeCode;
    obj_type: number;
    area: Option<Area>;
    constructor(obj_type_code: ObjectTypeCode, obj_type: number, area: Option<Area>);
    match<T>(p: ObjectIdInfoPartten<T>): T;
}
export class CoreObjectIdInfo implements ObjectIdInfoMatcher {
    area: Option<Area>;
    has_owner: boolean;
    has_single_key: boolean;
    has_mn_key: boolean;
    constructor(area: Option<Area>, has_owner: boolean, has_single_key: boolean, has_mn_key: boolean);
    match<T>(p: ObjectIdInfoPartten<T>): T;
}
export class DecAppObjectIdInfo implements ObjectIdInfoMatcher {
    area: Option<Area>;
    has_owner: boolean;
    has_single_key: boolean;
    has_mn_key: boolean;
    constructor(area: Option<Area>, has_owner: boolean, has_single_key: boolean, has_mn_key: boolean);
    match<T>(p: ObjectIdInfoPartten<T>): T;
}
export type ObjectIdInfo = (StandardObjectIdInfo | CoreObjectIdInfo | DecAppObjectIdInfo) & ObjectIdInfoMatcher;
export class ObjectId implements RawEncode, Compareable<ObjectId> {
    m_buf: Uint8Array;
    m_base58?: string;
    constructor(buf: Uint8Array);
    get object_id(): void;
    static default(): ObjectId;
    static copy_from_slice(buf: Uint8Array): ObjectId;
    obj_type_code(): ObjectTypeCode;
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
    as_slice(): Uint8Array;
    clone(): ObjectId;
    length(): number;
    toString(): string;
    toJSON(): string;
    to_string(): string;
    to_base_58(): string;
    hashCode(): symbol;
    equals(other: ObjectId): boolean;
    eq(other: ObjectId): boolean;
    static from_str(s: string): BuckyResult<ObjectId>;
    static from_base_58(s: string): BuckyResult<ObjectId>;
    to_hash_value(): HashValue;
    object_category(): ObjectCategory;
    is_stand_object(): boolean;
    is_core_object(): boolean;
    is_dec_app_object(): boolean;
    info(): ObjectIdInfo;
}
export class ObjectIdDecoder implements RawDecode<ObjectId> {
    raw_decode(buf: Uint8Array): BuckyResult<[ObjectId, Uint8Array]>;
}
export class ObjectLink implements RawEncode {
    get obj_id(): ObjectId;
    get obj_owner(): Option<ObjectId>;
    constructor(obj_id: ObjectId, obj_owner: Option<ObjectId>);
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
}
export class ObjectLinkDecoder implements RawDecode<ObjectLink> {
    raw_decode(buf: Uint8Array): BuckyResult<[ObjectLink, Uint8Array]>;
}

export class TypelessDescTypeInfo extends DescTypeInfo {
    obj_type(): number;
    get_sub_obj_type(): number;
    set_sub_obj_type(v: number): void;
    sub_desc_type(): SubDescType;
}
export class TypelessDescContent extends DescContent {
    constructor(buf: Uint8Array, version: number, format: number);
    type_info(): DescTypeInfo;
    codec_info(): ContentCodecInfo;
    buffer(): Uint8Array;
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
}
export class TypelessDescContentDecoder extends DescContentDecoder<TypelessDescContent> {
    constructor();
    type_info(): DescTypeInfo;
    raw_decode(buf: Uint8Array, ctx: ContentRawDecodeContext): BuckyResult<[TypelessDescContent, Uint8Array]>;
}
export class TypelessBodyContent extends BodyContent {
    constructor(buf: Uint8Array, version: number, format: number);
    type_info(): DescTypeInfo;
    codec_info(): ContentCodecInfo;
    buffer(): Uint8Array;
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
}
export class TypelessBodyContentDecoder extends BodyContentDecoder<TypelessBodyContent> {
    constructor();
    type_info(): DescTypeInfo;
    raw_decode(buf: Uint8Array, ctx: ContentRawDecodeContext): BuckyResult<[TypelessBodyContent, Uint8Array]>;
}
export class TypelessAnyObject extends NamedObject<TypelessDescContent, TypelessBodyContent> {
    convert_to<DC extends DescContent, BC extends BodyContent>(desc_content_decoder: DescContentDecoder<DC>, body_content_decoder: BodyContentDecoder<BC>): BuckyResult<NamedObject<DC, BC>>;
}
export class TypelessAnyObjectDecoder<O extends TypelessAnyObject> extends NamedObjectDecoder<TypelessDescContent, TypelessBodyContent, O> {
    constructor(obj_builder: new (...constructorArgs: any[]) => O);
}
export class TypelessCoreObject extends TypelessAnyObject {
}
export class TypelessCoreObjectDecoder extends TypelessAnyObjectDecoder<TypelessCoreObject> {
    constructor();
}
export class TypelessDECAppObject extends TypelessAnyObject {
}
export class TypelessDECAppObjectDecoder extends TypelessAnyObjectDecoder<TypelessDECAppObject> {
    constructor();
}

export enum ObjectTypeCode {
    Device = 1,
    People = 2,
    SimpleGroup = 3,
    Org = 4,
    AppGroup = 5,
    UnionAccount = 6,
    Chunk = 7,
    File = 8,
    Dir = 9,
    Diff = 10,
    ProofOfService = 11,
    Tx = 12,
    Action = 13,
    Relation = 14,
    Contract = 15,
    Custom = 16
}
export function number_2_obj_type_code(x: number): ObjectTypeCode;
export function number_2_obj_type_code_name(x: number): string;
export function obj_type_code_raw_check(buf: Uint8Array): ObjectTypeCode;
export class ObjectTypeCodeEncoder implements RawEncode {
    value: ObjectTypeCode;
    constructor(value: ObjectTypeCode);
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
}
export class ObjectTypeCodeDecoder implements RawDecode<ObjectTypeCode> {
    raw_decode(buf: Uint8Array): BuckyResult<[ObjectTypeCode, Uint8Array]>;
}

export class OrgDescTypeInfo extends DescTypeInfo {
    obj_type(): number;
    sub_desc_type(): SubDescType;
}
export class OrgDescContent extends DescContent {
    type_info(): DescTypeInfo;
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
}
export class OrgDescContentDecoder extends DescContentDecoder<OrgDescContent> {
    type_info(): DescTypeInfo;
    raw_decode(buf: Uint8Array): BuckyResult<[OrgDescContent, Uint8Array]>;
}
export class Director {
    id: ObjectId;
    right: number;
    constructor(id: ObjectId, right: number);
}
export class OrgMember {
    id: ObjectId;
    right: number;
    shared: JSBI;
    constructor(id: ObjectId, right: number, shared: JSBI);
}
export class OrgBodyContent extends ProtobufBodyContent<protos.IOrgBodyContent> {
    members: OrgMember[];
    directors: Director[];
    total_equity: JSBI;
    constructor(members: OrgMember[], directors: Director[], total_equity: JSBI);
    try_to_proto(): BuckyResult<protos.IOrgBodyContent>;
}
export class OrgBodyContentDecoder extends ProtobufBodyContentDecoder<OrgBodyContent, IOrgBodyContent> {
    constructor();
    try_from_proto(value: protos.IOrgBodyContent): BuckyResult<OrgBodyContent>;
}
export class OrgDesc extends NamedObjectDesc<OrgDescContent> {
}
export class OrgDescDecoder extends NamedObjectDescDecoder<OrgDescContent> {
    constructor();
}
export class OrgBuilder extends NamedObjectBuilder<OrgDescContent, OrgBodyContent> {
}
export class OrgId extends NamedObjectId<OrgDescContent, OrgBodyContent> {
    constructor(id: ObjectId);
    static default(): OrgId;
    static from_base_58(s: string): BuckyResult<OrgId>;
    static try_from_object_id(id: ObjectId): BuckyResult<OrgId>;
}
export class OrgIdDecoder extends NamedObjectIdDecoder<OrgDescContent, OrgBodyContent> {
    constructor();
}
export class Org extends NamedObject<OrgDescContent, OrgBodyContent> {
    static create(members: OrgMember[], directors: Director[], total_equity: string | number, build?: (builder: OrgBuilder) => void): Org;
    org_id(): OrgId;
    content_info(): OrgBodyContent;
}
export class OrgDecoder extends NamedObjectDecoder<OrgDescContent, OrgBodyContent, Org> {
    constructor();
}

export class PeopleDescTypeInfo extends DescTypeInfo {
    obj_type(): number;
    sub_desc_type(): SubDescType;
}
export class PeopleDescContent extends DescContent {
    type_info(): DescTypeInfo;
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
}
export class PeopleDescContentDecoder extends DescContentDecoder<PeopleDescContent> {
    type_info(): DescTypeInfo;
    raw_decode(buf: Uint8Array): BuckyResult<[PeopleDescContent, Uint8Array]>;
}
export class PeopleBodyContent extends ProtobufBodyContent<protos.IPeopleBodyContent> {
    ood_list: DeviceId[];
    name?: string | undefined;
    icon?: FileId | undefined;
    constructor(ood_list: DeviceId[], name?: string | undefined, icon?: FileId | undefined);
    set_name(name?: string): void;
    set_icon(icon?: FileId): void;
    try_to_proto(): BuckyResult<protos.IPeopleBodyContent>;
}
export class PeopleBodyContentDecoder extends ProtobufBodyContentDecoder<PeopleBodyContent, protos.IPeopleBodyContent> {
    constructor();
    try_from_proto(value: protos.IPeopleBodyContent): BuckyResult<PeopleBodyContent>;
}
export class PeopleDesc extends NamedObjectDesc<PeopleDescContent> {
}
export class PeopleDescDecoder extends NamedObjectDescDecoder<PeopleDescContent> {
    constructor();
}
export class PeopleBuilder extends NamedObjectBuilder<PeopleDescContent, PeopleBodyContent> {
}
export class PeopleId extends NamedObjectId<PeopleDescContent, PeopleBodyContent> {
    constructor(id: ObjectId);
    static default(): PeopleId;
    static from_base_58(s: string): BuckyResult<PeopleId>;
    static try_from_object_id(id: ObjectId): BuckyResult<PeopleId>;
}
export class PeopleIdDecoder extends NamedObjectIdDecoder<DeviceDescContent, DeviceBodyContent> {
    constructor();
}
export class People extends NamedObject<PeopleDescContent, PeopleBodyContent> {
    static create(owner: Option<ObjectId>, ood_list: DeviceId[], public_key: PublicKey, area: Option<Area>, name?: string, icon?: FileId, build?: (builder: PeopleBuilder) => void): People;
    people_id(): PeopleId;
    name(): string | undefined;
    set_name(name?: string): void;
    icon(): FileId | undefined;
    set_icon(icon?: FileId): void;
}
export class PeopleDecoder extends NamedObjectDecoder<PeopleDescContent, PeopleBodyContent, People> {
    constructor();
}

export class RelationDescTypeInfo extends DescTypeInfo {
    obj_type(): number;
    sub_desc_type(): SubDescType;
}
export class RelationBodyContent extends BodyContent {
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
}
export class RelationBodyContentDecoder extends BodyContentDecoder<RelationBodyContent> {
    raw_decode(buf: Uint8Array): BuckyResult<[RelationBodyContent, Uint8Array]>;
}
export class RelationDesc extends NamedObjectDesc<EmptyDescContent> {
}
export class RelationDescDecoder extends NamedObjectDescDecoder<EmptyDescContent> {
    constructor();
}
export class RelationBuilder extends NamedObjectBuilder<EmptyDescContent, RelationBodyContent> {
}
export class RelationId extends NamedObjectId<EmptyDescContent, RelationBodyContent> {
    constructor(id: ObjectId);
    static default(): RelationId;
    static from_base_58(s: string): BuckyResult<RelationId>;
    static try_from_object_id(id: ObjectId): BuckyResult<RelationId>;
}
export class RelationIdDecoder extends NamedObjectIdDecoder<EmptyDescContent, RelationBodyContent> {
    constructor();
}
export class Relation extends NamedObject<EmptyDescContent, RelationBodyContent> {
    static create(build?: (builder: RelationBuilder) => void): Relation;
    relation_id(): RelationId;
    connect_info(): RelationBodyContent;
}
export class RelationDecoder extends NamedObjectDecoder<EmptyDescContent, RelationBodyContent, Relation> {
    constructor();
}

export class SimpleGroupDescTypeInfo extends DescTypeInfo {
    obj_type(): number;
    sub_desc_type(): SubDescType;
}
export class SimpleGroupDescContent extends DescContent {
    type_info(): DescTypeInfo;
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
}
export class SimpleGroupDescContentDecoder extends DescContentDecoder<SimpleGroupDescContent> {
    type_info(): DescTypeInfo;
    raw_decode(buf: Uint8Array): BuckyResult<[SimpleGroupDescContent, Uint8Array]>;
}
export class SimpleGroupBodyContent extends ProtobufBodyContent<protos.ISimpleGroupBodyContent> {
    members: ObjectId[];
    ood_list: DeviceId[];
    constructor(members: ObjectId[], ood_list: DeviceId[]);
    try_to_proto(): BuckyResult<protos.ISimpleGroupBodyContent>;
}
export class SimpleGroupBodyContentDecoder extends ProtobufBodyContentDecoder<SimpleGroupBodyContent, protos.ISimpleGroupBodyContent> {
    constructor();
    try_from_proto(value: protos.ISimpleGroupBodyContent): BuckyResult<SimpleGroupBodyContent>;
}
export class SimpleGroupDesc extends NamedObjectDesc<SimpleGroupDescContent> {
}
export class SimpleGroupDescDecoder extends NamedObjectDescDecoder<SimpleGroupDescContent> {
    constructor();
}
export class SimpleGroupBuilder extends NamedObjectBuilder<SimpleGroupDescContent, SimpleGroupBodyContent> {
}
export class SimpleGroupId extends NamedObjectId<SimpleGroupDescContent, SimpleGroupBodyContent> {
    constructor(id: ObjectId);
    static default(): SimpleGroupId;
    static from_base_58(s: string): BuckyResult<SimpleGroupId>;
    static try_from_object_id(id: ObjectId): BuckyResult<SimpleGroupId>;
}
export class SimpleGroupIdDecoder extends NamedObjectIdDecoder<SimpleGroupDescContent, SimpleGroupBodyContent> {
    constructor();
}
export class SimpleGroup extends NamedObject<SimpleGroupDescContent, SimpleGroupBodyContent> {
    static create(threshold: number, owners: PublicKey[], members: ObjectId[], ood_list: DeviceId[], area: Area, build?: (builder: SimpleGroupBuilder) => void): SimpleGroup;
    simple_group_id(): SimpleGroupId;
    connect_info(): SimpleGroupBodyContent;
}
export class SimpleGroupDecoder extends NamedObjectDecoder<SimpleGroupDescContent, SimpleGroupBodyContent, SimpleGroup> {
    constructor();
}

export class UnionAccountDescTypeInfo extends DescTypeInfo {
    obj_type(): number;
    sub_desc_type(): SubDescType;
}
export class UnionAccountDescContent extends DescContent {
    left: ObjectId;
    right: ObjectId;
    service_type: number;
    constructor(left: ObjectId, right: ObjectId, service_type: number);
    type_info(): DescTypeInfo;
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
}
export class UnionAccountDescContentDecoder extends DescContentDecoder<UnionAccountDescContent> {
    type_info(): DescTypeInfo;
    raw_decode(buf: Uint8Array): BuckyResult<[UnionAccountDescContent, Uint8Array]>;
}
export class UnionAccountBodyContent extends BodyContent {
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
}
export class UnionAccountBodyContentDecoder extends BodyContentDecoder<UnionAccountBodyContent> {
    raw_decode(buf: Uint8Array): BuckyResult<[UnionAccountBodyContent, Uint8Array]>;
}
export class UnionAccountDesc extends NamedObjectDesc<UnionAccountDescContent> {
}
export class UnionAccountDescDecoder extends NamedObjectDescDecoder<UnionAccountDescContent> {
    constructor();
}
export class UnionAccountBuilder extends NamedObjectBuilder<UnionAccountDescContent, UnionAccountBodyContent> {
}
export class UnionAccountId extends NamedObjectId<UnionAccountDescContent, UnionAccountBodyContent> {
    constructor(id: ObjectId);
    static default(): UnionAccountId;
    static from_base_58(s: string): BuckyResult<UnionAccountId>;
    static try_from_object_id(id: ObjectId): BuckyResult<UnionAccountId>;
}
export class UnionAccountIdDecoder extends NamedObjectIdDecoder<UnionAccountDescContent, UnionAccountBodyContent> {
    constructor();
}
export class UnionAccount extends NamedObject<UnionAccountDescContent, UnionAccountBodyContent> {
    static create(account1: ObjectId, account2: ObjectId, service_type: number, build?: (builder: UnionAccountBuilder) => void): UnionAccount;
    union_account_id(): UnionAccountId;
    connect_info(): UnionAccountBodyContent;
}
export class UnionAccountDecoder extends NamedObjectDecoder<UnionAccountDescContent, UnionAccountBodyContent, UnionAccount> {
    constructor();
}

export const UNIQUE_VALUE_LEN: number;
export class UniqueId implements RawEncode {
    m_buf: Uint8Array;
    constructor(buf: Uint8Array);
    as_slice(): Uint8Array;
    length(): number;
    toJSON(): string;
    static default(): UniqueId;
    static copy_from_slice(buf: Uint8Array): UniqueId;
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
    to_base_58(): string;
}
export class UniqueIdDecoder implements RawDecode<UniqueId> {
    raw_decode(buf: Uint8Array): BuckyResult<[UniqueId, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class ChunkTransContract implements RawEncode {
    price_per_kbytes: number;
    obj_list: Option<ObjectId[]>;
    min_speed: Option<number>;
    max_speed: Option<number>;
    avg_speed: Option<number>;
    max_bytes: Option<JSBI>;
    constructor(price_per_kbytes: number, obj_list: Option<ObjectId[]>, min_speed: Option<number>, max_speed: Option<number>, avg_speed: Option<number>, max_bytes: Option<JSBI>);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class ChunkTransContractDecoder implements RawDecode<ChunkTransContract> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[ChunkTransContract, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class ChunkTransReceipt implements RawEncode {
    chunk_id: ChunkId;
    crypto_chunk_id: ChunkId;
    valid_length: Option<JSBI>;
    max_speed: Option<number>;
    min_speed: Option<number>;
    crypto_key: Option<JSBI>;
    constructor(chunk_id: ChunkId, crypto_chunk_id: ChunkId, valid_length: Option<JSBI>, max_speed: Option<number>, min_speed: Option<number>, crypto_key: Option<JSBI>);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class ChunkTransReceiptDecoder implements RawDecode<ChunkTransReceipt> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[ChunkTransReceipt, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class DSGReceipt implements RawEncode {
    constructor();
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class DSGReceiptDecoder implements RawDecode<DSGReceipt> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[DSGReceipt, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class ProofData implements RawEncode {
    data: Uint8Array;
    constructor(data: Uint8Array);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class ProofDataDecoder implements RawDecode<ProofData> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[ProofData, Uint8Array]>;
}

export class ProofDataExt {
    obj: ProofData;
    constructor(obj: ProofData);
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class ProofOfDSG implements RawEncode {
    constructor();
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class ProofOfDSGDecoder implements RawDecode<ProofOfDSG> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[ProofOfDSG, Uint8Array]>;
}

export class ProofOfDSGExt {
    obj: ProofOfDSG;
    constructor(obj: ProofOfDSG);
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class ProofOfServiceDescTypeInfo extends DescTypeInfo {
    obj_type(): number;
    sub_desc_type(): SubDescType;
}
export class ProofOfServiceDescContent extends DescContent {
    proof_type: ProofTypeCode;
    data: ProofData;
    constructor(proof_type: ProofTypeCode, data: ProofData);
    type_info(): DescTypeInfo;
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
}
export class ProofOfServiceDescContentDecoder extends DescContentDecoder<ProofOfServiceDescContent> {
    type_info(): DescTypeInfo;
    raw_decode(buf: Uint8Array): BuckyResult<[ProofOfServiceDescContent, Uint8Array]>;
}
export class ProofOfServiceBodyContent extends BodyContent {
    data: ProofData;
    constructor(data: ProofData);
    raw_measure(): BuckyResult<number>;
    raw_encode(buf: Uint8Array): BuckyResult<Uint8Array>;
}
export class ProofOfServiceBodyContentDecoder extends BodyContentDecoder<ProofOfServiceBodyContent> {
    raw_decode(buf: Uint8Array): BuckyResult<[ProofOfServiceBodyContent, Uint8Array]>;
}
export class ProofOfServiceDesc extends NamedObjectDesc<ProofOfServiceDescContent> {
}
export class ProofOfServiceDescDecoder extends NamedObjectDescDecoder<ProofOfServiceDescContent> {
    constructor();
}
export class ProofOfServiceBuilder extends NamedObjectBuilder<ProofOfServiceDescContent, ProofOfServiceBodyContent> {
}
export class ProofOfServiceId extends NamedObjectId<ProofOfServiceDescContent, ProofOfServiceBodyContent> {
    constructor(id: ObjectId);
    static default(): ProofOfServiceId;
    static from_base_58(s: string): BuckyResult<ProofOfServiceId>;
    static try_from_object_id(id: ObjectId): BuckyResult<ProofOfServiceId>;
}
export class ProofOfServiceIdDecoder extends NamedObjectIdDecoder<ProofOfServiceDescContent, ProofOfServiceBodyContent> {
    constructor();
}
export class ProofOfService extends NamedObject<ProofOfServiceDescContent, ProofOfServiceBodyContent> {
    static create(owner: Option<ObjectId>, proof_type: ProofTypeCode, data_0: ProofData, data_1: ProofData): ProofOfService;
    ext(): ProofOfServiceExt;
}
export class ProofOfServiceDecoder extends NamedObjectDecoder<ProofOfServiceDescContent, ProofOfServiceBodyContent, ProofOfService> {
    constructor();
}

export class ProofOfServiceExt {
    obj: ProofOfService;
    constructor(obj: ProofOfService);
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class ProofOfSNService implements RawEncode {
    version: SnServiceReceiptVersion;
    grade: SnServiceGrade;
    rto: JSBI;
    duration: JSBI;
    start_time: JSBI;
    ping_count: JSBI;
    ping_resp_count: JSBI;
    called_count: JSBI;
    call_peer_count: JSBI;
    connect_peer_count: JSBI;
    call_delay: JSBI;
    constructor(version: SnServiceReceiptVersion, grade: SnServiceGrade, rto: JSBI, duration: JSBI, start_time: JSBI, ping_count: JSBI, ping_resp_count: JSBI, called_count: JSBI, call_peer_count: JSBI, connect_peer_count: JSBI, call_delay: JSBI);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class ProofOfSNServiceDecoder implements RawDecode<ProofOfSNService> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[ProofOfSNService, Uint8Array]>;
}

export class ProofOfSNServiceExt {
    obj: ProofOfSNService;
    constructor(obj: ProofOfSNService);
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class ProofTypeCode implements RawEncode {
    static DSGStorage(): ProofTypeCode;
    static DSGStorageCheck(): ProofTypeCode;
    static DSGMerkleProof(): ProofTypeCode;
    match<T>(visitor: {
        DSGStorage?: () => T;
        DSGStorageCheck?: () => T;
        DSGMerkleProof?: () => T;
    }): T | undefined;
    eq_type(rhs: ProofTypeCode): boolean;
    ext(): ProofTypeCodeExt;
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class ProofTypeCodeDecoder implements RawDecode<ProofTypeCode> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[ProofTypeCode, Uint8Array]>;
}

export class ProofTypeCodeExt {
    obj: ProofTypeCode;
    constructor(obj: ProofTypeCode);
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class Service implements RawEncode {
    static Contract(contract: ServiceContract): Service;
    static Receipt(receipt: ServiceReceipt): Service;
    match<T>(visitor: {
        Contract?: (contract: ServiceContract) => T;
        Receipt?: (receipt: ServiceReceipt) => T;
    }): T | undefined;
    eq_type(rhs: Service): boolean;
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class ServiceDecoder implements RawDecode<Service> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[Service, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class ServiceContract implements RawEncode {
    buyer: ObjectId;
    seller: ObjectId;
    customer: Option<ObjectId>;
    service_type: number;
    service_start: JSBI;
    service_end: JSBI;
    coin_id: Option<number>;
    total_price: Option<JSBI>;
    advance_payment: Option<JSBI>;
    contract_body: ServiceContractBody;
    constructor(buyer: ObjectId, seller: ObjectId, customer: Option<ObjectId>, service_type: number, service_start: JSBI, service_end: JSBI, coin_id: Option<number>, total_price: Option<JSBI>, advance_payment: Option<JSBI>, contract_body: ServiceContractBody);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class ServiceContractDecoder implements RawDecode<ServiceContract> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[ServiceContract, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class ServiceContractBody implements RawEncode {
    static Traffic(traffic: TrafficContract): ServiceContractBody;
    static ChunkTrans(chunktrans: ChunkTransContract): ServiceContractBody;
    match<T>(visitor: {
        Traffic?: (traffic: TrafficContract) => T;
        ChunkTrans?: (chunktrans: ChunkTransContract) => T;
    }): T | undefined;
    eq_type(rhs: ServiceContractBody): boolean;
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class ServiceContractBodyDecoder implements RawDecode<ServiceContractBody> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[ServiceContractBody, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class ServiceReceipt implements RawEncode {
    customer: ObjectId;
    service_type: number;
    service_start: JSBI;
    service_end: JSBI;
    receipt_body: ServiceReceiptBody;
    constructor(customer: ObjectId, service_type: number, service_start: JSBI, service_end: JSBI, receipt_body: ServiceReceiptBody);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class ServiceReceiptDecoder implements RawDecode<ServiceReceipt> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[ServiceReceipt, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class ServiceReceiptBody implements RawEncode {
    static SN(sn: SNReceipt): ServiceReceiptBody;
    static Traffic(traffic: TrafficReceipt): ServiceReceiptBody;
    static ChunkTrans(chunktrans: ChunkTransReceipt): ServiceReceiptBody;
    static DSG(dsg: DSGReceipt): ServiceReceiptBody;
    match<T>(visitor: {
        SN?: (sn: SNReceipt) => T;
        Traffic?: (traffic: TrafficReceipt) => T;
        ChunkTrans?: (chunktrans: ChunkTransReceipt) => T;
        DSG?: (dsg: DSGReceipt) => T;
    }): T | undefined;
    eq_type(rhs: ServiceReceiptBody): boolean;
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class ServiceReceiptBodyDecoder implements RawDecode<ServiceReceiptBody> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[ServiceReceiptBody, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class SNReceipt implements RawEncode {
    ping_count: Option<number>;
    called_count: Option<number>;
    success_called_count: Option<number>;
    constructor(ping_count: Option<number>, called_count: Option<number>, success_called_count: Option<number>);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class SNReceiptDecoder implements RawDecode<SNReceipt> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[SNReceipt, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class SnServiceGrade implements RawEncode {
    static None(): SnServiceGrade;
    static Discard(): SnServiceGrade;
    static Passable(): SnServiceGrade;
    static Normal(): SnServiceGrade;
    static Fine(): SnServiceGrade;
    static Wonderfull(): SnServiceGrade;
    match<T>(visitor: {
        None?: () => T;
        Discard?: () => T;
        Passable?: () => T;
        Normal?: () => T;
        Fine?: () => T;
        Wonderfull?: () => T;
    }): T | undefined;
    eq_type(rhs: SnServiceGrade): boolean;
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class SnServiceGradeDecoder implements RawDecode<SnServiceGrade> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[SnServiceGrade, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class SnServiceReceiptVersion implements RawEncode {
    static Invalid(): SnServiceReceiptVersion;
    static Current(): SnServiceReceiptVersion;
    match<T>(visitor: {
        Invalid?: () => T;
        Current?: () => T;
    }): T | undefined;
    eq_type(rhs: SnServiceReceiptVersion): boolean;
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class SnServiceReceiptVersionDecoder implements RawDecode<SnServiceReceiptVersion> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[SnServiceReceiptVersion, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class TrafficContract implements RawEncode {
    price_per_kbytes: number;
    avg_ping_ms: Option<number>;
    max_up_bytes: Option<JSBI>;
    max_up_speed: Option<number>;
    min_up_speed: Option<number>;
    max_down_bytes: Option<JSBI>;
    max_down_speed: Option<number>;
    min_down_speed: Option<number>;
    constructor(price_per_kbytes: number, avg_ping_ms: Option<number>, max_up_bytes: Option<JSBI>, max_up_speed: Option<number>, min_up_speed: Option<number>, max_down_bytes: Option<JSBI>, max_down_speed: Option<number>, min_down_speed: Option<number>);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class TrafficContractDecoder implements RawDecode<TrafficContract> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[TrafficContract, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class TrafficReceipt implements RawEncode {
    up_bytes: JSBI;
    down_bytes: JSBI;
    total_package: JSBI;
    max_speed: Option<number>;
    min_speed: Option<number>;
    avg_ping_ms: Option<number>;
    stream_count: Option<number>;
    failed_stream_count: Option<number>;
    break_stream_count: Option<number>;
    constructor(up_bytes: JSBI, down_bytes: JSBI, total_package: JSBI, max_speed: Option<number>, min_speed: Option<number>, avg_ping_ms: Option<number>, stream_count: Option<number>, failed_stream_count: Option<number>, break_stream_count: Option<number>);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class TrafficReceiptDecoder implements RawDecode<TrafficReceipt> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[TrafficReceipt, Uint8Array]>;
}

export class NameInfo {
    sub_records: BuckyMap<BuckyString, NameRecord>;
    record: NameRecord;
    owner: Option<ObjectId>;
    constructor(sub_records: BuckyMap<BuckyString, NameRecord>, record: NameRecord, owner: Option<ObjectId>);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class NameInfoDecoder implements RawDecode<NameInfo> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[NameInfo, Uint8Array]>;
}

export class NameLink implements RawEncode {
    static ObjectLink(obj_link: ObjectId): NameLink;
    static OtherNameLink(other_name_link: string): NameLink;
    static IPLink(ip_link: IpAddr): NameLink;
    match<T>(visitor: {
        ObjectLink?: (obj_link: ObjectId) => T;
        OtherNameLink?: (other_name_link: string) => T;
        IPLink?: (ip_link: IpAddr) => T;
    }): T | undefined;
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class NameLinkDecoder implements RawDecode<NameLink> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[NameLink, Uint8Array]>;
}

export class NameRecord implements RawEncode {
    link: NameLink;
    user_data: string;
    constructor(link: NameLink, user_data: string);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class NameRecordDecoder implements RawDecode<NameRecord> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[NameRecord, Uint8Array]>;
}

/*****************************************************
  * This code is auto generated from auto.js
  * Please DO NOT MODIFY this file
  * author: fanfeilong@buckyos.com
  * date: Thu Mar 04 2021 19:16:17 GMT+0800 (GMT+08:00)
  *****************************************************/
export class NameState implements RawEncode {
    static Normal(): NameState;
    static Lock(): NameState;
    static Auction(): NameState;
    static ArrearsAuction(): NameState;
    static ArrearsAuctionWait(): NameState;
    static ActiveAuction(): NameState;
    match<T>(visitor: {
        Normal?: () => T;
        Lock?: () => T;
        Auction?: () => T;
        ArrearsAuction?: () => T;
        ArrearsAuctionWait?: () => T;
        ActiveAuction?: () => T;
    }): T | undefined;
    eq_type(rhs: NameState): boolean;
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class NameStateDecoder implements RawDecode<NameState> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[NameState, Uint8Array]>;
}

export class CreateContractTx implements RawEncode {
    value: JSBI;
    init_data: Uint8Array;
    constructor(value: JSBI, init_data: Uint8Array);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class CreateContractTxDecoder implements RawDecode<CreateContractTx> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[CreateContractTx, Uint8Array]>;
}

export class CreateContract2Tx implements RawEncode {
    value: JSBI;
    init_data: Uint8Array;
    salt: Uint8Array;
    constructor(value: JSBI, init_data: Uint8Array, salt: Uint8Array);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class CreateContract2TxDecoder implements RawDecode<CreateContract2Tx> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[CreateContract2Tx, Uint8Array]>;
}

export class CallContractTx implements RawEncode {
    address: ObjectId;
    value: JSBI;
    data: Uint8Array;
    constructor(address: ObjectId, value: JSBI, data: Uint8Array);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class CallContractTxDecoder implements RawDecode<CallContractTx> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[CallContractTx, Uint8Array]>;
}

export class TypeBuffer<T extends RawEncode> implements RawEncode {
    obj: T;
    constructor(obj: T);
    raw_measure(ctx?: any, purpose?: RawEncodePurpose): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any, purpose?: RawEncodePurpose): BuckyResult<Uint8Array>;
}
export class TypeBufferDecoder<T extends RawEncode, D extends RawDecode<T>> implements RawDecode<TypeBuffer<T>> {
    constructor(inner_decoder: D);
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[TypeBuffer<T>, Uint8Array]>;
}

export class ViewContract implements RawEncode {
    address: ObjectId;
    data: Uint8Array;
    constructor(address: ObjectId, data: Uint8Array);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class ViewContractDecoder implements RawDecode<ViewContract> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[ViewContract, Uint8Array]>;
}

export class ViewLog implements RawEncode {
    address: ObjectId;
    from: number;
    to: number;
    topic: Vec<OptionEncoder<BuckyFixedBuffer>>;
    constructor(address: ObjectId, from: number, to: number, topics: (Uint8Array | null)[]);
    raw_measure(ctx?: any, purpose?: RawEncodePurpose): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any, purpose?: RawEncodePurpose): BuckyResult<Uint8Array>;
}
export class ViewLogDecoder implements RawDecode<ViewLog> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[ViewLog, Uint8Array]>;
}

export class ViewContractResult implements RawEncode {
    ret: number;
    value: Uint8Array;
    constructor(ret: number, value: Uint8Array);
    raw_measure(ctx?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any): BuckyResult<Uint8Array>;
}
export class ViewContractResultDecoder implements RawDecode<ViewContractResult> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[ViewContractResult, Uint8Array]>;
}

export class ViewLogResult implements RawEncode {
    logs: [Uint8Array[], Uint8Array][];
    constructor(logs: Vec<BuckyTuple>);
    raw_measure(ctx?: any, purpose?: RawEncodePurpose): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any, purpose?: RawEncodePurpose): BuckyResult<Uint8Array>;
}
export class ViewLogResultDecoder implements RawDecode<ViewLogResult> {
    raw_decode(buf: Uint8Array, ctx?: any): BuckyResult<[ViewLogResult, Uint8Array]>;
}

export { protos };

export interface UtilOutputRequestCommon {
    req_path?: string;
    dec_id?: ObjectId;
    target?: ObjectId;
    flags: number;
}
export interface UtilGetDeviceOutputRequest {
    common: UtilOutputRequestCommon;
}
export interface UtilGetDeviceOutputResponse {
    device_id: DeviceId;
    device: Device;
}
export interface UtilGetZoneOutputRequest {
    common: UtilOutputRequestCommon;
    object_id?: ObjectId;
    object_raw?: Uint8Array;
}
export interface UtilGetZoneOutputResponse {
    zone_id: ZoneId;
    zone: Zone;
    device_id: DeviceId;
}
export interface UtilResolveOODOutputRequest {
    common: UtilOutputRequestCommon;
    object_id: ObjectId;
    owner_id?: ObjectId;
}
export interface UtilResolveOODOutputResponse {
    device_list: DeviceId[];
}
export class UtilResolveOODOutputResponseJsonCodec extends JsonCodec<UtilResolveOODOutputResponse> {
    constructor();
    decode_object(o: any): BuckyResult<UtilResolveOODOutputResponse>;
}
export enum OODNetworkType {
    Unknown = "unknown",
    Intranet = "intranet",
    Extranet = "extranet"
}
export interface OODStatus {
    network: OODNetworkType;
    first_ping: JSBI;
    first_success_ping: JSBI;
    last_success_ping: JSBI;
    last_ping: JSBI;
    last_ping_result: number;
    ping_count: number;
    ping_success_count: JSBI;
    cont_fail_count: number;
    ping_avg_during: JSBI;
    ping_max_during: JSBI;
    ping_min_during: JSBI;
}
export class OODStatusJsonCodec extends JsonCodec<OODStatus> {
    constructor();
    decode_object(o: any): BuckyResult<OODStatus>;
}
export interface UtilGetOODStatusOutputRequest {
    common: UtilOutputRequestCommon;
}
export interface UtilGetOODStatusOutputResponse {
    status: OODStatus;
}
export class UtilGetOODStatusOutputResponseJsonCodec extends JsonCodec<UtilGetOODStatusOutputResponse> {
    constructor();
    decode_object(o: any): BuckyResult<UtilGetOODStatusOutputResponse>;
}
export interface UtilGetNOCInfoOutputRequest {
    common: UtilOutputRequestCommon;
}
export interface UtilGetNOCInfoOutputResponse {
    stat: NamedObjectCacheStat;
}
export interface DeviceStaticInfo {
    device_id: DeviceId;
    device: Device;
    is_ood_device: boolean;
    ood_device_id: DeviceId;
    zone_id: ZoneId;
    owner_id?: ObjectId;
    cyfs_root: string;
}
export class DeviceStaticInfoJsonCodec extends JsonCodec<DeviceStaticInfo> {
    constructor();
    decode_object(o: any): BuckyResult<DeviceStaticInfo>;
}
export interface UtilGetDeviceStaticInfoOutputRequest {
    common: UtilOutputRequestCommon;
}
export interface UtilGetDeviceStaticInfoOutputResponse {
    info: DeviceStaticInfo;
}
export class UtilGetDeviceStaticInfoOutputResponseJsonCodec extends JsonCodec<UtilGetDeviceStaticInfoOutputResponse> {
    constructor();
    decode_object(o: any): BuckyResult<UtilGetDeviceStaticInfoOutputResponse>;
}
export enum BdtNetworkAccessType {
    NAT = "nat",
    WAN = "wan"
}
export interface BdtNetworkAccessEndpoint {
    lan_ep: Endpoint;
    wan_ep: Endpoint;
    access_type: BdtNetworkAccessType;
}
export class BdtNetworkAccessEndpointJsonCodec extends JsonCodec<BdtNetworkAccessEndpoint> {
    constructor();
    decode_object(o: any): BuckyResult<BdtNetworkAccessEndpoint>;
}
export interface BdtNetworkAccessSn {
    sn: DeviceId;
    sn_status: SnStatus;
}
export class BdtNetworkAccessSnJsonCodec extends JsonCodec<BdtNetworkAccessSn> {
    constructor();
    decode_object(o: any): BuckyResult<BdtNetworkAccessSn>;
}
export interface BdtNetworkAccessInfo {
    v4: BdtNetworkAccessEndpoint[];
    v6: BdtNetworkAccessEndpoint[];
    sn: BdtNetworkAccessSn[];
}
export class BdtNetworkAccessInfoJsonCodec extends JsonCodec<BdtNetworkAccessInfo> {
    constructor();
    decode_object(o: any): BuckyResult<BdtNetworkAccessInfo>;
}
export interface UtilGetNetworkAccessInfoOutputRequest {
    common: UtilOutputRequestCommon;
}
export interface UtilGetNetworkAccessInfoOutputResponse {
    info: BdtNetworkAccessInfo;
}
export class UtilGetNetworkAccessInfoOutputResponseJsonCodec extends JsonCodec<UtilGetNetworkAccessInfoOutputResponse> {
    constructor();
    decode_object(o: any): BuckyResult<UtilGetNetworkAccessInfoOutputResponse>;
}
export interface UtilGetSystemInfoOutputRequest {
    common: UtilOutputRequestCommon;
}
export interface UtilGetSystemInfoOutputResponse {
    info: SystemInfo;
}
export interface VersionInfo {
    version: string;
    channel: CyfsChannel;
    target: string;
}
export interface UtilGetVersionInfoOutputRequest {
    common: UtilOutputRequestCommon;
}
export interface UtilGetVersionInfoOutputResponse {
    info: VersionInfo;
}

export abstract class WebSocketRequestHandler {
    on_request(requestor: WebSocketRequestManager, cmd: number, content: Uint8Array): Promise<BuckyResult<Option<Uint8Array>>>;
    process_string_request(requestor: WebSocketRequestManager, cmd: number, content: Uint8Array): Promise<BuckyResult<Option<Uint8Array>>>;
    on_string_request(requestor: WebSocketRequestManager, cmd: number, content: string): Promise<BuckyResult<Option<string>>>;
    abstract on_session_begin(session: WebSocketSession): Promise<void>;
    abstract on_session_end(session: WebSocketSession): Promise<void>;
    abstract clone_handler(): WebSocketRequestHandler;
}
export class RequestItem {
    seq: number;
    send_tick: JSBI;
    resp: Option<BuckyResult<Uint8Array>>;
    isTimeout: boolean;
    resolve?: () => void;
    waker: Promise<void>;
    constructor(seq: number, send_tick: JSBI);
    timeout(): void;
}
interface RequestResult {
    seq: number;
    req_item: RequestItem;
    list: {
        [n: number]: RequestItem;
    };
}
export class WebSocketRequestContainer {
    next_seq: number;
    list: {
        [n: number]: RequestItem;
    };
    new_request(sid: number): RequestResult;
    remove_request(seq: number): RequestItem;
    check_timeout(): {};
    clear(): void;
    static on_timeout(sid: number, list: {
        [n: number]: RequestItem;
    }): void;
}
export class WebSocketRequestManager {
    handler: WebSocketRequestHandler;
    is_monitor: boolean;
    sid: number;
    session: Option<WebSocketSession>;
    reqs: WebSocketRequestContainer;
    constructor(handler: WebSocketRequestHandler);
    is_session_valid(): boolean;
    bind_session(session: WebSocketSession): void;
    unbind_session(): void;
    static on_msg(requestor: WebSocketRequestManager, packet: WSPacket): Promise<BuckyResult<void>>;
    post_bytes_req(cmd: number, msg: Uint8Array): Promise<BuckyResult<Uint8Array>>;
    post_req(cmd: number, msg: string): Promise<BuckyResult<string>>;
    on_resp(packet: WSPacket): Promise<BuckyResult<void>>;
    monitor(): Promise<void>;
    stop_monitor(): void;
    post_to_session(buf: Uint8Array): Promise<BuckyResult<void>>;
    post_req_without_resp(cmd: number, msg: string): BuckyResult<void>;
    post_buffer_req_without_resp(cmd: number, msg: Uint8Array): BuckyResult<void>;
}
export {};

export class WebSocketSession {
    sid: number;
    handler: WebSocketRequestHandler;
    requestor: WebSocketRequestManager;
    constructor(sid: number, source: string, handler: WebSocketRequestHandler);
    post_msg(msg: Uint8Array): BuckyResult<void>;
    static run_client(session: WebSocketSession, ws: WebSocket): Promise<void>;
    static run(session: WebSocketSession, ws: WebSocket, as_server: boolean): Promise<void>;
}

export class WebSocketClient {
    service_url: string;
    handler: WebSocketRequestHandler;
    ws?: WebSocket;
    session_manager: WebSocketSessionManager;
    constructor(service_url: string, handler: WebSocketRequestHandler);
    select_session(): WebSocketSession | undefined;
    run(): Promise<void>;
    run_once(): Promise<unknown>;
    start(): void;
}

export interface EthAbiResult extends ReadonlyArray<any> {
    readonly [key: string]: any;
}
export function checkResultErrors(result: EthAbiResult): {
    path: (string | number)[];
    error: Error;
}[];
export type CoerceFunc = (type: string, value: any) => any;
export abstract class Coder {
    readonly name: string;
    readonly type: string;
    readonly localName?: string;
    readonly dynamic: boolean;
    constructor(name: string, type: string, localName: string | undefined, dynamic: boolean);
    _throwError(message: string, value: any): void;
    abstract encode(writer: Writer, value: any): number;
    abstract decode(reader: Reader): any;
    abstract defaultValue(): any;
}
export class Writer {
    readonly wordSize: number;
    _data: Uint8Array[];
    _dataLength: number;
    _padding: Uint8Array;
    constructor(wordSize: number);
    get data(): string;
    get length(): number;
    _writeData(data: Uint8Array): number;
    appendWriter(writer: Writer): number;
    writeBytes(value: BytesLike): number;
    _getValue(value: BigNumberish): Uint8Array;
    writeValue(value: BigNumberish): number;
    writeUpdatableValue(): (value: BigNumberish) => void;
}
export class Reader {
    readonly wordSize: number;
    readonly _coerceFunc?: CoerceFunc | undefined;
    readonly allowLoose?: boolean | undefined;
    readonly _data: Uint8Array;
    _offset: number;
    constructor(data: BytesLike, wordSize: number, _coerceFunc?: CoerceFunc | undefined, allowLoose?: boolean | undefined);
    get data(): string;
    get consumed(): number;
    static coerce(name: string, value: any): any;
    coerce(name: string, value: any): any;
    _peekBytes(offset: number, length: number, loose?: boolean): Uint8Array;
    subReader(offset: number): Reader;
    readBytes(length: number, loose?: boolean): Uint8Array;
    readValue(): BigNumber;
}

export abstract class ProtobufDescContent<P> extends DescContent {
    constructor(encode: (value: P, writer?: Writer) => Writer);
    abstract try_to_proto(): BuckyResult<P>;
    codec_info(): ContentCodecInfo;
    raw_measure(ctx?: any, purpose?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any, purpose?: any): BuckyResult<Uint8Array>;
}
export abstract class ProtobufDescContentDecoder<T extends DescContent, P> extends DescContentDecoder<T> {
    constructor(decode: (reader: Uint8Array) => P);
    abstract try_from_proto(value: P): BuckyResult<T>;
    raw_decode(buf: Uint8Array, ctx: ContentRawDecodeContext): BuckyResult<[T, Uint8Array]>;
}
export abstract class ProtobufBodyContent<P> extends BodyContent {
    constructor(encode: (value: P, writer?: Writer) => Writer);
    abstract try_to_proto(): BuckyResult<P>;
    codec_info(): ContentCodecInfo;
    raw_measure(ctx?: any, purpose?: any): BuckyResult<number>;
    raw_encode(buf: Uint8Array, ctx?: any, purpose?: any): BuckyResult<Uint8Array>;
}
export abstract class ProtobufBodyContentDecoder<T extends BodyContent, P> extends BodyContentDecoder<T> {
    constructor(decode: (reader: Uint8Array) => P);
    abstract try_from_proto(value: P): BuckyResult<T>;
    raw_decode(buf: Uint8Array, ctx: ContentRawDecodeContext): BuckyResult<[T, Uint8Array]>;
}
export class ProtobufCodecHelper {
    static ensure_not_null<T>(value: T | null | undefined): BuckyResult<T>;
    static encode_buf_list<T extends RawEncode>(list: T[]): BuckyResult<Uint8Array[]>;
    static encode_multi_buf_list<T extends RawEncode>(...list: T[][]): BuckyResult<Uint8Array[][]>;
    static decode_buf_list<T>(list: Uint8Array[], decoder: RawDecode<T>): BuckyResult<T[]>;
    static encode_buf<T extends RawEncode>(value: T): BuckyResult<Uint8Array>;
    static decode_buf<T>(item: Uint8Array, decoder: RawDecode<T>): BuckyResult<T>;
    static encode_int64(value: JSBI): Long.Long;
    static decode_int64(value: Long.Long | number): JSBI;
}
export class EmptyProtobufBodyContent extends ProtobufBodyContent<protos.IEmptyContent> {
    constructor();
    try_to_proto(): BuckyResult<protos.IEmptyContent>;
}
export class EmptyProtobufBodyContentDecoder extends ProtobufBodyContentDecoder<EmptyProtobufBodyContent, protos.IEmptyContent> {
    constructor();
    try_from_proto(value: protos.IEmptyContent): BuckyResult<EmptyProtobufBodyContent>;
}

export interface SystemInfo {
    name: string;
    cpu_usage: number;
    total_memory: number;
    used_memory: number;
    received_bytes: number;
    transmitted_bytes: number;
}
export enum SnStatus {
    Init = "init",
    Connecting = "connecting",
    Online = "online",
    Offline = "offline"
}
export interface NamedObjectCacheStat {
    count: number;
    storage_size: number;
}

export class WSPacketHeader {
    seq: number;
    cmd: number;
    content_length: number;
    magic: number;
    version: number;
    constructor(seq: number, cmd: number, content_length: number);
    static parse(buf: Uint8Array): BuckyResult<WSPacketHeader>;
    encode(buf: Uint8Array): void;
}
export class WSPacket {
    header: WSPacketHeader;
    content: Uint8Array;
    constructor(header: WSPacketHeader, content: Uint8Array);
    static new_from_buffer(seq: number, cmd: number, msg: Uint8Array): WSPacket;
    static decode_from_buffer(buf: Uint8Array): WSPacket;
    encode(): Uint8Array;
}

class WebSocketSessionManagerInner {
    list: WebSocketSession[];
    next_sid: number;
    constructor(handler: WebSocketRequestHandler);
    get_session(sid: number): WebSocketSession | undefined;
    select_session(): WebSocketSession | undefined;
    new_session(source: string): WebSocketSession;
    remove_session(sid: number): WebSocketSession | undefined;
}
export class WebSocketSessionManager extends WebSocketSessionManagerInner {
    constructor(handler: WebSocketRequestHandler);
    run_client_session(service_url: string, ws: WebSocket): Promise<WebSocketSession>;
}
export {};

/** Properties of an EmptyContent. */
export interface IEmptyContent {
}

/** Represents an EmptyContent. */
export class EmptyContent implements IEmptyContent {

        /**
            * Constructs a new EmptyContent.
            * @param [properties] Properties to set
            */
        constructor(properties?: IEmptyContent);

        /**
            * Creates a new EmptyContent instance using the specified properties.
            * @param [properties] Properties to set
            * @returns EmptyContent instance
            */
        static create(properties?: IEmptyContent): EmptyContent;

        /**
            * Encodes the specified EmptyContent message. Does not implicitly {@link EmptyContent.verify|verify} messages.
            * @param message EmptyContent message or plain object to encode
            * @param [writer] Writer to encode to
            * @returns Writer
            */
        static encode(message: IEmptyContent, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
            * Encodes the specified EmptyContent message, length delimited. Does not implicitly {@link EmptyContent.verify|verify} messages.
            * @param message EmptyContent message or plain object to encode
            * @param [writer] Writer to encode to
            * @returns Writer
            */
        static encodeDelimited(message: IEmptyContent, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
            * Decodes an EmptyContent message from the specified reader or buffer.
            * @param reader Reader or buffer to decode from
            * @param [length] Message length if known beforehand
            * @returns EmptyContent
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */
        static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): EmptyContent;

        /**
            * Decodes an EmptyContent message from the specified reader or buffer, length delimited.
            * @param reader Reader or buffer to decode from
            * @returns EmptyContent
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */
        static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): EmptyContent;

        /**
            * Verifies an EmptyContent message.
            * @param message Plain object to verify
            * @returns `null` if valid, otherwise the reason why it is not
            */
        static verify(message: { [k: string]: any }): (string|null);

        /**
            * Creates an EmptyContent message from a plain object. Also converts values to their respective internal types.
            * @param object Plain object
            * @returns EmptyContent
            */
        static fromObject(object: { [k: string]: any }): EmptyContent;

        /**
            * Creates a plain object from an EmptyContent message. Also converts values to other types if specified.
            * @param message EmptyContent
            * @param [options] Conversion options
            * @returns Plain object
            */
        static toObject(message: EmptyContent, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
            * Converts this EmptyContent to JSON.
            * @returns JSON object
            */
        toJSON(): { [k: string]: any };
}

/** Properties of an EmptyContentV1. */
export interface IEmptyContentV1 {

        /** EmptyContentV1 name */
        name?: (string|null);
}

/** Represents an EmptyContentV1. */
export class EmptyContentV1 implements IEmptyContentV1 {

        /**
            * Constructs a new EmptyContentV1.
            * @param [properties] Properties to set
            */
        constructor(properties?: IEmptyContentV1);

        /** EmptyContentV1 name. */
        name: string;

        /**
            * Creates a new EmptyContentV1 instance using the specified properties.
            * @param [properties] Properties to set
            * @returns EmptyContentV1 instance
            */
        static create(properties?: IEmptyContentV1): EmptyContentV1;

        /**
            * Encodes the specified EmptyContentV1 message. Does not implicitly {@link EmptyContentV1.verify|verify} messages.
            * @param message EmptyContentV1 message or plain object to encode
            * @param [writer] Writer to encode to
            * @returns Writer
            */
        static encode(message: IEmptyContentV1, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
            * Encodes the specified EmptyContentV1 message, length delimited. Does not implicitly {@link EmptyContentV1.verify|verify} messages.
            * @param message EmptyContentV1 message or plain object to encode
            * @param [writer] Writer to encode to
            * @returns Writer
            */
        static encodeDelimited(message: IEmptyContentV1, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
            * Decodes an EmptyContentV1 message from the specified reader or buffer.
            * @param reader Reader or buffer to decode from
            * @param [length] Message length if known beforehand
            * @returns EmptyContentV1
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */
        static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): EmptyContentV1;

        /**
            * Decodes an EmptyContentV1 message from the specified reader or buffer, length delimited.
            * @param reader Reader or buffer to decode from
            * @returns EmptyContentV1
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */
        static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): EmptyContentV1;

        /**
            * Verifies an EmptyContentV1 message.
            * @param message Plain object to verify
            * @returns `null` if valid, otherwise the reason why it is not
            */
        static verify(message: { [k: string]: any }): (string|null);

        /**
            * Creates an EmptyContentV1 message from a plain object. Also converts values to their respective internal types.
            * @param object Plain object
            * @returns EmptyContentV1
            */
        static fromObject(object: { [k: string]: any }): EmptyContentV1;

        /**
            * Creates a plain object from an EmptyContentV1 message. Also converts values to other types if specified.
            * @param message EmptyContentV1
            * @param [options] Conversion options
            * @returns Plain object
            */
        static toObject(message: EmptyContentV1, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
            * Converts this EmptyContentV1 to JSON.
            * @returns JSON object
            */
        toJSON(): { [k: string]: any };
}

/** Properties of a ContractBodyContent. */
export interface IContractBodyContent {

        /** ContractBodyContent data */
        data?: (Uint8Array|null);
}

/** Represents a ContractBodyContent. */
export class ContractBodyContent implements IContractBodyContent {

        /**
            * Constructs a new ContractBodyContent.
            * @param [properties] Properties to set
            */
        constructor(properties?: IContractBodyContent);

        /** ContractBodyContent data. */
        data: Uint8Array;

        /**
            * Creates a new ContractBodyContent instance using the specified properties.
            * @param [properties] Properties to set
            * @returns ContractBodyContent instance
            */
        static create(properties?: IContractBodyContent): ContractBodyContent;

        /**
            * Encodes the specified ContractBodyContent message. Does not implicitly {@link ContractBodyContent.verify|verify} messages.
            * @param message ContractBodyContent message or plain object to encode
            * @param [writer] Writer to encode to
            * @returns Writer
            */
        static encode(message: IContractBodyContent, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
            * Encodes the specified ContractBodyContent message, length delimited. Does not implicitly {@link ContractBodyContent.verify|verify} messages.
            * @param message ContractBodyContent message or plain object to encode
            * @param [writer] Writer to encode to
            * @returns Writer
            */
        static encodeDelimited(message: IContractBodyContent, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
            * Decodes a ContractBodyContent message from the specified reader or buffer.
            * @param reader Reader or buffer to decode from
            * @param [length] Message length if known beforehand
            * @returns ContractBodyContent
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */
        static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): ContractBodyContent;

        /**
            * Decodes a ContractBodyContent message from the specified reader or buffer, length delimited.
            * @param reader Reader or buffer to decode from
            * @returns ContractBodyContent
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */
        static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): ContractBodyContent;

        /**
            * Verifies a ContractBodyContent message.
            * @param message Plain object to verify
            * @returns `null` if valid, otherwise the reason why it is not
            */
        static verify(message: { [k: string]: any }): (string|null);

        /**
            * Creates a ContractBodyContent message from a plain object. Also converts values to their respective internal types.
            * @param object Plain object
            * @returns ContractBodyContent
            */
        static fromObject(object: { [k: string]: any }): ContractBodyContent;

        /**
            * Creates a plain object from a ContractBodyContent message. Also converts values to other types if specified.
            * @param message ContractBodyContent
            * @param [options] Conversion options
            * @returns Plain object
            */
        static toObject(message: ContractBodyContent, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
            * Converts this ContractBodyContent to JSON.
            * @returns JSON object
            */
        toJSON(): { [k: string]: any };
}

/** Properties of a DeviceBodyContent. */
export interface IDeviceBodyContent {

        /** DeviceBodyContent endpoints */
        endpoints?: (Uint8Array[]|null);

        /** DeviceBodyContent sn_list */
        sn_list?: (Uint8Array[]|null);

        /** DeviceBodyContent passive_pn_list */
        passive_pn_list?: (Uint8Array[]|null);

        /** DeviceBodyContent name */
        name?: (string|null);
}

/** Represents a DeviceBodyContent. */
export class DeviceBodyContent implements IDeviceBodyContent {

        /**
            * Constructs a new DeviceBodyContent.
            * @param [properties] Properties to set
            */
        constructor(properties?: IDeviceBodyContent);

        /** DeviceBodyContent endpoints. */
        endpoints: Uint8Array[];

        /** DeviceBodyContent sn_list. */
        sn_list: Uint8Array[];

        /** DeviceBodyContent passive_pn_list. */
        passive_pn_list: Uint8Array[];

        /** DeviceBodyContent name. */
        name?: (string|null);

        /** DeviceBodyContent _name. */
        _name?: "name";

        /**
            * Creates a new DeviceBodyContent instance using the specified properties.
            * @param [properties] Properties to set
            * @returns DeviceBodyContent instance
            */
        static create(properties?: IDeviceBodyContent): DeviceBodyContent;

        /**
            * Encodes the specified DeviceBodyContent message. Does not implicitly {@link DeviceBodyContent.verify|verify} messages.
            * @param message DeviceBodyContent message or plain object to encode
            * @param [writer] Writer to encode to
            * @returns Writer
            */
        static encode(message: IDeviceBodyContent, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
            * Encodes the specified DeviceBodyContent message, length delimited. Does not implicitly {@link DeviceBodyContent.verify|verify} messages.
            * @param message DeviceBodyContent message or plain object to encode
            * @param [writer] Writer to encode to
            * @returns Writer
            */
        static encodeDelimited(message: IDeviceBodyContent, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
            * Decodes a DeviceBodyContent message from the specified reader or buffer.
            * @param reader Reader or buffer to decode from
            * @param [length] Message length if known beforehand
            * @returns DeviceBodyContent
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */
        static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): DeviceBodyContent;

        /**
            * Decodes a DeviceBodyContent message from the specified reader or buffer, length delimited.
            * @param reader Reader or buffer to decode from
            * @returns DeviceBodyContent
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */
        static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): DeviceBodyContent;

        /**
            * Verifies a DeviceBodyContent message.
            * @param message Plain object to verify
            * @returns `null` if valid, otherwise the reason why it is not
            */
        static verify(message: { [k: string]: any }): (string|null);

        /**
            * Creates a DeviceBodyContent message from a plain object. Also converts values to their respective internal types.
            * @param object Plain object
            * @returns DeviceBodyContent
            */
        static fromObject(object: { [k: string]: any }): DeviceBodyContent;

        /**
            * Creates a plain object from a DeviceBodyContent message. Also converts values to other types if specified.
            * @param message DeviceBodyContent
            * @param [options] Conversion options
            * @returns Plain object
            */
        static toObject(message: DeviceBodyContent, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
            * Converts this DeviceBodyContent to JSON.
            * @returns JSON object
            */
        toJSON(): { [k: string]: any };
}

/** Properties of a DirBodyContent. */
export interface IDirBodyContent {

        /** DirBodyContent type */
        type?: (DirBodyContent.Type|null);

        /** DirBodyContent chunk_id */
        chunk_id?: (Uint8Array|null);

        /** DirBodyContent obj_list */
        obj_list?: (DirBodyContent.IObjItem[]|null);
}

/** Represents a DirBodyContent. */
export class DirBodyContent implements IDirBodyContent {

        /**
            * Constructs a new DirBodyContent.
            * @param [properties] Properties to set
            */
        constructor(properties?: IDirBodyContent);

        /** DirBodyContent type. */
        type: DirBodyContent.Type;

        /** DirBodyContent chunk_id. */
        chunk_id?: (Uint8Array|null);

        /** DirBodyContent obj_list. */
        obj_list: DirBodyContent.IObjItem[];

        /** DirBodyContent _chunk_id. */
        _chunk_id?: "chunk_id";

        /**
            * Creates a new DirBodyContent instance using the specified properties.
            * @param [properties] Properties to set
            * @returns DirBodyContent instance
            */
        static create(properties?: IDirBodyContent): DirBodyContent;

        /**
            * Encodes the specified DirBodyContent message. Does not implicitly {@link DirBodyContent.verify|verify} messages.
            * @param message DirBodyContent message or plain object to encode
            * @param [writer] Writer to encode to
            * @returns Writer
            */
        static encode(message: IDirBodyContent, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
            * Encodes the specified DirBodyContent message, length delimited. Does not implicitly {@link DirBodyContent.verify|verify} messages.
            * @param message DirBodyContent message or plain object to encode
            * @param [writer] Writer to encode to
            * @returns Writer
            */
        static encodeDelimited(message: IDirBodyContent, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
            * Decodes a DirBodyContent message from the specified reader or buffer.
            * @param reader Reader or buffer to decode from
            * @param [length] Message length if known beforehand
            * @returns DirBodyContent
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */
        static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): DirBodyContent;

        /**
            * Decodes a DirBodyContent message from the specified reader or buffer, length delimited.
            * @param reader Reader or buffer to decode from
            * @returns DirBodyContent
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */
        static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): DirBodyContent;

        /**
            * Verifies a DirBodyContent message.
            * @param message Plain object to verify
            * @returns `null` if valid, otherwise the reason why it is not
            */
        static verify(message: { [k: string]: any }): (string|null);

        /**
            * Creates a DirBodyContent message from a plain object. Also converts values to their respective internal types.
            * @param object Plain object
            * @returns DirBodyContent
            */
        static fromObject(object: { [k: string]: any }): DirBodyContent;

        /**
            * Creates a plain object from a DirBodyContent message. Also converts values to other types if specified.
            * @param message DirBodyContent
            * @param [options] Conversion options
            * @returns Plain object
            */
        static toObject(message: DirBodyContent, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
            * Converts this DirBodyContent to JSON.
            * @returns JSON object
            */
        toJSON(): { [k: string]: any };
}

export namespace DirBodyContent {

        /** Type enum. */
        enum Type {
                Chunk = 0,
                ObjList = 1
        }

        /** Properties of an ObjItem. */
        interface IObjItem {

                /** ObjItem obj_id */
                obj_id?: (Uint8Array|null);

                /** ObjItem value */
                value?: (Uint8Array|null);
        }

        /** Represents an ObjItem. */
        class ObjItem implements IObjItem {

                /**
                    * Constructs a new ObjItem.
                    * @param [properties] Properties to set
                    */
                constructor(properties?: DirBodyContent.IObjItem);

                /** ObjItem obj_id. */
                obj_id: Uint8Array;

                /** ObjItem value. */
                value: Uint8Array;

                /**
                    * Creates a new ObjItem instance using the specified properties.
                    * @param [properties] Properties to set
                    * @returns ObjItem instance
                    */
                static create(properties?: DirBodyContent.IObjItem): DirBodyContent.ObjItem;

                /**
                    * Encodes the specified ObjItem message. Does not implicitly {@link DirBodyContent.ObjItem.verify|verify} messages.
                    * @param message ObjItem message or plain object to encode
                    * @param [writer] Writer to encode to
                    * @returns Writer
                    */
                static encode(message: DirBodyContent.IObjItem, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                    * Encodes the specified ObjItem message, length delimited. Does not implicitly {@link DirBodyContent.ObjItem.verify|verify} messages.
                    * @param message ObjItem message or plain object to encode
                    * @param [writer] Writer to encode to
                    * @returns Writer
                    */
                static encodeDelimited(message: DirBodyContent.IObjItem, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                    * Decodes an ObjItem message from the specified reader or buffer.
                    * @param reader Reader or buffer to decode from
                    * @param [length] Message length if known beforehand
                    * @returns ObjItem
                    * @throws {Error} If the payload is not a reader or valid buffer
                    * @throws {$protobuf.util.ProtocolError} If required fields are missing
                    */
                static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): DirBodyContent.ObjItem;

                /**
                    * Decodes an ObjItem message from the specified reader or buffer, length delimited.
                    * @param reader Reader or buffer to decode from
                    * @returns ObjItem
                    * @throws {Error} If the payload is not a reader or valid buffer
                    * @throws {$protobuf.util.ProtocolError} If required fields are missing
                    */
                static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): DirBodyContent.ObjItem;

                /**
                    * Verifies an ObjItem message.
                    * @param message Plain object to verify
                    * @returns `null` if valid, otherwise the reason why it is not
                    */
                static verify(message: { [k: string]: any }): (string|null);

                /**
                    * Creates an ObjItem message from a plain object. Also converts values to their respective internal types.
                    * @param object Plain object
                    * @returns ObjItem
                    */
                static fromObject(object: { [k: string]: any }): DirBodyContent.ObjItem;

                /**
                    * Creates a plain object from an ObjItem message. Also converts values to other types if specified.
                    * @param message ObjItem
                    * @param [options] Conversion options
                    * @returns Plain object
                    */
                static toObject(message: DirBodyContent.ObjItem, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                    * Converts this ObjItem to JSON.
                    * @returns JSON object
                    */
                toJSON(): { [k: string]: any };
        }
}

/** Properties of a ChunkList. */
export interface IChunkList {

        /** ChunkList type */
        type?: (ChunkList.Type|null);

        /** ChunkList chunk_id_list */
        chunk_id_list?: (Uint8Array[]|null);

        /** ChunkList file_id */
        file_id?: (Uint8Array|null);
}

/** Represents a ChunkList. */
export class ChunkList implements IChunkList {

        /**
            * Constructs a new ChunkList.
            * @param [properties] Properties to set
            */
        constructor(properties?: IChunkList);

        /** ChunkList type. */
        type: ChunkList.Type;

        /** ChunkList chunk_id_list. */
        chunk_id_list: Uint8Array[];

        /** ChunkList file_id. */
        file_id: Uint8Array;

        /**
            * Creates a new ChunkList instance using the specified properties.
            * @param [properties] Properties to set
            * @returns ChunkList instance
            */
        static create(properties?: IChunkList): ChunkList;

        /**
            * Encodes the specified ChunkList message. Does not implicitly {@link ChunkList.verify|verify} messages.
            * @param message ChunkList message or plain object to encode
            * @param [writer] Writer to encode to
            * @returns Writer
            */
        static encode(message: IChunkList, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
            * Encodes the specified ChunkList message, length delimited. Does not implicitly {@link ChunkList.verify|verify} messages.
            * @param message ChunkList message or plain object to encode
            * @param [writer] Writer to encode to
            * @returns Writer
            */
        static encodeDelimited(message: IChunkList, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
            * Decodes a ChunkList message from the specified reader or buffer.
            * @param reader Reader or buffer to decode from
            * @param [length] Message length if known beforehand
            * @returns ChunkList
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */
        static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): ChunkList;

        /**
            * Decodes a ChunkList message from the specified reader or buffer, length delimited.
            * @param reader Reader or buffer to decode from
            * @returns ChunkList
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */
        static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): ChunkList;

        /**
            * Verifies a ChunkList message.
            * @param message Plain object to verify
            * @returns `null` if valid, otherwise the reason why it is not
            */
        static verify(message: { [k: string]: any }): (string|null);

        /**
            * Creates a ChunkList message from a plain object. Also converts values to their respective internal types.
            * @param object Plain object
            * @returns ChunkList
            */
        static fromObject(object: { [k: string]: any }): ChunkList;

        /**
            * Creates a plain object from a ChunkList message. Also converts values to other types if specified.
            * @param message ChunkList
            * @param [options] Conversion options
            * @returns Plain object
            */
        static toObject(message: ChunkList, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
            * Converts this ChunkList to JSON.
            * @returns JSON object
            */
        toJSON(): { [k: string]: any };
}

export namespace ChunkList {

        /** Type enum. */
        enum Type {
                ChunkInList = 0,
                ChunkInFile = 1
        }
}

/** Properties of a FileBodyContent. */
export interface IFileBodyContent {

        /** FileBodyContent chunk_list */
        chunk_list?: (IChunkList|null);
}

/** Represents a FileBodyContent. */
export class FileBodyContent implements IFileBodyContent {

        /**
            * Constructs a new FileBodyContent.
            * @param [properties] Properties to set
            */
        constructor(properties?: IFileBodyContent);

        /** FileBodyContent chunk_list. */
        chunk_list?: (IChunkList|null);

        /**
            * Creates a new FileBodyContent instance using the specified properties.
            * @param [properties] Properties to set
            * @returns FileBodyContent instance
            */
        static create(properties?: IFileBodyContent): FileBodyContent;

        /**
            * Encodes the specified FileBodyContent message. Does not implicitly {@link FileBodyContent.verify|verify} messages.
            * @param message FileBodyContent message or plain object to encode
            * @param [writer] Writer to encode to
            * @returns Writer
            */
        static encode(message: IFileBodyContent, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
            * Encodes the specified FileBodyContent message, length delimited. Does not implicitly {@link FileBodyContent.verify|verify} messages.
            * @param message FileBodyContent message or plain object to encode
            * @param [writer] Writer to encode to
            * @returns Writer
            */
        static encodeDelimited(message: IFileBodyContent, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
            * Decodes a FileBodyContent message from the specified reader or buffer.
            * @param reader Reader or buffer to decode from
            * @param [length] Message length if known beforehand
            * @returns FileBodyContent
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */
        static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): FileBodyContent;

        /**
            * Decodes a FileBodyContent message from the specified reader or buffer, length delimited.
            * @param reader Reader or buffer to decode from
            * @returns FileBodyContent
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */
        static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): FileBodyContent;

        /**
            * Verifies a FileBodyContent message.
            * @param message Plain object to verify
            * @returns `null` if valid, otherwise the reason why it is not
            */
        static verify(message: { [k: string]: any }): (string|null);

        /**
            * Creates a FileBodyContent message from a plain object. Also converts values to their respective internal types.
            * @param object Plain object
            * @returns FileBodyContent
            */
        static fromObject(object: { [k: string]: any }): FileBodyContent;

        /**
            * Creates a plain object from a FileBodyContent message. Also converts values to other types if specified.
            * @param message FileBodyContent
            * @param [options] Conversion options
            * @returns Plain object
            */
        static toObject(message: FileBodyContent, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
            * Converts this FileBodyContent to JSON.
            * @returns JSON object
            */
        toJSON(): { [k: string]: any };
}

/** Properties of a Director. */
export interface IDirector {

        /** Director id */
        id?: (Uint8Array|null);

        /** Director right */
        right?: (number|null);
}

/** Represents a Director. */
export class Director implements IDirector {

        /**
            * Constructs a new Director.
            * @param [properties] Properties to set
            */
        constructor(properties?: IDirector);

        /** Director id. */
        id: Uint8Array;

        /** Director right. */
        right: number;

        /**
            * Creates a new Director instance using the specified properties.
            * @param [properties] Properties to set
            * @returns Director instance
            */
        static create(properties?: IDirector): Director;

        /**
            * Encodes the specified Director message. Does not implicitly {@link Director.verify|verify} messages.
            * @param message Director message or plain object to encode
            * @param [writer] Writer to encode to
            * @returns Writer
            */
        static encode(message: IDirector, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
            * Encodes the specified Director message, length delimited. Does not implicitly {@link Director.verify|verify} messages.
            * @param message Director message or plain object to encode
            * @param [writer] Writer to encode to
            * @returns Writer
            */
        static encodeDelimited(message: IDirector, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
            * Decodes a Director message from the specified reader or buffer.
            * @param reader Reader or buffer to decode from
            * @param [length] Message length if known beforehand
            * @returns Director
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */
        static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): Director;

        /**
            * Decodes a Director message from the specified reader or buffer, length delimited.
            * @param reader Reader or buffer to decode from
            * @returns Director
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */
        static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): Director;

        /**
            * Verifies a Director message.
            * @param message Plain object to verify
            * @returns `null` if valid, otherwise the reason why it is not
            */
        static verify(message: { [k: string]: any }): (string|null);

        /**
            * Creates a Director message from a plain object. Also converts values to their respective internal types.
            * @param object Plain object
            * @returns Director
            */
        static fromObject(object: { [k: string]: any }): Director;

        /**
            * Creates a plain object from a Director message. Also converts values to other types if specified.
            * @param message Director
            * @param [options] Conversion options
            * @returns Plain object
            */
        static toObject(message: Director, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
            * Converts this Director to JSON.
            * @returns JSON object
            */
        toJSON(): { [k: string]: any };
}

/** Properties of an OrgMember. */
export interface IOrgMember {

        /** OrgMember id */
        id?: (Uint8Array|null);

        /** OrgMember right */
        right?: (number|null);

        /** OrgMember shares */
        shares?: (number|Long|null);
}

/** Represents an OrgMember. */
export class OrgMember implements IOrgMember {

        /**
            * Constructs a new OrgMember.
            * @param [properties] Properties to set
            */
        constructor(properties?: IOrgMember);

        /** OrgMember id. */
        id: Uint8Array;

        /** OrgMember right. */
        right: number;

        /** OrgMember shares. */
        shares: (number|Long);

        /**
            * Creates a new OrgMember instance using the specified properties.
            * @param [properties] Properties to set
            * @returns OrgMember instance
            */
        static create(properties?: IOrgMember): OrgMember;

        /**
            * Encodes the specified OrgMember message. Does not implicitly {@link OrgMember.verify|verify} messages.
            * @param message OrgMember message or plain object to encode
            * @param [writer] Writer to encode to
            * @returns Writer
            */
        static encode(message: IOrgMember, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
            * Encodes the specified OrgMember message, length delimited. Does not implicitly {@link OrgMember.verify|verify} messages.
            * @param message OrgMember message or plain object to encode
            * @param [writer] Writer to encode to
            * @returns Writer
            */
        static encodeDelimited(message: IOrgMember, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
            * Decodes an OrgMember message from the specified reader or buffer.
            * @param reader Reader or buffer to decode from
            * @param [length] Message length if known beforehand
            * @returns OrgMember
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */
        static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): OrgMember;

        /**
            * Decodes an OrgMember message from the specified reader or buffer, length delimited.
            * @param reader Reader or buffer to decode from
            * @returns OrgMember
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */
        static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): OrgMember;

        /**
            * Verifies an OrgMember message.
            * @param message Plain object to verify
            * @returns `null` if valid, otherwise the reason why it is not
            */
        static verify(message: { [k: string]: any }): (string|null);

        /**
            * Creates an OrgMember message from a plain object. Also converts values to their respective internal types.
            * @param object Plain object
            * @returns OrgMember
            */
        static fromObject(object: { [k: string]: any }): OrgMember;

        /**
            * Creates a plain object from an OrgMember message. Also converts values to other types if specified.
            * @param message OrgMember
            * @param [options] Conversion options
            * @returns Plain object
            */
        static toObject(message: OrgMember, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
            * Converts this OrgMember to JSON.
            * @returns JSON object
            */
        toJSON(): { [k: string]: any };
}

/** Properties of an OrgBodyContent. */
export interface IOrgBodyContent {

        /** OrgBodyContent members */
        members?: (IOrgMember[]|null);

        /** OrgBodyContent directors */
        directors?: (IDirector[]|null);

        /** OrgBodyContent total_equity */
        total_equity?: (number|Long|null);
}

/** Represents an OrgBodyContent. */
export class OrgBodyContent implements IOrgBodyContent {

        /**
            * Constructs a new OrgBodyContent.
            * @param [properties] Properties to set
            */
        constructor(properties?: IOrgBodyContent);

        /** OrgBodyContent members. */
        members: IOrgMember[];

        /** OrgBodyContent directors. */
        directors: IDirector[];

        /** OrgBodyContent total_equity. */
        total_equity: (number|Long);

        /**
            * Creates a new OrgBodyContent instance using the specified properties.
            * @param [properties] Properties to set
            * @returns OrgBodyContent instance
            */
        static create(properties?: IOrgBodyContent): OrgBodyContent;

        /**
            * Encodes the specified OrgBodyContent message. Does not implicitly {@link OrgBodyContent.verify|verify} messages.
            * @param message OrgBodyContent message or plain object to encode
            * @param [writer] Writer to encode to
            * @returns Writer
            */
        static encode(message: IOrgBodyContent, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
            * Encodes the specified OrgBodyContent message, length delimited. Does not implicitly {@link OrgBodyContent.verify|verify} messages.
            * @param message OrgBodyContent message or plain object to encode
            * @param [writer] Writer to encode to
            * @returns Writer
            */
        static encodeDelimited(message: IOrgBodyContent, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
            * Decodes an OrgBodyContent message from the specified reader or buffer.
            * @param reader Reader or buffer to decode from
            * @param [length] Message length if known beforehand
            * @returns OrgBodyContent
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */
        static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): OrgBodyContent;

        /**
            * Decodes an OrgBodyContent message from the specified reader or buffer, length delimited.
            * @param reader Reader or buffer to decode from
            * @returns OrgBodyContent
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */
        static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): OrgBodyContent;

        /**
            * Verifies an OrgBodyContent message.
            * @param message Plain object to verify
            * @returns `null` if valid, otherwise the reason why it is not
            */
        static verify(message: { [k: string]: any }): (string|null);

        /**
            * Creates an OrgBodyContent message from a plain object. Also converts values to their respective internal types.
            * @param object Plain object
            * @returns OrgBodyContent
            */
        static fromObject(object: { [k: string]: any }): OrgBodyContent;

        /**
            * Creates a plain object from an OrgBodyContent message. Also converts values to other types if specified.
            * @param message OrgBodyContent
            * @param [options] Conversion options
            * @returns Plain object
            */
        static toObject(message: OrgBodyContent, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
            * Converts this OrgBodyContent to JSON.
            * @returns JSON object
            */
        toJSON(): { [k: string]: any };
}

/** Properties of a PeopleBodyContent. */
export interface IPeopleBodyContent {

        /** PeopleBodyContent ood_list */
        ood_list?: (Uint8Array[]|null);

        /** PeopleBodyContent name */
        name?: (string|null);

        /** PeopleBodyContent icon */
        icon?: (Uint8Array|null);
}

/** Represents a PeopleBodyContent. */
export class PeopleBodyContent implements IPeopleBodyContent {

        /**
            * Constructs a new PeopleBodyContent.
            * @param [properties] Properties to set
            */
        constructor(properties?: IPeopleBodyContent);

        /** PeopleBodyContent ood_list. */
        ood_list: Uint8Array[];

        /** PeopleBodyContent name. */
        name?: (string|null);

        /** PeopleBodyContent icon. */
        icon?: (Uint8Array|null);

        /** PeopleBodyContent _name. */
        _name?: "name";

        /** PeopleBodyContent _icon. */
        _icon?: "icon";

        /**
            * Creates a new PeopleBodyContent instance using the specified properties.
            * @param [properties] Properties to set
            * @returns PeopleBodyContent instance
            */
        static create(properties?: IPeopleBodyContent): PeopleBodyContent;

        /**
            * Encodes the specified PeopleBodyContent message. Does not implicitly {@link PeopleBodyContent.verify|verify} messages.
            * @param message PeopleBodyContent message or plain object to encode
            * @param [writer] Writer to encode to
            * @returns Writer
            */
        static encode(message: IPeopleBodyContent, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
            * Encodes the specified PeopleBodyContent message, length delimited. Does not implicitly {@link PeopleBodyContent.verify|verify} messages.
            * @param message PeopleBodyContent message or plain object to encode
            * @param [writer] Writer to encode to
            * @returns Writer
            */
        static encodeDelimited(message: IPeopleBodyContent, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
            * Decodes a PeopleBodyContent message from the specified reader or buffer.
            * @param reader Reader or buffer to decode from
            * @param [length] Message length if known beforehand
            * @returns PeopleBodyContent
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */
        static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): PeopleBodyContent;

        /**
            * Decodes a PeopleBodyContent message from the specified reader or buffer, length delimited.
            * @param reader Reader or buffer to decode from
            * @returns PeopleBodyContent
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */
        static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): PeopleBodyContent;

        /**
            * Verifies a PeopleBodyContent message.
            * @param message Plain object to verify
            * @returns `null` if valid, otherwise the reason why it is not
            */
        static verify(message: { [k: string]: any }): (string|null);

        /**
            * Creates a PeopleBodyContent message from a plain object. Also converts values to their respective internal types.
            * @param object Plain object
            * @returns PeopleBodyContent
            */
        static fromObject(object: { [k: string]: any }): PeopleBodyContent;

        /**
            * Creates a plain object from a PeopleBodyContent message. Also converts values to other types if specified.
            * @param message PeopleBodyContent
            * @param [options] Conversion options
            * @returns Plain object
            */
        static toObject(message: PeopleBodyContent, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
            * Converts this PeopleBodyContent to JSON.
            * @returns JSON object
            */
        toJSON(): { [k: string]: any };
}

/** Properties of a SimpleGroupBodyContent. */
export interface ISimpleGroupBodyContent {

        /** SimpleGroupBodyContent members */
        members?: (Uint8Array[]|null);

        /** SimpleGroupBodyContent ood_list */
        ood_list?: (Uint8Array[]|null);
}

/** Represents a SimpleGroupBodyContent. */
export class SimpleGroupBodyContent implements ISimpleGroupBodyContent {

        /**
            * Constructs a new SimpleGroupBodyContent.
            * @param [properties] Properties to set
            */
        constructor(properties?: ISimpleGroupBodyContent);

        /** SimpleGroupBodyContent members. */
        members: Uint8Array[];

        /** SimpleGroupBodyContent ood_list. */
        ood_list: Uint8Array[];

        /**
            * Creates a new SimpleGroupBodyContent instance using the specified properties.
            * @param [properties] Properties to set
            * @returns SimpleGroupBodyContent instance
            */
        static create(properties?: ISimpleGroupBodyContent): SimpleGroupBodyContent;

        /**
            * Encodes the specified SimpleGroupBodyContent message. Does not implicitly {@link SimpleGroupBodyContent.verify|verify} messages.
            * @param message SimpleGroupBodyContent message or plain object to encode
            * @param [writer] Writer to encode to
            * @returns Writer
            */
        static encode(message: ISimpleGroupBodyContent, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
            * Encodes the specified SimpleGroupBodyContent message, length delimited. Does not implicitly {@link SimpleGroupBodyContent.verify|verify} messages.
            * @param message SimpleGroupBodyContent message or plain object to encode
            * @param [writer] Writer to encode to
            * @returns Writer
            */
        static encodeDelimited(message: ISimpleGroupBodyContent, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
            * Decodes a SimpleGroupBodyContent message from the specified reader or buffer.
            * @param reader Reader or buffer to decode from
            * @param [length] Message length if known beforehand
            * @returns SimpleGroupBodyContent
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */
        static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): SimpleGroupBodyContent;

        /**
            * Decodes a SimpleGroupBodyContent message from the specified reader or buffer, length delimited.
            * @param reader Reader or buffer to decode from
            * @returns SimpleGroupBodyContent
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */
        static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): SimpleGroupBodyContent;

        /**
            * Verifies a SimpleGroupBodyContent message.
            * @param message Plain object to verify
            * @returns `null` if valid, otherwise the reason why it is not
            */
        static verify(message: { [k: string]: any }): (string|null);

        /**
            * Creates a SimpleGroupBodyContent message from a plain object. Also converts values to their respective internal types.
            * @param object Plain object
            * @returns SimpleGroupBodyContent
            */
        static fromObject(object: { [k: string]: any }): SimpleGroupBodyContent;

        /**
            * Creates a plain object from a SimpleGroupBodyContent message. Also converts values to other types if specified.
            * @param message SimpleGroupBodyContent
            * @param [options] Conversion options
            * @returns Plain object
            */
        static toObject(message: SimpleGroupBodyContent, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
            * Converts this SimpleGroupBodyContent to JSON.
            * @returns JSON object
            */
        toJSON(): { [k: string]: any };
}

/** Properties of a TxBodyContent. */
export interface ITxBodyContent {

        /** TxBodyContent data */
        data?: (Uint8Array|null);
}

/** Represents a TxBodyContent. */
export class TxBodyContent implements ITxBodyContent {

        /**
            * Constructs a new TxBodyContent.
            * @param [properties] Properties to set
            */
        constructor(properties?: ITxBodyContent);

        /** TxBodyContent data. */
        data: Uint8Array;

        /**
            * Creates a new TxBodyContent instance using the specified properties.
            * @param [properties] Properties to set
            * @returns TxBodyContent instance
            */
        static create(properties?: ITxBodyContent): TxBodyContent;

        /**
            * Encodes the specified TxBodyContent message. Does not implicitly {@link TxBodyContent.verify|verify} messages.
            * @param message TxBodyContent message or plain object to encode
            * @param [writer] Writer to encode to
            * @returns Writer
            */
        static encode(message: ITxBodyContent, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
            * Encodes the specified TxBodyContent message, length delimited. Does not implicitly {@link TxBodyContent.verify|verify} messages.
            * @param message TxBodyContent message or plain object to encode
            * @param [writer] Writer to encode to
            * @returns Writer
            */
        static encodeDelimited(message: ITxBodyContent, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
            * Decodes a TxBodyContent message from the specified reader or buffer.
            * @param reader Reader or buffer to decode from
            * @param [length] Message length if known beforehand
            * @returns TxBodyContent
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */
        static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TxBodyContent;

        /**
            * Decodes a TxBodyContent message from the specified reader or buffer, length delimited.
            * @param reader Reader or buffer to decode from
            * @returns TxBodyContent
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */
        static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): TxBodyContent;

        /**
            * Verifies a TxBodyContent message.
            * @param message Plain object to verify
            * @returns `null` if valid, otherwise the reason why it is not
            */
        static verify(message: { [k: string]: any }): (string|null);

        /**
            * Creates a TxBodyContent message from a plain object. Also converts values to their respective internal types.
            * @param object Plain object
            * @returns TxBodyContent
            */
        static fromObject(object: { [k: string]: any }): TxBodyContent;

        /**
            * Creates a plain object from a TxBodyContent message. Also converts values to other types if specified.
            * @param message TxBodyContent
            * @param [options] Conversion options
            * @returns Plain object
            */
        static toObject(message: TxBodyContent, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
            * Converts this TxBodyContent to JSON.
            * @returns JSON object
            */
        toJSON(): { [k: string]: any };
}

/** Properties of a ProofData. */
export interface IProofData {

        /** ProofData data */
        data?: (Uint8Array|null);
}

/** Represents a ProofData. */
export class ProofData implements IProofData {

        /**
            * Constructs a new ProofData.
            * @param [properties] Properties to set
            */
        constructor(properties?: IProofData);

        /** ProofData data. */
        data: Uint8Array;

        /**
            * Creates a new ProofData instance using the specified properties.
            * @param [properties] Properties to set
            * @returns ProofData instance
            */
        static create(properties?: IProofData): ProofData;

        /**
            * Encodes the specified ProofData message. Does not implicitly {@link ProofData.verify|verify} messages.
            * @param message ProofData message or plain object to encode
            * @param [writer] Writer to encode to
            * @returns Writer
            */
        static encode(message: IProofData, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
            * Encodes the specified ProofData message, length delimited. Does not implicitly {@link ProofData.verify|verify} messages.
            * @param message ProofData message or plain object to encode
            * @param [writer] Writer to encode to
            * @returns Writer
            */
        static encodeDelimited(message: IProofData, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
            * Decodes a ProofData message from the specified reader or buffer.
            * @param reader Reader or buffer to decode from
            * @param [length] Message length if known beforehand
            * @returns ProofData
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */
        static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): ProofData;

        /**
            * Decodes a ProofData message from the specified reader or buffer, length delimited.
            * @param reader Reader or buffer to decode from
            * @returns ProofData
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */
        static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): ProofData;

        /**
            * Verifies a ProofData message.
            * @param message Plain object to verify
            * @returns `null` if valid, otherwise the reason why it is not
            */
        static verify(message: { [k: string]: any }): (string|null);

        /**
            * Creates a ProofData message from a plain object. Also converts values to their respective internal types.
            * @param object Plain object
            * @returns ProofData
            */
        static fromObject(object: { [k: string]: any }): ProofData;

        /**
            * Creates a plain object from a ProofData message. Also converts values to other types if specified.
            * @param message ProofData
            * @param [options] Conversion options
            * @returns Plain object
            */
        static toObject(message: ProofData, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
            * Converts this ProofData to JSON.
            * @returns JSON object
            */
        toJSON(): { [k: string]: any };
}

/** Properties of a ProofOfServiceBodyContent. */
export interface IProofOfServiceBodyContent {

        /** ProofOfServiceBodyContent data */
        data?: (IProofData|null);
}

/** Represents a ProofOfServiceBodyContent. */
export class ProofOfServiceBodyContent implements IProofOfServiceBodyContent {

        /**
            * Constructs a new ProofOfServiceBodyContent.
            * @param [properties] Properties to set
            */
        constructor(properties?: IProofOfServiceBodyContent);

        /** ProofOfServiceBodyContent data. */
        data?: (IProofData|null);

        /**
            * Creates a new ProofOfServiceBodyContent instance using the specified properties.
            * @param [properties] Properties to set
            * @returns ProofOfServiceBodyContent instance
            */
        static create(properties?: IProofOfServiceBodyContent): ProofOfServiceBodyContent;

        /**
            * Encodes the specified ProofOfServiceBodyContent message. Does not implicitly {@link ProofOfServiceBodyContent.verify|verify} messages.
            * @param message ProofOfServiceBodyContent message or plain object to encode
            * @param [writer] Writer to encode to
            * @returns Writer
            */
        static encode(message: IProofOfServiceBodyContent, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
            * Encodes the specified ProofOfServiceBodyContent message, length delimited. Does not implicitly {@link ProofOfServiceBodyContent.verify|verify} messages.
            * @param message ProofOfServiceBodyContent message or plain object to encode
            * @param [writer] Writer to encode to
            * @returns Writer
            */
        static encodeDelimited(message: IProofOfServiceBodyContent, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
            * Decodes a ProofOfServiceBodyContent message from the specified reader or buffer.
            * @param reader Reader or buffer to decode from
            * @param [length] Message length if known beforehand
            * @returns ProofOfServiceBodyContent
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */
        static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): ProofOfServiceBodyContent;

        /**
            * Decodes a ProofOfServiceBodyContent message from the specified reader or buffer, length delimited.
            * @param reader Reader or buffer to decode from
            * @returns ProofOfServiceBodyContent
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */
        static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): ProofOfServiceBodyContent;

        /**
            * Verifies a ProofOfServiceBodyContent message.
            * @param message Plain object to verify
            * @returns `null` if valid, otherwise the reason why it is not
            */
        static verify(message: { [k: string]: any }): (string|null);

        /**
            * Creates a ProofOfServiceBodyContent message from a plain object. Also converts values to their respective internal types.
            * @param object Plain object
            * @returns ProofOfServiceBodyContent
            */
        static fromObject(object: { [k: string]: any }): ProofOfServiceBodyContent;

        /**
            * Creates a plain object from a ProofOfServiceBodyContent message. Also converts values to other types if specified.
            * @param message ProofOfServiceBodyContent
            * @param [options] Conversion options
            * @returns Plain object
            */
        static toObject(message: ProofOfServiceBodyContent, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
            * Converts this ProofOfServiceBodyContent to JSON.
            * @returns JSON object
            */
        toJSON(): { [k: string]: any };
}

/** Properties of a StorageDescContent. */
export interface IStorageDescContent {

        /** StorageDescContent id */
        id?: (string|null);
}

/** Represents a StorageDescContent. */
export class StorageDescContent implements IStorageDescContent {

        /**
            * Constructs a new StorageDescContent.
            * @param [properties] Properties to set
            */
        constructor(properties?: IStorageDescContent);

        /** StorageDescContent id. */
        id: string;

        /**
            * Creates a new StorageDescContent instance using the specified properties.
            * @param [properties] Properties to set
            * @returns StorageDescContent instance
            */
        static create(properties?: IStorageDescContent): StorageDescContent;

        /**
            * Encodes the specified StorageDescContent message. Does not implicitly {@link StorageDescContent.verify|verify} messages.
            * @param message StorageDescContent message or plain object to encode
            * @param [writer] Writer to encode to
            * @returns Writer
            */
        static encode(message: IStorageDescContent, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
            * Encodes the specified StorageDescContent message, length delimited. Does not implicitly {@link StorageDescContent.verify|verify} messages.
            * @param message StorageDescContent message or plain object to encode
            * @param [writer] Writer to encode to
            * @returns Writer
            */
        static encodeDelimited(message: IStorageDescContent, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
            * Decodes a StorageDescContent message from the specified reader or buffer.
            * @param reader Reader or buffer to decode from
            * @param [length] Message length if known beforehand
            * @returns StorageDescContent
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */
        static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): StorageDescContent;

        /**
            * Decodes a StorageDescContent message from the specified reader or buffer, length delimited.
            * @param reader Reader or buffer to decode from
            * @returns StorageDescContent
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */
        static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): StorageDescContent;

        /**
            * Verifies a StorageDescContent message.
            * @param message Plain object to verify
            * @returns `null` if valid, otherwise the reason why it is not
            */
        static verify(message: { [k: string]: any }): (string|null);

        /**
            * Creates a StorageDescContent message from a plain object. Also converts values to their respective internal types.
            * @param object Plain object
            * @returns StorageDescContent
            */
        static fromObject(object: { [k: string]: any }): StorageDescContent;

        /**
            * Creates a plain object from a StorageDescContent message. Also converts values to other types if specified.
            * @param message StorageDescContent
            * @param [options] Conversion options
            * @returns Plain object
            */
        static toObject(message: StorageDescContent, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
            * Converts this StorageDescContent to JSON.
            * @returns JSON object
            */
        toJSON(): { [k: string]: any };
}

/** Properties of a StorageBodyContent. */
export interface IStorageBodyContent {

        /** StorageBodyContent value */
        value?: (Uint8Array|null);
}

/** Represents a StorageBodyContent. */
export class StorageBodyContent implements IStorageBodyContent {

        /**
            * Constructs a new StorageBodyContent.
            * @param [properties] Properties to set
            */
        constructor(properties?: IStorageBodyContent);

        /** StorageBodyContent value. */
        value: Uint8Array;

        /**
            * Creates a new StorageBodyContent instance using the specified properties.
            * @param [properties] Properties to set
            * @returns StorageBodyContent instance
            */
        static create(properties?: IStorageBodyContent): StorageBodyContent;

        /**
            * Encodes the specified StorageBodyContent message. Does not implicitly {@link StorageBodyContent.verify|verify} messages.
            * @param message StorageBodyContent message or plain object to encode
            * @param [writer] Writer to encode to
            * @returns Writer
            */
        static encode(message: IStorageBodyContent, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
            * Encodes the specified StorageBodyContent message, length delimited. Does not implicitly {@link StorageBodyContent.verify|verify} messages.
            * @param message StorageBodyContent message or plain object to encode
            * @param [writer] Writer to encode to
            * @returns Writer
            */
        static encodeDelimited(message: IStorageBodyContent, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
            * Decodes a StorageBodyContent message from the specified reader or buffer.
            * @param reader Reader or buffer to decode from
            * @param [length] Message length if known beforehand
            * @returns StorageBodyContent
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */
        static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): StorageBodyContent;

        /**
            * Decodes a StorageBodyContent message from the specified reader or buffer, length delimited.
            * @param reader Reader or buffer to decode from
            * @returns StorageBodyContent
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */
        static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): StorageBodyContent;

        /**
            * Verifies a StorageBodyContent message.
            * @param message Plain object to verify
            * @returns `null` if valid, otherwise the reason why it is not
            */
        static verify(message: { [k: string]: any }): (string|null);

        /**
            * Creates a StorageBodyContent message from a plain object. Also converts values to their respective internal types.
            * @param object Plain object
            * @returns StorageBodyContent
            */
        static fromObject(object: { [k: string]: any }): StorageBodyContent;

        /**
            * Creates a plain object from a StorageBodyContent message. Also converts values to other types if specified.
            * @param message StorageBodyContent
            * @param [options] Conversion options
            * @returns Plain object
            */
        static toObject(message: StorageBodyContent, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
            * Converts this StorageBodyContent to JSON.
            * @returns JSON object
            */
        toJSON(): { [k: string]: any };
}

/** Properties of a TextDescContent. */
export interface ITextDescContent {

        /** TextDescContent id */
        id?: (string|null);

        /** TextDescContent header */
        header?: (string|null);
}

/** Represents a TextDescContent. */
export class TextDescContent implements ITextDescContent {

        /**
            * Constructs a new TextDescContent.
            * @param [properties] Properties to set
            */
        constructor(properties?: ITextDescContent);

        /** TextDescContent id. */
        id: string;

        /** TextDescContent header. */
        header: string;

        /**
            * Creates a new TextDescContent instance using the specified properties.
            * @param [properties] Properties to set
            * @returns TextDescContent instance
            */
        static create(properties?: ITextDescContent): TextDescContent;

        /**
            * Encodes the specified TextDescContent message. Does not implicitly {@link TextDescContent.verify|verify} messages.
            * @param message TextDescContent message or plain object to encode
            * @param [writer] Writer to encode to
            * @returns Writer
            */
        static encode(message: ITextDescContent, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
            * Encodes the specified TextDescContent message, length delimited. Does not implicitly {@link TextDescContent.verify|verify} messages.
            * @param message TextDescContent message or plain object to encode
            * @param [writer] Writer to encode to
            * @returns Writer
            */
        static encodeDelimited(message: ITextDescContent, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
            * Decodes a TextDescContent message from the specified reader or buffer.
            * @param reader Reader or buffer to decode from
            * @param [length] Message length if known beforehand
            * @returns TextDescContent
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */
        static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TextDescContent;

        /**
            * Decodes a TextDescContent message from the specified reader or buffer, length delimited.
            * @param reader Reader or buffer to decode from
            * @returns TextDescContent
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */
        static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): TextDescContent;

        /**
            * Verifies a TextDescContent message.
            * @param message Plain object to verify
            * @returns `null` if valid, otherwise the reason why it is not
            */
        static verify(message: { [k: string]: any }): (string|null);

        /**
            * Creates a TextDescContent message from a plain object. Also converts values to their respective internal types.
            * @param object Plain object
            * @returns TextDescContent
            */
        static fromObject(object: { [k: string]: any }): TextDescContent;

        /**
            * Creates a plain object from a TextDescContent message. Also converts values to other types if specified.
            * @param message TextDescContent
            * @param [options] Conversion options
            * @returns Plain object
            */
        static toObject(message: TextDescContent, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
            * Converts this TextDescContent to JSON.
            * @returns JSON object
            */
        toJSON(): { [k: string]: any };
}

/** Properties of a TextContent. */
export interface ITextContent {

        /** TextContent value */
        value?: (string|null);
}

/** Represents a TextContent. */
export class TextContent implements ITextContent {

        /**
            * Constructs a new TextContent.
            * @param [properties] Properties to set
            */
        constructor(properties?: ITextContent);

        /** TextContent value. */
        value: string;

        /**
            * Creates a new TextContent instance using the specified properties.
            * @param [properties] Properties to set
            * @returns TextContent instance
            */
        static create(properties?: ITextContent): TextContent;

        /**
            * Encodes the specified TextContent message. Does not implicitly {@link TextContent.verify|verify} messages.
            * @param message TextContent message or plain object to encode
            * @param [writer] Writer to encode to
            * @returns Writer
            */
        static encode(message: ITextContent, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
            * Encodes the specified TextContent message, length delimited. Does not implicitly {@link TextContent.verify|verify} messages.
            * @param message TextContent message or plain object to encode
            * @param [writer] Writer to encode to
            * @returns Writer
            */
        static encodeDelimited(message: ITextContent, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
            * Decodes a TextContent message from the specified reader or buffer.
            * @param reader Reader or buffer to decode from
            * @param [length] Message length if known beforehand
            * @returns TextContent
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */
        static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TextContent;

        /**
            * Decodes a TextContent message from the specified reader or buffer, length delimited.
            * @param reader Reader or buffer to decode from
            * @returns TextContent
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */
        static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): TextContent;

        /**
            * Verifies a TextContent message.
            * @param message Plain object to verify
            * @returns `null` if valid, otherwise the reason why it is not
            */
        static verify(message: { [k: string]: any }): (string|null);

        /**
            * Creates a TextContent message from a plain object. Also converts values to their respective internal types.
            * @param object Plain object
            * @returns TextContent
            */
        static fromObject(object: { [k: string]: any }): TextContent;

        /**
            * Creates a plain object from a TextContent message. Also converts values to other types if specified.
            * @param message TextContent
            * @param [options] Conversion options
            * @returns Plain object
            */
        static toObject(message: TextContent, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
            * Converts this TextContent to JSON.
            * @returns JSON object
            */
        toJSON(): { [k: string]: any };
}

/** Properties of a ZoneDescContent. */
export interface IZoneDescContent {

        /** ZoneDescContent owner */
        owner?: (Uint8Array|null);
}

/** Represents a ZoneDescContent. */
export class ZoneDescContent implements IZoneDescContent {

        /**
            * Constructs a new ZoneDescContent.
            * @param [properties] Properties to set
            */
        constructor(properties?: IZoneDescContent);

        /** ZoneDescContent owner. */
        owner: Uint8Array;

        /**
            * Creates a new ZoneDescContent instance using the specified properties.
            * @param [properties] Properties to set
            * @returns ZoneDescContent instance
            */
        static create(properties?: IZoneDescContent): ZoneDescContent;

        /**
            * Encodes the specified ZoneDescContent message. Does not implicitly {@link ZoneDescContent.verify|verify} messages.
            * @param message ZoneDescContent message or plain object to encode
            * @param [writer] Writer to encode to
            * @returns Writer
            */
        static encode(message: IZoneDescContent, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
            * Encodes the specified ZoneDescContent message, length delimited. Does not implicitly {@link ZoneDescContent.verify|verify} messages.
            * @param message ZoneDescContent message or plain object to encode
            * @param [writer] Writer to encode to
            * @returns Writer
            */
        static encodeDelimited(message: IZoneDescContent, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
            * Decodes a ZoneDescContent message from the specified reader or buffer.
            * @param reader Reader or buffer to decode from
            * @param [length] Message length if known beforehand
            * @returns ZoneDescContent
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */
        static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): ZoneDescContent;

        /**
            * Decodes a ZoneDescContent message from the specified reader or buffer, length delimited.
            * @param reader Reader or buffer to decode from
            * @returns ZoneDescContent
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */
        static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): ZoneDescContent;

        /**
            * Verifies a ZoneDescContent message.
            * @param message Plain object to verify
            * @returns `null` if valid, otherwise the reason why it is not
            */
        static verify(message: { [k: string]: any }): (string|null);

        /**
            * Creates a ZoneDescContent message from a plain object. Also converts values to their respective internal types.
            * @param object Plain object
            * @returns ZoneDescContent
            */
        static fromObject(object: { [k: string]: any }): ZoneDescContent;

        /**
            * Creates a plain object from a ZoneDescContent message. Also converts values to other types if specified.
            * @param message ZoneDescContent
            * @param [options] Conversion options
            * @returns Plain object
            */
        static toObject(message: ZoneDescContent, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
            * Converts this ZoneDescContent to JSON.
            * @returns JSON object
            */
        toJSON(): { [k: string]: any };
}

/** Properties of a ZoneBodyContent. */
export interface IZoneBodyContent {

        /** ZoneBodyContent ood_list */
        ood_list?: (Uint8Array[]|null);

        /** ZoneBodyContent known_device_list */
        known_device_list?: (Uint8Array[]|null);
}

/** Represents a ZoneBodyContent. */
export class ZoneBodyContent implements IZoneBodyContent {

        /**
            * Constructs a new ZoneBodyContent.
            * @param [properties] Properties to set
            */
        constructor(properties?: IZoneBodyContent);

        /** ZoneBodyContent ood_list. */
        ood_list: Uint8Array[];

        /** ZoneBodyContent known_device_list. */
        known_device_list: Uint8Array[];

        /**
            * Creates a new ZoneBodyContent instance using the specified properties.
            * @param [properties] Properties to set
            * @returns ZoneBodyContent instance
            */
        static create(properties?: IZoneBodyContent): ZoneBodyContent;

        /**
            * Encodes the specified ZoneBodyContent message. Does not implicitly {@link ZoneBodyContent.verify|verify} messages.
            * @param message ZoneBodyContent message or plain object to encode
            * @param [writer] Writer to encode to
            * @returns Writer
            */
        static encode(message: IZoneBodyContent, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
            * Encodes the specified ZoneBodyContent message, length delimited. Does not implicitly {@link ZoneBodyContent.verify|verify} messages.
            * @param message ZoneBodyContent message or plain object to encode
            * @param [writer] Writer to encode to
            * @returns Writer
            */
        static encodeDelimited(message: IZoneBodyContent, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
            * Decodes a ZoneBodyContent message from the specified reader or buffer.
            * @param reader Reader or buffer to decode from
            * @param [length] Message length if known beforehand
            * @returns ZoneBodyContent
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */
        static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): ZoneBodyContent;

        /**
            * Decodes a ZoneBodyContent message from the specified reader or buffer, length delimited.
            * @param reader Reader or buffer to decode from
            * @returns ZoneBodyContent
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */
        static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): ZoneBodyContent;

        /**
            * Verifies a ZoneBodyContent message.
            * @param message Plain object to verify
            * @returns `null` if valid, otherwise the reason why it is not
            */
        static verify(message: { [k: string]: any }): (string|null);

        /**
            * Creates a ZoneBodyContent message from a plain object. Also converts values to their respective internal types.
            * @param object Plain object
            * @returns ZoneBodyContent
            */
        static fromObject(object: { [k: string]: any }): ZoneBodyContent;

        /**
            * Creates a plain object from a ZoneBodyContent message. Also converts values to other types if specified.
            * @param message ZoneBodyContent
            * @param [options] Conversion options
            * @returns Plain object
            */
        static toObject(message: ZoneBodyContent, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
            * Converts this ZoneBodyContent to JSON.
            * @returns JSON object
            */
        toJSON(): { [k: string]: any };
}

/** Properties of an AppExtInfoDescContent. */
export interface IAppExtInfoDescContent {

        /** AppExtInfoDescContent id */
        id?: (string|null);
}

/** Represents an AppExtInfoDescContent. */
export class AppExtInfoDescContent implements IAppExtInfoDescContent {

        /**
            * Constructs a new AppExtInfoDescContent.
            * @param [properties] Properties to set
            */
        constructor(properties?: IAppExtInfoDescContent);

        /** AppExtInfoDescContent id. */
        id: string;

        /**
            * Creates a new AppExtInfoDescContent instance using the specified properties.
            * @param [properties] Properties to set
            * @returns AppExtInfoDescContent instance
            */
        static create(properties?: IAppExtInfoDescContent): AppExtInfoDescContent;

        /**
            * Encodes the specified AppExtInfoDescContent message. Does not implicitly {@link AppExtInfoDescContent.verify|verify} messages.
            * @param message AppExtInfoDescContent message or plain object to encode
            * @param [writer] Writer to encode to
            * @returns Writer
            */
        static encode(message: IAppExtInfoDescContent, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
            * Encodes the specified AppExtInfoDescContent message, length delimited. Does not implicitly {@link AppExtInfoDescContent.verify|verify} messages.
            * @param message AppExtInfoDescContent message or plain object to encode
            * @param [writer] Writer to encode to
            * @returns Writer
            */
        static encodeDelimited(message: IAppExtInfoDescContent, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
            * Decodes an AppExtInfoDescContent message from the specified reader or buffer.
            * @param reader Reader or buffer to decode from
            * @param [length] Message length if known beforehand
            * @returns AppExtInfoDescContent
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */
        static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): AppExtInfoDescContent;

        /**
            * Decodes an AppExtInfoDescContent message from the specified reader or buffer, length delimited.
            * @param reader Reader or buffer to decode from
            * @returns AppExtInfoDescContent
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */
        static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): AppExtInfoDescContent;

        /**
            * Verifies an AppExtInfoDescContent message.
            * @param message Plain object to verify
            * @returns `null` if valid, otherwise the reason why it is not
            */
        static verify(message: { [k: string]: any }): (string|null);

        /**
            * Creates an AppExtInfoDescContent message from a plain object. Also converts values to their respective internal types.
            * @param object Plain object
            * @returns AppExtInfoDescContent
            */
        static fromObject(object: { [k: string]: any }): AppExtInfoDescContent;

        /**
            * Creates a plain object from an AppExtInfoDescContent message. Also converts values to other types if specified.
            * @param message AppExtInfoDescContent
            * @param [options] Conversion options
            * @returns Plain object
            */
        static toObject(message: AppExtInfoDescContent, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
            * Converts this AppExtInfoDescContent to JSON.
            * @returns JSON object
            */
        toJSON(): { [k: string]: any };
}

/** Properties of an AppExtInfoBodyContent. */
export interface IAppExtInfoBodyContent {

        /** AppExtInfoBodyContent info */
        info?: (string|null);
}

/** Represents an AppExtInfoBodyContent. */
export class AppExtInfoBodyContent implements IAppExtInfoBodyContent {

        /**
            * Constructs a new AppExtInfoBodyContent.
            * @param [properties] Properties to set
            */
        constructor(properties?: IAppExtInfoBodyContent);

        /** AppExtInfoBodyContent info. */
        info: string;

        /**
            * Creates a new AppExtInfoBodyContent instance using the specified properties.
            * @param [properties] Properties to set
            * @returns AppExtInfoBodyContent instance
            */
        static create(properties?: IAppExtInfoBodyContent): AppExtInfoBodyContent;

        /**
            * Encodes the specified AppExtInfoBodyContent message. Does not implicitly {@link AppExtInfoBodyContent.verify|verify} messages.
            * @param message AppExtInfoBodyContent message or plain object to encode
            * @param [writer] Writer to encode to
            * @returns Writer
            */
        static encode(message: IAppExtInfoBodyContent, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
            * Encodes the specified AppExtInfoBodyContent message, length delimited. Does not implicitly {@link AppExtInfoBodyContent.verify|verify} messages.
            * @param message AppExtInfoBodyContent message or plain object to encode
            * @param [writer] Writer to encode to
            * @returns Writer
            */
        static encodeDelimited(message: IAppExtInfoBodyContent, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
            * Decodes an AppExtInfoBodyContent message from the specified reader or buffer.
            * @param reader Reader or buffer to decode from
            * @param [length] Message length if known beforehand
            * @returns AppExtInfoBodyContent
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */
        static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): AppExtInfoBodyContent;

        /**
            * Decodes an AppExtInfoBodyContent message from the specified reader or buffer, length delimited.
            * @param reader Reader or buffer to decode from
            * @returns AppExtInfoBodyContent
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */
        static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): AppExtInfoBodyContent;

        /**
            * Verifies an AppExtInfoBodyContent message.
            * @param message Plain object to verify
            * @returns `null` if valid, otherwise the reason why it is not
            */
        static verify(message: { [k: string]: any }): (string|null);

        /**
            * Creates an AppExtInfoBodyContent message from a plain object. Also converts values to their respective internal types.
            * @param object Plain object
            * @returns AppExtInfoBodyContent
            */
        static fromObject(object: { [k: string]: any }): AppExtInfoBodyContent;

        /**
            * Creates a plain object from an AppExtInfoBodyContent message. Also converts values to other types if specified.
            * @param message AppExtInfoBodyContent
            * @param [options] Conversion options
            * @returns Plain object
            */
        static toObject(message: AppExtInfoBodyContent, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
            * Converts this AppExtInfoBodyContent to JSON.
            * @returns JSON object
            */
        toJSON(): { [k: string]: any };
}

/** Properties of an AppLocalStatusDesc. */
export interface IAppLocalStatusDesc {

        /** AppLocalStatusDesc id */
        id?: (Uint8Array|null);
}

/** Represents an AppLocalStatusDesc. */
export class AppLocalStatusDesc implements IAppLocalStatusDesc {

        /**
            * Constructs a new AppLocalStatusDesc.
            * @param [properties] Properties to set
            */
        constructor(properties?: IAppLocalStatusDesc);

        /** AppLocalStatusDesc id. */
        id: Uint8Array;

        /**
            * Creates a new AppLocalStatusDesc instance using the specified properties.
            * @param [properties] Properties to set
            * @returns AppLocalStatusDesc instance
            */
        static create(properties?: IAppLocalStatusDesc): AppLocalStatusDesc;

        /**
            * Encodes the specified AppLocalStatusDesc message. Does not implicitly {@link AppLocalStatusDesc.verify|verify} messages.
            * @param message AppLocalStatusDesc message or plain object to encode
            * @param [writer] Writer to encode to
            * @returns Writer
            */
        static encode(message: IAppLocalStatusDesc, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
            * Encodes the specified AppLocalStatusDesc message, length delimited. Does not implicitly {@link AppLocalStatusDesc.verify|verify} messages.
            * @param message AppLocalStatusDesc message or plain object to encode
            * @param [writer] Writer to encode to
            * @returns Writer
            */
        static encodeDelimited(message: IAppLocalStatusDesc, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
            * Decodes an AppLocalStatusDesc message from the specified reader or buffer.
            * @param reader Reader or buffer to decode from
            * @param [length] Message length if known beforehand
            * @returns AppLocalStatusDesc
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */
        static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): AppLocalStatusDesc;

        /**
            * Decodes an AppLocalStatusDesc message from the specified reader or buffer, length delimited.
            * @param reader Reader or buffer to decode from
            * @returns AppLocalStatusDesc
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */
        static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): AppLocalStatusDesc;

        /**
            * Verifies an AppLocalStatusDesc message.
            * @param message Plain object to verify
            * @returns `null` if valid, otherwise the reason why it is not
            */
        static verify(message: { [k: string]: any }): (string|null);

        /**
            * Creates an AppLocalStatusDesc message from a plain object. Also converts values to their respective internal types.
            * @param object Plain object
            * @returns AppLocalStatusDesc
            */
        static fromObject(object: { [k: string]: any }): AppLocalStatusDesc;

        /**
            * Creates a plain object from an AppLocalStatusDesc message. Also converts values to other types if specified.
            * @param message AppLocalStatusDesc
            * @param [options] Conversion options
            * @returns Plain object
            */
        static toObject(message: AppLocalStatusDesc, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
            * Converts this AppLocalStatusDesc to JSON.
            * @returns JSON object
            */
        toJSON(): { [k: string]: any };
}

/** Properties of an AppLocalStatusBody. */
export interface IAppLocalStatusBody {

        /** AppLocalStatusBody status */
        status?: (number|null);

        /** AppLocalStatusBody web_dir */
        web_dir?: (Uint8Array|null);
}

/** Represents an AppLocalStatusBody. */
export class AppLocalStatusBody implements IAppLocalStatusBody {

        /**
            * Constructs a new AppLocalStatusBody.
            * @param [properties] Properties to set
            */
        constructor(properties?: IAppLocalStatusBody);

        /** AppLocalStatusBody status. */
        status: number;

        /** AppLocalStatusBody web_dir. */
        web_dir?: (Uint8Array|null);

        /** AppLocalStatusBody _web_dir. */
        _web_dir?: "web_dir";

        /**
            * Creates a new AppLocalStatusBody instance using the specified properties.
            * @param [properties] Properties to set
            * @returns AppLocalStatusBody instance
            */
        static create(properties?: IAppLocalStatusBody): AppLocalStatusBody;

        /**
            * Encodes the specified AppLocalStatusBody message. Does not implicitly {@link AppLocalStatusBody.verify|verify} messages.
            * @param message AppLocalStatusBody message or plain object to encode
            * @param [writer] Writer to encode to
            * @returns Writer
            */
        static encode(message: IAppLocalStatusBody, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
            * Encodes the specified AppLocalStatusBody message, length delimited. Does not implicitly {@link AppLocalStatusBody.verify|verify} messages.
            * @param message AppLocalStatusBody message or plain object to encode
            * @param [writer] Writer to encode to
            * @returns Writer
            */
        static encodeDelimited(message: IAppLocalStatusBody, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
            * Decodes an AppLocalStatusBody message from the specified reader or buffer.
            * @param reader Reader or buffer to decode from
            * @param [length] Message length if known beforehand
            * @returns AppLocalStatusBody
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */
        static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): AppLocalStatusBody;

        /**
            * Decodes an AppLocalStatusBody message from the specified reader or buffer, length delimited.
            * @param reader Reader or buffer to decode from
            * @returns AppLocalStatusBody
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */
        static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): AppLocalStatusBody;

        /**
            * Verifies an AppLocalStatusBody message.
            * @param message Plain object to verify
            * @returns `null` if valid, otherwise the reason why it is not
            */
        static verify(message: { [k: string]: any }): (string|null);

        /**
            * Creates an AppLocalStatusBody message from a plain object. Also converts values to their respective internal types.
            * @param object Plain object
            * @returns AppLocalStatusBody
            */
        static fromObject(object: { [k: string]: any }): AppLocalStatusBody;

        /**
            * Creates a plain object from an AppLocalStatusBody message. Also converts values to other types if specified.
            * @param message AppLocalStatusBody
            * @param [options] Conversion options
            * @returns Plain object
            */
        static toObject(message: AppLocalStatusBody, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
            * Converts this AppLocalStatusBody to JSON.
            * @returns JSON object
            */
        toJSON(): { [k: string]: any };
}

/** Properties of an AppStatusDescContent. */
export interface IAppStatusDescContent {

        /** AppStatusDescContent id */
        id?: (Uint8Array|null);
}

/** Represents an AppStatusDescContent. */
export class AppStatusDescContent implements IAppStatusDescContent {

        /**
            * Constructs a new AppStatusDescContent.
            * @param [properties] Properties to set
            */
        constructor(properties?: IAppStatusDescContent);

        /** AppStatusDescContent id. */
        id: Uint8Array;

        /**
            * Creates a new AppStatusDescContent instance using the specified properties.
            * @param [properties] Properties to set
            * @returns AppStatusDescContent instance
            */
        static create(properties?: IAppStatusDescContent): AppStatusDescContent;

        /**
            * Encodes the specified AppStatusDescContent message. Does not implicitly {@link AppStatusDescContent.verify|verify} messages.
            * @param message AppStatusDescContent message or plain object to encode
            * @param [writer] Writer to encode to
            * @returns Writer
            */
        static encode(message: IAppStatusDescContent, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
            * Encodes the specified AppStatusDescContent message, length delimited. Does not implicitly {@link AppStatusDescContent.verify|verify} messages.
            * @param message AppStatusDescContent message or plain object to encode
            * @param [writer] Writer to encode to
            * @returns Writer
            */
        static encodeDelimited(message: IAppStatusDescContent, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
            * Decodes an AppStatusDescContent message from the specified reader or buffer.
            * @param reader Reader or buffer to decode from
            * @param [length] Message length if known beforehand
            * @returns AppStatusDescContent
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */
        static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): AppStatusDescContent;

        /**
            * Decodes an AppStatusDescContent message from the specified reader or buffer, length delimited.
            * @param reader Reader or buffer to decode from
            * @returns AppStatusDescContent
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */
        static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): AppStatusDescContent;

        /**
            * Verifies an AppStatusDescContent message.
            * @param message Plain object to verify
            * @returns `null` if valid, otherwise the reason why it is not
            */
        static verify(message: { [k: string]: any }): (string|null);

        /**
            * Creates an AppStatusDescContent message from a plain object. Also converts values to their respective internal types.
            * @param object Plain object
            * @returns AppStatusDescContent
            */
        static fromObject(object: { [k: string]: any }): AppStatusDescContent;

        /**
            * Creates a plain object from an AppStatusDescContent message. Also converts values to other types if specified.
            * @param message AppStatusDescContent
            * @param [options] Conversion options
            * @returns Plain object
            */
        static toObject(message: AppStatusDescContent, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
            * Converts this AppStatusDescContent to JSON.
            * @returns JSON object
            */
        toJSON(): { [k: string]: any };
}

/** Properties of an AppStatusContent. */
export interface IAppStatusContent {

        /** AppStatusContent version */
        version?: (string|null);

        /** AppStatusContent status */
        status?: (number|null);
}

/** Represents an AppStatusContent. */
export class AppStatusContent implements IAppStatusContent {

        /**
            * Constructs a new AppStatusContent.
            * @param [properties] Properties to set
            */
        constructor(properties?: IAppStatusContent);

        /** AppStatusContent version. */
        version: string;

        /** AppStatusContent status. */
        status: number;

        /**
            * Creates a new AppStatusContent instance using the specified properties.
            * @param [properties] Properties to set
            * @returns AppStatusContent instance
            */
        static create(properties?: IAppStatusContent): AppStatusContent;

        /**
            * Encodes the specified AppStatusContent message. Does not implicitly {@link AppStatusContent.verify|verify} messages.
            * @param message AppStatusContent message or plain object to encode
            * @param [writer] Writer to encode to
            * @returns Writer
            */
        static encode(message: IAppStatusContent, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
            * Encodes the specified AppStatusContent message, length delimited. Does not implicitly {@link AppStatusContent.verify|verify} messages.
            * @param message AppStatusContent message or plain object to encode
            * @param [writer] Writer to encode to
            * @returns Writer
            */
        static encodeDelimited(message: IAppStatusContent, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
            * Decodes an AppStatusContent message from the specified reader or buffer.
            * @param reader Reader or buffer to decode from
            * @param [length] Message length if known beforehand
            * @returns AppStatusContent
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */
        static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): AppStatusContent;

        /**
            * Decodes an AppStatusContent message from the specified reader or buffer, length delimited.
            * @param reader Reader or buffer to decode from
            * @returns AppStatusContent
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */
        static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): AppStatusContent;

        /**
            * Verifies an AppStatusContent message.
            * @param message Plain object to verify
            * @returns `null` if valid, otherwise the reason why it is not
            */
        static verify(message: { [k: string]: any }): (string|null);

        /**
            * Creates an AppStatusContent message from a plain object. Also converts values to their respective internal types.
            * @param object Plain object
            * @returns AppStatusContent
            */
        static fromObject(object: { [k: string]: any }): AppStatusContent;

        /**
            * Creates a plain object from an AppStatusContent message. Also converts values to other types if specified.
            * @param message AppStatusContent
            * @param [options] Conversion options
            * @returns Plain object
            */
        static toObject(message: AppStatusContent, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
            * Converts this AppStatusContent to JSON.
            * @returns JSON object
            */
        toJSON(): { [k: string]: any };
}

/** Properties of an AppStoreListBodyContent. */
export interface IAppStoreListBodyContent {

        /** AppStoreListBodyContent app_store_list */
        app_store_list?: (Uint8Array[]|null);
}

/** Represents an AppStoreListBodyContent. */
export class AppStoreListBodyContent implements IAppStoreListBodyContent {

        /**
            * Constructs a new AppStoreListBodyContent.
            * @param [properties] Properties to set
            */
        constructor(properties?: IAppStoreListBodyContent);

        /** AppStoreListBodyContent app_store_list. */
        app_store_list: Uint8Array[];

        /**
            * Creates a new AppStoreListBodyContent instance using the specified properties.
            * @param [properties] Properties to set
            * @returns AppStoreListBodyContent instance
            */
        static create(properties?: IAppStoreListBodyContent): AppStoreListBodyContent;

        /**
            * Encodes the specified AppStoreListBodyContent message. Does not implicitly {@link AppStoreListBodyContent.verify|verify} messages.
            * @param message AppStoreListBodyContent message or plain object to encode
            * @param [writer] Writer to encode to
            * @returns Writer
            */
        static encode(message: IAppStoreListBodyContent, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
            * Encodes the specified AppStoreListBodyContent message, length delimited. Does not implicitly {@link AppStoreListBodyContent.verify|verify} messages.
            * @param message AppStoreListBodyContent message or plain object to encode
            * @param [writer] Writer to encode to
            * @returns Writer
            */
        static encodeDelimited(message: IAppStoreListBodyContent, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
            * Decodes an AppStoreListBodyContent message from the specified reader or buffer.
            * @param reader Reader or buffer to decode from
            * @param [length] Message length if known beforehand
            * @returns AppStoreListBodyContent
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */
        static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): AppStoreListBodyContent;

        /**
            * Decodes an AppStoreListBodyContent message from the specified reader or buffer, length delimited.
            * @param reader Reader or buffer to decode from
            * @returns AppStoreListBodyContent
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */
        static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): AppStoreListBodyContent;

        /**
            * Verifies an AppStoreListBodyContent message.
            * @param message Plain object to verify
            * @returns `null` if valid, otherwise the reason why it is not
            */
        static verify(message: { [k: string]: any }): (string|null);

        /**
            * Creates an AppStoreListBodyContent message from a plain object. Also converts values to their respective internal types.
            * @param object Plain object
            * @returns AppStoreListBodyContent
            */
        static fromObject(object: { [k: string]: any }): AppStoreListBodyContent;

        /**
            * Creates a plain object from an AppStoreListBodyContent message. Also converts values to other types if specified.
            * @param message AppStoreListBodyContent
            * @param [options] Conversion options
            * @returns Plain object
            */
        static toObject(message: AppStoreListBodyContent, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
            * Converts this AppStoreListBodyContent to JSON.
            * @returns JSON object
            */
        toJSON(): { [k: string]: any };
}

/** Properties of an AppListDescContent. */
export interface IAppListDescContent {

        /** AppListDescContent id */
        id?: (string|null);

        /** AppListDescContent category */
        category?: (string|null);
}

/** Represents an AppListDescContent. */
export class AppListDescContent implements IAppListDescContent {

        /**
            * Constructs a new AppListDescContent.
            * @param [properties] Properties to set
            */
        constructor(properties?: IAppListDescContent);

        /** AppListDescContent id. */
        id: string;

        /** AppListDescContent category. */
        category: string;

        /**
            * Creates a new AppListDescContent instance using the specified properties.
            * @param [properties] Properties to set
            * @returns AppListDescContent instance
            */
        static create(properties?: IAppListDescContent): AppListDescContent;

        /**
            * Encodes the specified AppListDescContent message. Does not implicitly {@link AppListDescContent.verify|verify} messages.
            * @param message AppListDescContent message or plain object to encode
            * @param [writer] Writer to encode to
            * @returns Writer
            */
        static encode(message: IAppListDescContent, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
            * Encodes the specified AppListDescContent message, length delimited. Does not implicitly {@link AppListDescContent.verify|verify} messages.
            * @param message AppListDescContent message or plain object to encode
            * @param [writer] Writer to encode to
            * @returns Writer
            */
        static encodeDelimited(message: IAppListDescContent, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
            * Decodes an AppListDescContent message from the specified reader or buffer.
            * @param reader Reader or buffer to decode from
            * @param [length] Message length if known beforehand
            * @returns AppListDescContent
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */
        static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): AppListDescContent;

        /**
            * Decodes an AppListDescContent message from the specified reader or buffer, length delimited.
            * @param reader Reader or buffer to decode from
            * @returns AppListDescContent
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */
        static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): AppListDescContent;

        /**
            * Verifies an AppListDescContent message.
            * @param message Plain object to verify
            * @returns `null` if valid, otherwise the reason why it is not
            */
        static verify(message: { [k: string]: any }): (string|null);

        /**
            * Creates an AppListDescContent message from a plain object. Also converts values to their respective internal types.
            * @param object Plain object
            * @returns AppListDescContent
            */
        static fromObject(object: { [k: string]: any }): AppListDescContent;

        /**
            * Creates a plain object from an AppListDescContent message. Also converts values to other types if specified.
            * @param message AppListDescContent
            * @param [options] Conversion options
            * @returns Plain object
            */
        static toObject(message: AppListDescContent, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
            * Converts this AppListDescContent to JSON.
            * @returns JSON object
            */
        toJSON(): { [k: string]: any };
}

/** Properties of an AppListSourceItem. */
export interface IAppListSourceItem {

        /** AppListSourceItem app_id */
        app_id?: (Uint8Array|null);

        /** AppListSourceItem app_status */
        app_status?: (Uint8Array|null);
}

/** Represents an AppListSourceItem. */
export class AppListSourceItem implements IAppListSourceItem {

        /**
            * Constructs a new AppListSourceItem.
            * @param [properties] Properties to set
            */
        constructor(properties?: IAppListSourceItem);

        /** AppListSourceItem app_id. */
        app_id: Uint8Array;

        /** AppListSourceItem app_status. */
        app_status: Uint8Array;

        /**
            * Creates a new AppListSourceItem instance using the specified properties.
            * @param [properties] Properties to set
            * @returns AppListSourceItem instance
            */
        static create(properties?: IAppListSourceItem): AppListSourceItem;

        /**
            * Encodes the specified AppListSourceItem message. Does not implicitly {@link AppListSourceItem.verify|verify} messages.
            * @param message AppListSourceItem message or plain object to encode
            * @param [writer] Writer to encode to
            * @returns Writer
            */
        static encode(message: IAppListSourceItem, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
            * Encodes the specified AppListSourceItem message, length delimited. Does not implicitly {@link AppListSourceItem.verify|verify} messages.
            * @param message AppListSourceItem message or plain object to encode
            * @param [writer] Writer to encode to
            * @returns Writer
            */
        static encodeDelimited(message: IAppListSourceItem, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
            * Decodes an AppListSourceItem message from the specified reader or buffer.
            * @param reader Reader or buffer to decode from
            * @param [length] Message length if known beforehand
            * @returns AppListSourceItem
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */
        static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): AppListSourceItem;

        /**
            * Decodes an AppListSourceItem message from the specified reader or buffer, length delimited.
            * @param reader Reader or buffer to decode from
            * @returns AppListSourceItem
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */
        static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): AppListSourceItem;

        /**
            * Verifies an AppListSourceItem message.
            * @param message Plain object to verify
            * @returns `null` if valid, otherwise the reason why it is not
            */
        static verify(message: { [k: string]: any }): (string|null);

        /**
            * Creates an AppListSourceItem message from a plain object. Also converts values to their respective internal types.
            * @param object Plain object
            * @returns AppListSourceItem
            */
        static fromObject(object: { [k: string]: any }): AppListSourceItem;

        /**
            * Creates a plain object from an AppListSourceItem message. Also converts values to other types if specified.
            * @param message AppListSourceItem
            * @param [options] Conversion options
            * @returns Plain object
            */
        static toObject(message: AppListSourceItem, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
            * Converts this AppListSourceItem to JSON.
            * @returns JSON object
            */
        toJSON(): { [k: string]: any };
}

/** Properties of an AppListContent. */
export interface IAppListContent {

        /** AppListContent source */
        source?: (IAppListSourceItem[]|null);
}

/** Represents an AppListContent. */
export class AppListContent implements IAppListContent {

        /**
            * Constructs a new AppListContent.
            * @param [properties] Properties to set
            */
        constructor(properties?: IAppListContent);

        /** AppListContent source. */
        source: IAppListSourceItem[];

        /**
            * Creates a new AppListContent instance using the specified properties.
            * @param [properties] Properties to set
            * @returns AppListContent instance
            */
        static create(properties?: IAppListContent): AppListContent;

        /**
            * Encodes the specified AppListContent message. Does not implicitly {@link AppListContent.verify|verify} messages.
            * @param message AppListContent message or plain object to encode
            * @param [writer] Writer to encode to
            * @returns Writer
            */
        static encode(message: IAppListContent, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
            * Encodes the specified AppListContent message, length delimited. Does not implicitly {@link AppListContent.verify|verify} messages.
            * @param message AppListContent message or plain object to encode
            * @param [writer] Writer to encode to
            * @returns Writer
            */
        static encodeDelimited(message: IAppListContent, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
            * Decodes an AppListContent message from the specified reader or buffer.
            * @param reader Reader or buffer to decode from
            * @param [length] Message length if known beforehand
            * @returns AppListContent
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */
        static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): AppListContent;

        /**
            * Decodes an AppListContent message from the specified reader or buffer, length delimited.
            * @param reader Reader or buffer to decode from
            * @returns AppListContent
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */
        static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): AppListContent;

        /**
            * Verifies an AppListContent message.
            * @param message Plain object to verify
            * @returns `null` if valid, otherwise the reason why it is not
            */
        static verify(message: { [k: string]: any }): (string|null);

        /**
            * Creates an AppListContent message from a plain object. Also converts values to their respective internal types.
            * @param object Plain object
            * @returns AppListContent
            */
        static fromObject(object: { [k: string]: any }): AppListContent;

        /**
            * Creates a plain object from an AppListContent message. Also converts values to other types if specified.
            * @param message AppListContent
            * @param [options] Conversion options
            * @returns Plain object
            */
        static toObject(message: AppListContent, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
            * Converts this AppListContent to JSON.
            * @returns JSON object
            */
        toJSON(): { [k: string]: any };
}

/** Properties of a DecAppDescContent. */
export interface IDecAppDescContent {

        /** DecAppDescContent id */
        id?: (string|null);
}

/** Represents a DecAppDescContent. */
export class DecAppDescContent implements IDecAppDescContent {

        /**
            * Constructs a new DecAppDescContent.
            * @param [properties] Properties to set
            */
        constructor(properties?: IDecAppDescContent);

        /** DecAppDescContent id. */
        id: string;

        /**
            * Creates a new DecAppDescContent instance using the specified properties.
            * @param [properties] Properties to set
            * @returns DecAppDescContent instance
            */
        static create(properties?: IDecAppDescContent): DecAppDescContent;

        /**
            * Encodes the specified DecAppDescContent message. Does not implicitly {@link DecAppDescContent.verify|verify} messages.
            * @param message DecAppDescContent message or plain object to encode
            * @param [writer] Writer to encode to
            * @returns Writer
            */
        static encode(message: IDecAppDescContent, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
            * Encodes the specified DecAppDescContent message, length delimited. Does not implicitly {@link DecAppDescContent.verify|verify} messages.
            * @param message DecAppDescContent message or plain object to encode
            * @param [writer] Writer to encode to
            * @returns Writer
            */
        static encodeDelimited(message: IDecAppDescContent, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
            * Decodes a DecAppDescContent message from the specified reader or buffer.
            * @param reader Reader or buffer to decode from
            * @param [length] Message length if known beforehand
            * @returns DecAppDescContent
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */
        static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): DecAppDescContent;

        /**
            * Decodes a DecAppDescContent message from the specified reader or buffer, length delimited.
            * @param reader Reader or buffer to decode from
            * @returns DecAppDescContent
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */
        static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): DecAppDescContent;

        /**
            * Verifies a DecAppDescContent message.
            * @param message Plain object to verify
            * @returns `null` if valid, otherwise the reason why it is not
            */
        static verify(message: { [k: string]: any }): (string|null);

        /**
            * Creates a DecAppDescContent message from a plain object. Also converts values to their respective internal types.
            * @param object Plain object
            * @returns DecAppDescContent
            */
        static fromObject(object: { [k: string]: any }): DecAppDescContent;

        /**
            * Creates a plain object from a DecAppDescContent message. Also converts values to other types if specified.
            * @param message DecAppDescContent
            * @param [options] Conversion options
            * @returns Plain object
            */
        static toObject(message: DecAppDescContent, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
            * Converts this DecAppDescContent to JSON.
            * @returns JSON object
            */
        toJSON(): { [k: string]: any };
}

/** Properties of a DecAppContent. */
export interface IDecAppContent {

        /** DecAppContent source */
        source?: ({ [k: string]: Uint8Array }|null);

        /** DecAppContent source_desc */
        source_desc?: ({ [k: string]: string }|null);

        /** DecAppContent icon */
        icon?: (string|null);

        /** DecAppContent desc */
        desc?: (string|null);

        /** DecAppContent tags */
        tags?: ({ [k: string]: string }|null);
}

/** Represents a DecAppContent. */
export class DecAppContent implements IDecAppContent {

        /**
            * Constructs a new DecAppContent.
            * @param [properties] Properties to set
            */
        constructor(properties?: IDecAppContent);

        /** DecAppContent source. */
        source: { [k: string]: Uint8Array };

        /** DecAppContent source_desc. */
        source_desc: { [k: string]: string };

        /** DecAppContent icon. */
        icon?: (string|null);

        /** DecAppContent desc. */
        desc?: (string|null);

        /** DecAppContent tags. */
        tags: { [k: string]: string };

        /** DecAppContent _icon. */
        _icon?: "icon";

        /** DecAppContent _desc. */
        _desc?: "desc";

        /**
            * Creates a new DecAppContent instance using the specified properties.
            * @param [properties] Properties to set
            * @returns DecAppContent instance
            */
        static create(properties?: IDecAppContent): DecAppContent;

        /**
            * Encodes the specified DecAppContent message. Does not implicitly {@link DecAppContent.verify|verify} messages.
            * @param message DecAppContent message or plain object to encode
            * @param [writer] Writer to encode to
            * @returns Writer
            */
        static encode(message: IDecAppContent, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
            * Encodes the specified DecAppContent message, length delimited. Does not implicitly {@link DecAppContent.verify|verify} messages.
            * @param message DecAppContent message or plain object to encode
            * @param [writer] Writer to encode to
            * @returns Writer
            */
        static encodeDelimited(message: IDecAppContent, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
            * Decodes a DecAppContent message from the specified reader or buffer.
            * @param reader Reader or buffer to decode from
            * @param [length] Message length if known beforehand
            * @returns DecAppContent
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */
        static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): DecAppContent;

        /**
            * Decodes a DecAppContent message from the specified reader or buffer, length delimited.
            * @param reader Reader or buffer to decode from
            * @returns DecAppContent
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */
        static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): DecAppContent;

        /**
            * Verifies a DecAppContent message.
            * @param message Plain object to verify
            * @returns `null` if valid, otherwise the reason why it is not
            */
        static verify(message: { [k: string]: any }): (string|null);

        /**
            * Creates a DecAppContent message from a plain object. Also converts values to their respective internal types.
            * @param object Plain object
            * @returns DecAppContent
            */
        static fromObject(object: { [k: string]: any }): DecAppContent;

        /**
            * Creates a plain object from a DecAppContent message. Also converts values to other types if specified.
            * @param message DecAppContent
            * @param [options] Conversion options
            * @returns Plain object
            */
        static toObject(message: DecAppContent, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
            * Converts this DecAppContent to JSON.
            * @returns JSON object
            */
        toJSON(): { [k: string]: any };
}

/** Properties of a PutAppDescContent. */
export interface IPutAppDescContent {

        /** PutAppDescContent apps */
        apps?: (Uint8Array[]|null);
}

/** Represents a PutAppDescContent. */
export class PutAppDescContent implements IPutAppDescContent {

        /**
            * Constructs a new PutAppDescContent.
            * @param [properties] Properties to set
            */
        constructor(properties?: IPutAppDescContent);

        /** PutAppDescContent apps. */
        apps: Uint8Array[];

        /**
            * Creates a new PutAppDescContent instance using the specified properties.
            * @param [properties] Properties to set
            * @returns PutAppDescContent instance
            */
        static create(properties?: IPutAppDescContent): PutAppDescContent;

        /**
            * Encodes the specified PutAppDescContent message. Does not implicitly {@link PutAppDescContent.verify|verify} messages.
            * @param message PutAppDescContent message or plain object to encode
            * @param [writer] Writer to encode to
            * @returns Writer
            */
        static encode(message: IPutAppDescContent, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
            * Encodes the specified PutAppDescContent message, length delimited. Does not implicitly {@link PutAppDescContent.verify|verify} messages.
            * @param message PutAppDescContent message or plain object to encode
            * @param [writer] Writer to encode to
            * @returns Writer
            */
        static encodeDelimited(message: IPutAppDescContent, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
            * Decodes a PutAppDescContent message from the specified reader or buffer.
            * @param reader Reader or buffer to decode from
            * @param [length] Message length if known beforehand
            * @returns PutAppDescContent
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */
        static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): PutAppDescContent;

        /**
            * Decodes a PutAppDescContent message from the specified reader or buffer, length delimited.
            * @param reader Reader or buffer to decode from
            * @returns PutAppDescContent
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */
        static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): PutAppDescContent;

        /**
            * Verifies a PutAppDescContent message.
            * @param message Plain object to verify
            * @returns `null` if valid, otherwise the reason why it is not
            */
        static verify(message: { [k: string]: any }): (string|null);

        /**
            * Creates a PutAppDescContent message from a plain object. Also converts values to their respective internal types.
            * @param object Plain object
            * @returns PutAppDescContent
            */
        static fromObject(object: { [k: string]: any }): PutAppDescContent;

        /**
            * Creates a plain object from a PutAppDescContent message. Also converts values to other types if specified.
            * @param message PutAppDescContent
            * @param [options] Conversion options
            * @returns Plain object
            */
        static toObject(message: PutAppDescContent, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
            * Converts this PutAppDescContent to JSON.
            * @returns JSON object
            */
        toJSON(): { [k: string]: any };
}

/** Properties of a RemoveAppDescContent. */
export interface IRemoveAppDescContent {

        /** RemoveAppDescContent apps */
        apps?: (Uint8Array[]|null);
}

/** Represents a RemoveAppDescContent. */
export class RemoveAppDescContent implements IRemoveAppDescContent {

        /**
            * Constructs a new RemoveAppDescContent.
            * @param [properties] Properties to set
            */
        constructor(properties?: IRemoveAppDescContent);

        /** RemoveAppDescContent apps. */
        apps: Uint8Array[];

        /**
            * Creates a new RemoveAppDescContent instance using the specified properties.
            * @param [properties] Properties to set
            * @returns RemoveAppDescContent instance
            */
        static create(properties?: IRemoveAppDescContent): RemoveAppDescContent;

        /**
            * Encodes the specified RemoveAppDescContent message. Does not implicitly {@link RemoveAppDescContent.verify|verify} messages.
            * @param message RemoveAppDescContent message or plain object to encode
            * @param [writer] Writer to encode to
            * @returns Writer
            */
        static encode(message: IRemoveAppDescContent, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
            * Encodes the specified RemoveAppDescContent message, length delimited. Does not implicitly {@link RemoveAppDescContent.verify|verify} messages.
            * @param message RemoveAppDescContent message or plain object to encode
            * @param [writer] Writer to encode to
            * @returns Writer
            */
        static encodeDelimited(message: IRemoveAppDescContent, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
            * Decodes a RemoveAppDescContent message from the specified reader or buffer.
            * @param reader Reader or buffer to decode from
            * @param [length] Message length if known beforehand
            * @returns RemoveAppDescContent
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */
        static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): RemoveAppDescContent;

        /**
            * Decodes a RemoveAppDescContent message from the specified reader or buffer, length delimited.
            * @param reader Reader or buffer to decode from
            * @returns RemoveAppDescContent
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */
        static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): RemoveAppDescContent;

        /**
            * Verifies a RemoveAppDescContent message.
            * @param message Plain object to verify
            * @returns `null` if valid, otherwise the reason why it is not
            */
        static verify(message: { [k: string]: any }): (string|null);

        /**
            * Creates a RemoveAppDescContent message from a plain object. Also converts values to their respective internal types.
            * @param object Plain object
            * @returns RemoveAppDescContent
            */
        static fromObject(object: { [k: string]: any }): RemoveAppDescContent;

        /**
            * Creates a plain object from a RemoveAppDescContent message. Also converts values to other types if specified.
            * @param message RemoveAppDescContent
            * @param [options] Conversion options
            * @returns Plain object
            */
        static toObject(message: RemoveAppDescContent, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
            * Converts this RemoveAppDescContent to JSON.
            * @returns JSON object
            */
        toJSON(): { [k: string]: any };
}

/** Properties of a FriendItem. */
export interface IFriendItem {

        /** FriendItem id */
        id?: (Uint8Array|null);

        /** FriendItem content */
        content?: (Uint8Array|null);
}

/** Represents a FriendItem. */
export class FriendItem implements IFriendItem {

        /**
            * Constructs a new FriendItem.
            * @param [properties] Properties to set
            */
        constructor(properties?: IFriendItem);

        /** FriendItem id. */
        id: Uint8Array;

        /** FriendItem content. */
        content: Uint8Array;

        /**
            * Creates a new FriendItem instance using the specified properties.
            * @param [properties] Properties to set
            * @returns FriendItem instance
            */
        static create(properties?: IFriendItem): FriendItem;

        /**
            * Encodes the specified FriendItem message. Does not implicitly {@link FriendItem.verify|verify} messages.
            * @param message FriendItem message or plain object to encode
            * @param [writer] Writer to encode to
            * @returns Writer
            */
        static encode(message: IFriendItem, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
            * Encodes the specified FriendItem message, length delimited. Does not implicitly {@link FriendItem.verify|verify} messages.
            * @param message FriendItem message or plain object to encode
            * @param [writer] Writer to encode to
            * @returns Writer
            */
        static encodeDelimited(message: IFriendItem, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
            * Decodes a FriendItem message from the specified reader or buffer.
            * @param reader Reader or buffer to decode from
            * @param [length] Message length if known beforehand
            * @returns FriendItem
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */
        static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): FriendItem;

        /**
            * Decodes a FriendItem message from the specified reader or buffer, length delimited.
            * @param reader Reader or buffer to decode from
            * @returns FriendItem
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */
        static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): FriendItem;

        /**
            * Verifies a FriendItem message.
            * @param message Plain object to verify
            * @returns `null` if valid, otherwise the reason why it is not
            */
        static verify(message: { [k: string]: any }): (string|null);

        /**
            * Creates a FriendItem message from a plain object. Also converts values to their respective internal types.
            * @param object Plain object
            * @returns FriendItem
            */
        static fromObject(object: { [k: string]: any }): FriendItem;

        /**
            * Creates a plain object from a FriendItem message. Also converts values to other types if specified.
            * @param message FriendItem
            * @param [options] Conversion options
            * @returns Plain object
            */
        static toObject(message: FriendItem, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
            * Converts this FriendItem to JSON.
            * @returns JSON object
            */
        toJSON(): { [k: string]: any };
}

/** Properties of a FriendListContent. */
export interface IFriendListContent {

        /** FriendListContent friends */
        friends?: (IFriendItem[]|null);

        /** FriendListContent auto_confirm */
        auto_confirm?: (number|null);

        /** FriendListContent auto_msg */
        auto_msg?: (string|null);
}

/** Represents a FriendListContent. */
export class FriendListContent implements IFriendListContent {

        /**
            * Constructs a new FriendListContent.
            * @param [properties] Properties to set
            */
        constructor(properties?: IFriendListContent);

        /** FriendListContent friends. */
        friends: IFriendItem[];

        /** FriendListContent auto_confirm. */
        auto_confirm: number;

        /** FriendListContent auto_msg. */
        auto_msg: string;

        /**
            * Creates a new FriendListContent instance using the specified properties.
            * @param [properties] Properties to set
            * @returns FriendListContent instance
            */
        static create(properties?: IFriendListContent): FriendListContent;

        /**
            * Encodes the specified FriendListContent message. Does not implicitly {@link FriendListContent.verify|verify} messages.
            * @param message FriendListContent message or plain object to encode
            * @param [writer] Writer to encode to
            * @returns Writer
            */
        static encode(message: IFriendListContent, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
            * Encodes the specified FriendListContent message, length delimited. Does not implicitly {@link FriendListContent.verify|verify} messages.
            * @param message FriendListContent message or plain object to encode
            * @param [writer] Writer to encode to
            * @returns Writer
            */
        static encodeDelimited(message: IFriendListContent, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
            * Decodes a FriendListContent message from the specified reader or buffer.
            * @param reader Reader or buffer to decode from
            * @param [length] Message length if known beforehand
            * @returns FriendListContent
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */
        static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): FriendListContent;

        /**
            * Decodes a FriendListContent message from the specified reader or buffer, length delimited.
            * @param reader Reader or buffer to decode from
            * @returns FriendListContent
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */
        static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): FriendListContent;

        /**
            * Verifies a FriendListContent message.
            * @param message Plain object to verify
            * @returns `null` if valid, otherwise the reason why it is not
            */
        static verify(message: { [k: string]: any }): (string|null);

        /**
            * Creates a FriendListContent message from a plain object. Also converts values to their respective internal types.
            * @param object Plain object
            * @returns FriendListContent
            */
        static fromObject(object: { [k: string]: any }): FriendListContent;

        /**
            * Creates a plain object from a FriendListContent message. Also converts values to other types if specified.
            * @param message FriendListContent
            * @param [options] Conversion options
            * @returns Plain object
            */
        static toObject(message: FriendListContent, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
            * Converts this FriendListContent to JSON.
            * @returns JSON object
            */
        toJSON(): { [k: string]: any };
}

/** Properties of an AddFriendDescContent. */
export interface IAddFriendDescContent {

        /** AddFriendDescContent to */
        to?: (Uint8Array|null);
}

/** Represents an AddFriendDescContent. */
export class AddFriendDescContent implements IAddFriendDescContent {

        /**
            * Constructs a new AddFriendDescContent.
            * @param [properties] Properties to set
            */
        constructor(properties?: IAddFriendDescContent);

        /** AddFriendDescContent to. */
        to: Uint8Array;

        /**
            * Creates a new AddFriendDescContent instance using the specified properties.
            * @param [properties] Properties to set
            * @returns AddFriendDescContent instance
            */
        static create(properties?: IAddFriendDescContent): AddFriendDescContent;

        /**
            * Encodes the specified AddFriendDescContent message. Does not implicitly {@link AddFriendDescContent.verify|verify} messages.
            * @param message AddFriendDescContent message or plain object to encode
            * @param [writer] Writer to encode to
            * @returns Writer
            */
        static encode(message: IAddFriendDescContent, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
            * Encodes the specified AddFriendDescContent message, length delimited. Does not implicitly {@link AddFriendDescContent.verify|verify} messages.
            * @param message AddFriendDescContent message or plain object to encode
            * @param [writer] Writer to encode to
            * @returns Writer
            */
        static encodeDelimited(message: IAddFriendDescContent, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
            * Decodes an AddFriendDescContent message from the specified reader or buffer.
            * @param reader Reader or buffer to decode from
            * @param [length] Message length if known beforehand
            * @returns AddFriendDescContent
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */
        static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): AddFriendDescContent;

        /**
            * Decodes an AddFriendDescContent message from the specified reader or buffer, length delimited.
            * @param reader Reader or buffer to decode from
            * @returns AddFriendDescContent
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */
        static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): AddFriendDescContent;

        /**
            * Verifies an AddFriendDescContent message.
            * @param message Plain object to verify
            * @returns `null` if valid, otherwise the reason why it is not
            */
        static verify(message: { [k: string]: any }): (string|null);

        /**
            * Creates an AddFriendDescContent message from a plain object. Also converts values to their respective internal types.
            * @param object Plain object
            * @returns AddFriendDescContent
            */
        static fromObject(object: { [k: string]: any }): AddFriendDescContent;

        /**
            * Creates a plain object from an AddFriendDescContent message. Also converts values to other types if specified.
            * @param message AddFriendDescContent
            * @param [options] Conversion options
            * @returns Plain object
            */
        static toObject(message: AddFriendDescContent, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
            * Converts this AddFriendDescContent to JSON.
            * @returns JSON object
            */
        toJSON(): { [k: string]: any };
}

/** Properties of a RemoveFriendDescContent. */
export interface IRemoveFriendDescContent {

        /** RemoveFriendDescContent to */
        to?: (Uint8Array|null);
}

/** Represents a RemoveFriendDescContent. */
export class RemoveFriendDescContent implements IRemoveFriendDescContent {

        /**
            * Constructs a new RemoveFriendDescContent.
            * @param [properties] Properties to set
            */
        constructor(properties?: IRemoveFriendDescContent);

        /** RemoveFriendDescContent to. */
        to: Uint8Array;

        /**
            * Creates a new RemoveFriendDescContent instance using the specified properties.
            * @param [properties] Properties to set
            * @returns RemoveFriendDescContent instance
            */
        static create(properties?: IRemoveFriendDescContent): RemoveFriendDescContent;

        /**
            * Encodes the specified RemoveFriendDescContent message. Does not implicitly {@link RemoveFriendDescContent.verify|verify} messages.
            * @param message RemoveFriendDescContent message or plain object to encode
            * @param [writer] Writer to encode to
            * @returns Writer
            */
        static encode(message: IRemoveFriendDescContent, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
            * Encodes the specified RemoveFriendDescContent message, length delimited. Does not implicitly {@link RemoveFriendDescContent.verify|verify} messages.
            * @param message RemoveFriendDescContent message or plain object to encode
            * @param [writer] Writer to encode to
            * @returns Writer
            */
        static encodeDelimited(message: IRemoveFriendDescContent, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
            * Decodes a RemoveFriendDescContent message from the specified reader or buffer.
            * @param reader Reader or buffer to decode from
            * @param [length] Message length if known beforehand
            * @returns RemoveFriendDescContent
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */
        static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): RemoveFriendDescContent;

        /**
            * Decodes a RemoveFriendDescContent message from the specified reader or buffer, length delimited.
            * @param reader Reader or buffer to decode from
            * @returns RemoveFriendDescContent
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */
        static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): RemoveFriendDescContent;

        /**
            * Verifies a RemoveFriendDescContent message.
            * @param message Plain object to verify
            * @returns `null` if valid, otherwise the reason why it is not
            */
        static verify(message: { [k: string]: any }): (string|null);

        /**
            * Creates a RemoveFriendDescContent message from a plain object. Also converts values to their respective internal types.
            * @param object Plain object
            * @returns RemoveFriendDescContent
            */
        static fromObject(object: { [k: string]: any }): RemoveFriendDescContent;

        /**
            * Creates a plain object from a RemoveFriendDescContent message. Also converts values to other types if specified.
            * @param message RemoveFriendDescContent
            * @param [options] Conversion options
            * @returns Plain object
            */
        static toObject(message: RemoveFriendDescContent, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
            * Converts this RemoveFriendDescContent to JSON.
            * @returns JSON object
            */
        toJSON(): { [k: string]: any };
}

/** Properties of a FriendOptionContent. */
export interface IFriendOptionContent {

        /** FriendOptionContent auto_confirm */
        auto_confirm?: (number|null);

        /** FriendOptionContent msg */
        msg?: (string|null);
}

/** Represents a FriendOptionContent. */
export class FriendOptionContent implements IFriendOptionContent {

        /**
            * Constructs a new FriendOptionContent.
            * @param [properties] Properties to set
            */
        constructor(properties?: IFriendOptionContent);

        /** FriendOptionContent auto_confirm. */
        auto_confirm?: (number|null);

        /** FriendOptionContent msg. */
        msg?: (string|null);

        /** FriendOptionContent _auto_confirm. */
        _auto_confirm?: "auto_confirm";

        /** FriendOptionContent _msg. */
        _msg?: "msg";

        /**
            * Creates a new FriendOptionContent instance using the specified properties.
            * @param [properties] Properties to set
            * @returns FriendOptionContent instance
            */
        static create(properties?: IFriendOptionContent): FriendOptionContent;

        /**
            * Encodes the specified FriendOptionContent message. Does not implicitly {@link FriendOptionContent.verify|verify} messages.
            * @param message FriendOptionContent message or plain object to encode
            * @param [writer] Writer to encode to
            * @returns Writer
            */
        static encode(message: IFriendOptionContent, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
            * Encodes the specified FriendOptionContent message, length delimited. Does not implicitly {@link FriendOptionContent.verify|verify} messages.
            * @param message FriendOptionContent message or plain object to encode
            * @param [writer] Writer to encode to
            * @returns Writer
            */
        static encodeDelimited(message: IFriendOptionContent, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
            * Decodes a FriendOptionContent message from the specified reader or buffer.
            * @param reader Reader or buffer to decode from
            * @param [length] Message length if known beforehand
            * @returns FriendOptionContent
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */
        static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): FriendOptionContent;

        /**
            * Decodes a FriendOptionContent message from the specified reader or buffer, length delimited.
            * @param reader Reader or buffer to decode from
            * @returns FriendOptionContent
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */
        static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): FriendOptionContent;

        /**
            * Verifies a FriendOptionContent message.
            * @param message Plain object to verify
            * @returns `null` if valid, otherwise the reason why it is not
            */
        static verify(message: { [k: string]: any }): (string|null);

        /**
            * Creates a FriendOptionContent message from a plain object. Also converts values to their respective internal types.
            * @param object Plain object
            * @returns FriendOptionContent
            */
        static fromObject(object: { [k: string]: any }): FriendOptionContent;

        /**
            * Creates a plain object from a FriendOptionContent message. Also converts values to other types if specified.
            * @param message FriendOptionContent
            * @param [options] Conversion options
            * @returns Plain object
            */
        static toObject(message: FriendOptionContent, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
            * Converts this FriendOptionContent to JSON.
            * @returns JSON object
            */
        toJSON(): { [k: string]: any };
}

/** Properties of a MsgObjectContent. */
export interface IMsgObjectContent {

        /** MsgObjectContent id */
        id?: (Uint8Array|null);

        /** MsgObjectContent name */
        name?: (string|null);
}

/** Represents a MsgObjectContent. */
export class MsgObjectContent implements IMsgObjectContent {

        /**
            * Constructs a new MsgObjectContent.
            * @param [properties] Properties to set
            */
        constructor(properties?: IMsgObjectContent);

        /** MsgObjectContent id. */
        id: Uint8Array;

        /** MsgObjectContent name. */
        name: string;

        /**
            * Creates a new MsgObjectContent instance using the specified properties.
            * @param [properties] Properties to set
            * @returns MsgObjectContent instance
            */
        static create(properties?: IMsgObjectContent): MsgObjectContent;

        /**
            * Encodes the specified MsgObjectContent message. Does not implicitly {@link MsgObjectContent.verify|verify} messages.
            * @param message MsgObjectContent message or plain object to encode
            * @param [writer] Writer to encode to
            * @returns Writer
            */
        static encode(message: IMsgObjectContent, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
            * Encodes the specified MsgObjectContent message, length delimited. Does not implicitly {@link MsgObjectContent.verify|verify} messages.
            * @param message MsgObjectContent message or plain object to encode
            * @param [writer] Writer to encode to
            * @returns Writer
            */
        static encodeDelimited(message: IMsgObjectContent, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
            * Decodes a MsgObjectContent message from the specified reader or buffer.
            * @param reader Reader or buffer to decode from
            * @param [length] Message length if known beforehand
            * @returns MsgObjectContent
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */
        static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): MsgObjectContent;

        /**
            * Decodes a MsgObjectContent message from the specified reader or buffer, length delimited.
            * @param reader Reader or buffer to decode from
            * @returns MsgObjectContent
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */
        static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): MsgObjectContent;

        /**
            * Verifies a MsgObjectContent message.
            * @param message Plain object to verify
            * @returns `null` if valid, otherwise the reason why it is not
            */
        static verify(message: { [k: string]: any }): (string|null);

        /**
            * Creates a MsgObjectContent message from a plain object. Also converts values to their respective internal types.
            * @param object Plain object
            * @returns MsgObjectContent
            */
        static fromObject(object: { [k: string]: any }): MsgObjectContent;

        /**
            * Creates a plain object from a MsgObjectContent message. Also converts values to other types if specified.
            * @param message MsgObjectContent
            * @param [options] Conversion options
            * @returns Plain object
            */
        static toObject(message: MsgObjectContent, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
            * Converts this MsgObjectContent to JSON.
            * @returns JSON object
            */
        toJSON(): { [k: string]: any };
}

/** Properties of a MsgContent. */
export interface IMsgContent {

        /** MsgContent type */
        type?: (MsgContent.Type|null);

        /** MsgContent text */
        text?: (string|null);

        /** MsgContent content */
        content?: (IMsgObjectContent|null);
}

/** Represents a MsgContent. */
export class MsgContent implements IMsgContent {

        /**
            * Constructs a new MsgContent.
            * @param [properties] Properties to set
            */
        constructor(properties?: IMsgContent);

        /** MsgContent type. */
        type: MsgContent.Type;

        /** MsgContent text. */
        text?: (string|null);

        /** MsgContent content. */
        content?: (IMsgObjectContent|null);

        /** MsgContent _text. */
        _text?: "text";

        /** MsgContent _content. */
        _content?: "content";

        /**
            * Creates a new MsgContent instance using the specified properties.
            * @param [properties] Properties to set
            * @returns MsgContent instance
            */
        static create(properties?: IMsgContent): MsgContent;

        /**
            * Encodes the specified MsgContent message. Does not implicitly {@link MsgContent.verify|verify} messages.
            * @param message MsgContent message or plain object to encode
            * @param [writer] Writer to encode to
            * @returns Writer
            */
        static encode(message: IMsgContent, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
            * Encodes the specified MsgContent message, length delimited. Does not implicitly {@link MsgContent.verify|verify} messages.
            * @param message MsgContent message or plain object to encode
            * @param [writer] Writer to encode to
            * @returns Writer
            */
        static encodeDelimited(message: IMsgContent, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
            * Decodes a MsgContent message from the specified reader or buffer.
            * @param reader Reader or buffer to decode from
            * @param [length] Message length if known beforehand
            * @returns MsgContent
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */
        static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): MsgContent;

        /**
            * Decodes a MsgContent message from the specified reader or buffer, length delimited.
            * @param reader Reader or buffer to decode from
            * @returns MsgContent
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */
        static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): MsgContent;

        /**
            * Verifies a MsgContent message.
            * @param message Plain object to verify
            * @returns `null` if valid, otherwise the reason why it is not
            */
        static verify(message: { [k: string]: any }): (string|null);

        /**
            * Creates a MsgContent message from a plain object. Also converts values to their respective internal types.
            * @param object Plain object
            * @returns MsgContent
            */
        static fromObject(object: { [k: string]: any }): MsgContent;

        /**
            * Creates a plain object from a MsgContent message. Also converts values to other types if specified.
            * @param message MsgContent
            * @param [options] Conversion options
            * @returns Plain object
            */
        static toObject(message: MsgContent, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
            * Converts this MsgContent to JSON.
            * @returns JSON object
            */
        toJSON(): { [k: string]: any };
}

export namespace MsgContent {

        /** Type enum. */
        enum Type {
                Text = 0,
                Object = 1
        }
}

/** Properties of a MsgDescContent. */
export interface IMsgDescContent {

        /** MsgDescContent to */
        to?: (Uint8Array|null);

        /** MsgDescContent content */
        content?: (IMsgContent|null);
}

/** Represents a MsgDescContent. */
export class MsgDescContent implements IMsgDescContent {

        /**
            * Constructs a new MsgDescContent.
            * @param [properties] Properties to set
            */
        constructor(properties?: IMsgDescContent);

        /** MsgDescContent to. */
        to: Uint8Array;

        /** MsgDescContent content. */
        content?: (IMsgContent|null);

        /**
            * Creates a new MsgDescContent instance using the specified properties.
            * @param [properties] Properties to set
            * @returns MsgDescContent instance
            */
        static create(properties?: IMsgDescContent): MsgDescContent;

        /**
            * Encodes the specified MsgDescContent message. Does not implicitly {@link MsgDescContent.verify|verify} messages.
            * @param message MsgDescContent message or plain object to encode
            * @param [writer] Writer to encode to
            * @returns Writer
            */
        static encode(message: IMsgDescContent, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
            * Encodes the specified MsgDescContent message, length delimited. Does not implicitly {@link MsgDescContent.verify|verify} messages.
            * @param message MsgDescContent message or plain object to encode
            * @param [writer] Writer to encode to
            * @returns Writer
            */
        static encodeDelimited(message: IMsgDescContent, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
            * Decodes a MsgDescContent message from the specified reader or buffer.
            * @param reader Reader or buffer to decode from
            * @param [length] Message length if known beforehand
            * @returns MsgDescContent
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */
        static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): MsgDescContent;

        /**
            * Decodes a MsgDescContent message from the specified reader or buffer, length delimited.
            * @param reader Reader or buffer to decode from
            * @returns MsgDescContent
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */
        static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): MsgDescContent;

        /**
            * Verifies a MsgDescContent message.
            * @param message Plain object to verify
            * @returns `null` if valid, otherwise the reason why it is not
            */
        static verify(message: { [k: string]: any }): (string|null);

        /**
            * Creates a MsgDescContent message from a plain object. Also converts values to their respective internal types.
            * @param object Plain object
            * @returns MsgDescContent
            */
        static fromObject(object: { [k: string]: any }): MsgDescContent;

        /**
            * Creates a plain object from a MsgDescContent message. Also converts values to other types if specified.
            * @param message MsgDescContent
            * @param [options] Conversion options
            * @returns Plain object
            */
        static toObject(message: MsgDescContent, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
            * Converts this MsgDescContent to JSON.
            * @returns JSON object
            */
        toJSON(): { [k: string]: any };
}

/** Properties of a MsgInfo. */
export interface IMsgInfo {

        /** MsgInfo orderd */
        orderd?: (number|null);

        /** MsgInfo seq */
        seq?: (number|Long|null);

        /** MsgInfo msg_obj_id */
        msg_obj_id?: (Uint8Array|null);

        /** MsgInfo member_id */
        member_id?: (Uint8Array|null);
}

/** Topic objects */
export class MsgInfo implements IMsgInfo {

        /**
            * Constructs a new MsgInfo.
            * @param [properties] Properties to set
            */
        constructor(properties?: IMsgInfo);

        /** MsgInfo orderd. */
        orderd: number;

        /** MsgInfo seq. */
        seq: (number|Long);

        /** MsgInfo msg_obj_id. */
        msg_obj_id: Uint8Array;

        /** MsgInfo member_id. */
        member_id: Uint8Array;

        /**
            * Creates a new MsgInfo instance using the specified properties.
            * @param [properties] Properties to set
            * @returns MsgInfo instance
            */
        static create(properties?: IMsgInfo): MsgInfo;

        /**
            * Encodes the specified MsgInfo message. Does not implicitly {@link MsgInfo.verify|verify} messages.
            * @param message MsgInfo message or plain object to encode
            * @param [writer] Writer to encode to
            * @returns Writer
            */
        static encode(message: IMsgInfo, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
            * Encodes the specified MsgInfo message, length delimited. Does not implicitly {@link MsgInfo.verify|verify} messages.
            * @param message MsgInfo message or plain object to encode
            * @param [writer] Writer to encode to
            * @returns Writer
            */
        static encodeDelimited(message: IMsgInfo, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
            * Decodes a MsgInfo message from the specified reader or buffer.
            * @param reader Reader or buffer to decode from
            * @param [length] Message length if known beforehand
            * @returns MsgInfo
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */
        static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): MsgInfo;

        /**
            * Decodes a MsgInfo message from the specified reader or buffer, length delimited.
            * @param reader Reader or buffer to decode from
            * @returns MsgInfo
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */
        static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): MsgInfo;

        /**
            * Verifies a MsgInfo message.
            * @param message Plain object to verify
            * @returns `null` if valid, otherwise the reason why it is not
            */
        static verify(message: { [k: string]: any }): (string|null);

        /**
            * Creates a MsgInfo message from a plain object. Also converts values to their respective internal types.
            * @param object Plain object
            * @returns MsgInfo
            */
        static fromObject(object: { [k: string]: any }): MsgInfo;

        /**
            * Creates a plain object from a MsgInfo message. Also converts values to other types if specified.
            * @param message MsgInfo
            * @param [options] Conversion options
            * @returns Plain object
            */
        static toObject(message: MsgInfo, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
            * Converts this MsgInfo to JSON.
            * @returns JSON object
            */
        toJSON(): { [k: string]: any };
}

/** Properties of a TopicMessageListDescContent. */
export interface ITopicMessageListDescContent {

        /** TopicMessageListDescContent topic_id */
        topic_id?: (Uint8Array|null);

        /** TopicMessageListDescContent slot */
        slot?: (number|null);
}

/** Represents a TopicMessageListDescContent. */
export class TopicMessageListDescContent implements ITopicMessageListDescContent {

        /**
            * Constructs a new TopicMessageListDescContent.
            * @param [properties] Properties to set
            */
        constructor(properties?: ITopicMessageListDescContent);

        /** TopicMessageListDescContent topic_id. */
        topic_id: Uint8Array;

        /** TopicMessageListDescContent slot. */
        slot: number;

        /**
            * Creates a new TopicMessageListDescContent instance using the specified properties.
            * @param [properties] Properties to set
            * @returns TopicMessageListDescContent instance
            */
        static create(properties?: ITopicMessageListDescContent): TopicMessageListDescContent;

        /**
            * Encodes the specified TopicMessageListDescContent message. Does not implicitly {@link TopicMessageListDescContent.verify|verify} messages.
            * @param message TopicMessageListDescContent message or plain object to encode
            * @param [writer] Writer to encode to
            * @returns Writer
            */
        static encode(message: ITopicMessageListDescContent, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
            * Encodes the specified TopicMessageListDescContent message, length delimited. Does not implicitly {@link TopicMessageListDescContent.verify|verify} messages.
            * @param message TopicMessageListDescContent message or plain object to encode
            * @param [writer] Writer to encode to
            * @returns Writer
            */
        static encodeDelimited(message: ITopicMessageListDescContent, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
            * Decodes a TopicMessageListDescContent message from the specified reader or buffer.
            * @param reader Reader or buffer to decode from
            * @param [length] Message length if known beforehand
            * @returns TopicMessageListDescContent
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */
        static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TopicMessageListDescContent;

        /**
            * Decodes a TopicMessageListDescContent message from the specified reader or buffer, length delimited.
            * @param reader Reader or buffer to decode from
            * @returns TopicMessageListDescContent
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */
        static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): TopicMessageListDescContent;

        /**
            * Verifies a TopicMessageListDescContent message.
            * @param message Plain object to verify
            * @returns `null` if valid, otherwise the reason why it is not
            */
        static verify(message: { [k: string]: any }): (string|null);

        /**
            * Creates a TopicMessageListDescContent message from a plain object. Also converts values to their respective internal types.
            * @param object Plain object
            * @returns TopicMessageListDescContent
            */
        static fromObject(object: { [k: string]: any }): TopicMessageListDescContent;

        /**
            * Creates a plain object from a TopicMessageListDescContent message. Also converts values to other types if specified.
            * @param message TopicMessageListDescContent
            * @param [options] Conversion options
            * @returns Plain object
            */
        static toObject(message: TopicMessageListDescContent, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
            * Converts this TopicMessageListDescContent to JSON.
            * @returns JSON object
            */
        toJSON(): { [k: string]: any };
}

/** Properties of a TopicMessageListBodyContent. */
export interface ITopicMessageListBodyContent {

        /** TopicMessageListBodyContent start */
        start?: (number|null);

        /** TopicMessageListBodyContent msg_list */
        msg_list?: (IMsgInfo[]|null);
}

/** Represents a TopicMessageListBodyContent. */
export class TopicMessageListBodyContent implements ITopicMessageListBodyContent {

        /**
            * Constructs a new TopicMessageListBodyContent.
            * @param [properties] Properties to set
            */
        constructor(properties?: ITopicMessageListBodyContent);

        /** TopicMessageListBodyContent start. */
        start: number;

        /** TopicMessageListBodyContent msg_list. */
        msg_list: IMsgInfo[];

        /**
            * Creates a new TopicMessageListBodyContent instance using the specified properties.
            * @param [properties] Properties to set
            * @returns TopicMessageListBodyContent instance
            */
        static create(properties?: ITopicMessageListBodyContent): TopicMessageListBodyContent;

        /**
            * Encodes the specified TopicMessageListBodyContent message. Does not implicitly {@link TopicMessageListBodyContent.verify|verify} messages.
            * @param message TopicMessageListBodyContent message or plain object to encode
            * @param [writer] Writer to encode to
            * @returns Writer
            */
        static encode(message: ITopicMessageListBodyContent, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
            * Encodes the specified TopicMessageListBodyContent message, length delimited. Does not implicitly {@link TopicMessageListBodyContent.verify|verify} messages.
            * @param message TopicMessageListBodyContent message or plain object to encode
            * @param [writer] Writer to encode to
            * @returns Writer
            */
        static encodeDelimited(message: ITopicMessageListBodyContent, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
            * Decodes a TopicMessageListBodyContent message from the specified reader or buffer.
            * @param reader Reader or buffer to decode from
            * @param [length] Message length if known beforehand
            * @returns TopicMessageListBodyContent
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */
        static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TopicMessageListBodyContent;

        /**
            * Decodes a TopicMessageListBodyContent message from the specified reader or buffer, length delimited.
            * @param reader Reader or buffer to decode from
            * @returns TopicMessageListBodyContent
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */
        static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): TopicMessageListBodyContent;

        /**
            * Verifies a TopicMessageListBodyContent message.
            * @param message Plain object to verify
            * @returns `null` if valid, otherwise the reason why it is not
            */
        static verify(message: { [k: string]: any }): (string|null);

        /**
            * Creates a TopicMessageListBodyContent message from a plain object. Also converts values to their respective internal types.
            * @param object Plain object
            * @returns TopicMessageListBodyContent
            */
        static fromObject(object: { [k: string]: any }): TopicMessageListBodyContent;

        /**
            * Creates a plain object from a TopicMessageListBodyContent message. Also converts values to other types if specified.
            * @param message TopicMessageListBodyContent
            * @param [options] Conversion options
            * @returns Plain object
            */
        static toObject(message: TopicMessageListBodyContent, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
            * Converts this TopicMessageListBodyContent to JSON.
            * @returns JSON object
            */
        toJSON(): { [k: string]: any };
}

/** Properties of a TopicPublishReqDescContent. */
export interface ITopicPublishReqDescContent {

        /** TopicPublishReqDescContent topic_id */
        topic_id?: (Uint8Array|null);

        /** TopicPublishReqDescContent topic_owner_id */
        topic_owner_id?: (Uint8Array|null);

        /** TopicPublishReqDescContent member_id */
        member_id?: (Uint8Array|null);

        /** TopicPublishReqDescContent seq */
        seq?: (number|null);

        /** TopicPublishReqDescContent count */
        count?: (number|null);
}

/** Represents a TopicPublishReqDescContent. */
export class TopicPublishReqDescContent implements ITopicPublishReqDescContent {

        /**
            * Constructs a new TopicPublishReqDescContent.
            * @param [properties] Properties to set
            */
        constructor(properties?: ITopicPublishReqDescContent);

        /** TopicPublishReqDescContent topic_id. */
        topic_id: Uint8Array;

        /** TopicPublishReqDescContent topic_owner_id. */
        topic_owner_id: Uint8Array;

        /** TopicPublishReqDescContent member_id. */
        member_id: Uint8Array;

        /** TopicPublishReqDescContent seq. */
        seq: number;

        /** TopicPublishReqDescContent count. */
        count: number;

        /**
            * Creates a new TopicPublishReqDescContent instance using the specified properties.
            * @param [properties] Properties to set
            * @returns TopicPublishReqDescContent instance
            */
        static create(properties?: ITopicPublishReqDescContent): TopicPublishReqDescContent;

        /**
            * Encodes the specified TopicPublishReqDescContent message. Does not implicitly {@link TopicPublishReqDescContent.verify|verify} messages.
            * @param message TopicPublishReqDescContent message or plain object to encode
            * @param [writer] Writer to encode to
            * @returns Writer
            */
        static encode(message: ITopicPublishReqDescContent, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
            * Encodes the specified TopicPublishReqDescContent message, length delimited. Does not implicitly {@link TopicPublishReqDescContent.verify|verify} messages.
            * @param message TopicPublishReqDescContent message or plain object to encode
            * @param [writer] Writer to encode to
            * @returns Writer
            */
        static encodeDelimited(message: ITopicPublishReqDescContent, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
            * Decodes a TopicPublishReqDescContent message from the specified reader or buffer.
            * @param reader Reader or buffer to decode from
            * @param [length] Message length if known beforehand
            * @returns TopicPublishReqDescContent
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */
        static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TopicPublishReqDescContent;

        /**
            * Decodes a TopicPublishReqDescContent message from the specified reader or buffer, length delimited.
            * @param reader Reader or buffer to decode from
            * @returns TopicPublishReqDescContent
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */
        static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): TopicPublishReqDescContent;

        /**
            * Verifies a TopicPublishReqDescContent message.
            * @param message Plain object to verify
            * @returns `null` if valid, otherwise the reason why it is not
            */
        static verify(message: { [k: string]: any }): (string|null);

        /**
            * Creates a TopicPublishReqDescContent message from a plain object. Also converts values to their respective internal types.
            * @param object Plain object
            * @returns TopicPublishReqDescContent
            */
        static fromObject(object: { [k: string]: any }): TopicPublishReqDescContent;

        /**
            * Creates a plain object from a TopicPublishReqDescContent message. Also converts values to other types if specified.
            * @param message TopicPublishReqDescContent
            * @param [options] Conversion options
            * @returns Plain object
            */
        static toObject(message: TopicPublishReqDescContent, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
            * Converts this TopicPublishReqDescContent to JSON.
            * @returns JSON object
            */
        toJSON(): { [k: string]: any };
}

/** Properties of a TopicPublishRespDescContent. */
export interface ITopicPublishRespDescContent {

        /** TopicPublishRespDescContent topic_id */
        topic_id?: (Uint8Array|null);

        /** TopicPublishRespDescContent topic_owner_id */
        topic_owner_id?: (Uint8Array|null);

        /** TopicPublishRespDescContent member_id */
        member_id?: (Uint8Array|null);

        /** TopicPublishRespDescContent seq */
        seq?: (number|Long|null);
}

/** Represents a TopicPublishRespDescContent. */
export class TopicPublishRespDescContent implements ITopicPublishRespDescContent {

        /**
            * Constructs a new TopicPublishRespDescContent.
            * @param [properties] Properties to set
            */
        constructor(properties?: ITopicPublishRespDescContent);

        /** TopicPublishRespDescContent topic_id. */
        topic_id: Uint8Array;

        /** TopicPublishRespDescContent topic_owner_id. */
        topic_owner_id: Uint8Array;

        /** TopicPublishRespDescContent member_id. */
        member_id: Uint8Array;

        /** TopicPublishRespDescContent seq. */
        seq: (number|Long);

        /**
            * Creates a new TopicPublishRespDescContent instance using the specified properties.
            * @param [properties] Properties to set
            * @returns TopicPublishRespDescContent instance
            */
        static create(properties?: ITopicPublishRespDescContent): TopicPublishRespDescContent;

        /**
            * Encodes the specified TopicPublishRespDescContent message. Does not implicitly {@link TopicPublishRespDescContent.verify|verify} messages.
            * @param message TopicPublishRespDescContent message or plain object to encode
            * @param [writer] Writer to encode to
            * @returns Writer
            */
        static encode(message: ITopicPublishRespDescContent, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
            * Encodes the specified TopicPublishRespDescContent message, length delimited. Does not implicitly {@link TopicPublishRespDescContent.verify|verify} messages.
            * @param message TopicPublishRespDescContent message or plain object to encode
            * @param [writer] Writer to encode to
            * @returns Writer
            */
        static encodeDelimited(message: ITopicPublishRespDescContent, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
            * Decodes a TopicPublishRespDescContent message from the specified reader or buffer.
            * @param reader Reader or buffer to decode from
            * @param [length] Message length if known beforehand
            * @returns TopicPublishRespDescContent
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */
        static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TopicPublishRespDescContent;

        /**
            * Decodes a TopicPublishRespDescContent message from the specified reader or buffer, length delimited.
            * @param reader Reader or buffer to decode from
            * @returns TopicPublishRespDescContent
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */
        static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): TopicPublishRespDescContent;

        /**
            * Verifies a TopicPublishRespDescContent message.
            * @param message Plain object to verify
            * @returns `null` if valid, otherwise the reason why it is not
            */
        static verify(message: { [k: string]: any }): (string|null);

        /**
            * Creates a TopicPublishRespDescContent message from a plain object. Also converts values to their respective internal types.
            * @param object Plain object
            * @returns TopicPublishRespDescContent
            */
        static fromObject(object: { [k: string]: any }): TopicPublishRespDescContent;

        /**
            * Creates a plain object from a TopicPublishRespDescContent message. Also converts values to other types if specified.
            * @param message TopicPublishRespDescContent
            * @param [options] Conversion options
            * @returns Plain object
            */
        static toObject(message: TopicPublishRespDescContent, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
            * Converts this TopicPublishRespDescContent to JSON.
            * @returns JSON object
            */
        toJSON(): { [k: string]: any };
}

/** Properties of a TopicPublishStatusDescContent. */
export interface ITopicPublishStatusDescContent {

        /** TopicPublishStatusDescContent topic_id */
        topic_id?: (Uint8Array|null);
}

/** Represents a TopicPublishStatusDescContent. */
export class TopicPublishStatusDescContent implements ITopicPublishStatusDescContent {

        /**
            * Constructs a new TopicPublishStatusDescContent.
            * @param [properties] Properties to set
            */
        constructor(properties?: ITopicPublishStatusDescContent);

        /** TopicPublishStatusDescContent topic_id. */
        topic_id: Uint8Array;

        /**
            * Creates a new TopicPublishStatusDescContent instance using the specified properties.
            * @param [properties] Properties to set
            * @returns TopicPublishStatusDescContent instance
            */
        static create(properties?: ITopicPublishStatusDescContent): TopicPublishStatusDescContent;

        /**
            * Encodes the specified TopicPublishStatusDescContent message. Does not implicitly {@link TopicPublishStatusDescContent.verify|verify} messages.
            * @param message TopicPublishStatusDescContent message or plain object to encode
            * @param [writer] Writer to encode to
            * @returns Writer
            */
        static encode(message: ITopicPublishStatusDescContent, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
            * Encodes the specified TopicPublishStatusDescContent message, length delimited. Does not implicitly {@link TopicPublishStatusDescContent.verify|verify} messages.
            * @param message TopicPublishStatusDescContent message or plain object to encode
            * @param [writer] Writer to encode to
            * @returns Writer
            */
        static encodeDelimited(message: ITopicPublishStatusDescContent, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
            * Decodes a TopicPublishStatusDescContent message from the specified reader or buffer.
            * @param reader Reader or buffer to decode from
            * @param [length] Message length if known beforehand
            * @returns TopicPublishStatusDescContent
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */
        static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TopicPublishStatusDescContent;

        /**
            * Decodes a TopicPublishStatusDescContent message from the specified reader or buffer, length delimited.
            * @param reader Reader or buffer to decode from
            * @returns TopicPublishStatusDescContent
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */
        static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): TopicPublishStatusDescContent;

        /**
            * Verifies a TopicPublishStatusDescContent message.
            * @param message Plain object to verify
            * @returns `null` if valid, otherwise the reason why it is not
            */
        static verify(message: { [k: string]: any }): (string|null);

        /**
            * Creates a TopicPublishStatusDescContent message from a plain object. Also converts values to their respective internal types.
            * @param object Plain object
            * @returns TopicPublishStatusDescContent
            */
        static fromObject(object: { [k: string]: any }): TopicPublishStatusDescContent;

        /**
            * Creates a plain object from a TopicPublishStatusDescContent message. Also converts values to other types if specified.
            * @param message TopicPublishStatusDescContent
            * @param [options] Conversion options
            * @returns Plain object
            */
        static toObject(message: TopicPublishStatusDescContent, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
            * Converts this TopicPublishStatusDescContent to JSON.
            * @returns JSON object
            */
        toJSON(): { [k: string]: any };
}

/** Properties of a SeqInfo. */
export interface ISeqInfo {

        /** SeqInfo id */
        id?: (Uint8Array|null);

        /** SeqInfo offset */
        offset?: (number|Long|null);

        /** SeqInfo start_seq */
        start_seq?: (number|Long|null);

        /** SeqInfo received_seqs */
        received_seqs?: ((number|Long)[]|null);
}

/** Represents a SeqInfo. */
export class SeqInfo implements ISeqInfo {

        /**
            * Constructs a new SeqInfo.
            * @param [properties] Properties to set
            */
        constructor(properties?: ISeqInfo);

        /** SeqInfo id. */
        id: Uint8Array;

        /** SeqInfo offset. */
        offset: (number|Long);

        /** SeqInfo start_seq. */
        start_seq: (number|Long);

        /** SeqInfo received_seqs. */
        received_seqs: (number|Long)[];

        /**
            * Creates a new SeqInfo instance using the specified properties.
            * @param [properties] Properties to set
            * @returns SeqInfo instance
            */
        static create(properties?: ISeqInfo): SeqInfo;

        /**
            * Encodes the specified SeqInfo message. Does not implicitly {@link SeqInfo.verify|verify} messages.
            * @param message SeqInfo message or plain object to encode
            * @param [writer] Writer to encode to
            * @returns Writer
            */
        static encode(message: ISeqInfo, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
            * Encodes the specified SeqInfo message, length delimited. Does not implicitly {@link SeqInfo.verify|verify} messages.
            * @param message SeqInfo message or plain object to encode
            * @param [writer] Writer to encode to
            * @returns Writer
            */
        static encodeDelimited(message: ISeqInfo, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
            * Decodes a SeqInfo message from the specified reader or buffer.
            * @param reader Reader or buffer to decode from
            * @param [length] Message length if known beforehand
            * @returns SeqInfo
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */
        static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): SeqInfo;

        /**
            * Decodes a SeqInfo message from the specified reader or buffer, length delimited.
            * @param reader Reader or buffer to decode from
            * @returns SeqInfo
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */
        static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): SeqInfo;

        /**
            * Verifies a SeqInfo message.
            * @param message Plain object to verify
            * @returns `null` if valid, otherwise the reason why it is not
            */
        static verify(message: { [k: string]: any }): (string|null);

        /**
            * Creates a SeqInfo message from a plain object. Also converts values to their respective internal types.
            * @param object Plain object
            * @returns SeqInfo
            */
        static fromObject(object: { [k: string]: any }): SeqInfo;

        /**
            * Creates a plain object from a SeqInfo message. Also converts values to other types if specified.
            * @param message SeqInfo
            * @param [options] Conversion options
            * @returns Plain object
            */
        static toObject(message: SeqInfo, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
            * Converts this SeqInfo to JSON.
            * @returns JSON object
            */
        toJSON(): { [k: string]: any };
}

/** Properties of a TopicPublishStatusBodyContent. */
export interface ITopicPublishStatusBodyContent {

        /** TopicPublishStatusBodyContent topic_id */
        topic_id?: (Uint8Array|null);

        /** TopicPublishStatusBodyContent device_list */
        device_list?: (Uint8Array[]|null);

        /** TopicPublishStatusBodyContent msg_list */
        msg_list?: (Uint8Array|null);

        /** TopicPublishStatusBodyContent msg_length */
        msg_length?: (number|null);

        /** TopicPublishStatusBodyContent seq_map */
        seq_map?: (ISeqInfo[]|null);
}

/** Represents a TopicPublishStatusBodyContent. */
export class TopicPublishStatusBodyContent implements ITopicPublishStatusBodyContent {

        /**
            * Constructs a new TopicPublishStatusBodyContent.
            * @param [properties] Properties to set
            */
        constructor(properties?: ITopicPublishStatusBodyContent);

        /** TopicPublishStatusBodyContent topic_id. */
        topic_id: Uint8Array;

        /** TopicPublishStatusBodyContent device_list. */
        device_list: Uint8Array[];

        /** TopicPublishStatusBodyContent msg_list. */
        msg_list: Uint8Array;

        /** TopicPublishStatusBodyContent msg_length. */
        msg_length: number;

        /** TopicPublishStatusBodyContent seq_map. */
        seq_map: ISeqInfo[];

        /**
            * Creates a new TopicPublishStatusBodyContent instance using the specified properties.
            * @param [properties] Properties to set
            * @returns TopicPublishStatusBodyContent instance
            */
        static create(properties?: ITopicPublishStatusBodyContent): TopicPublishStatusBodyContent;

        /**
            * Encodes the specified TopicPublishStatusBodyContent message. Does not implicitly {@link TopicPublishStatusBodyContent.verify|verify} messages.
            * @param message TopicPublishStatusBodyContent message or plain object to encode
            * @param [writer] Writer to encode to
            * @returns Writer
            */
        static encode(message: ITopicPublishStatusBodyContent, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
            * Encodes the specified TopicPublishStatusBodyContent message, length delimited. Does not implicitly {@link TopicPublishStatusBodyContent.verify|verify} messages.
            * @param message TopicPublishStatusBodyContent message or plain object to encode
            * @param [writer] Writer to encode to
            * @returns Writer
            */
        static encodeDelimited(message: ITopicPublishStatusBodyContent, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
            * Decodes a TopicPublishStatusBodyContent message from the specified reader or buffer.
            * @param reader Reader or buffer to decode from
            * @param [length] Message length if known beforehand
            * @returns TopicPublishStatusBodyContent
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */
        static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TopicPublishStatusBodyContent;

        /**
            * Decodes a TopicPublishStatusBodyContent message from the specified reader or buffer, length delimited.
            * @param reader Reader or buffer to decode from
            * @returns TopicPublishStatusBodyContent
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */
        static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): TopicPublishStatusBodyContent;

        /**
            * Verifies a TopicPublishStatusBodyContent message.
            * @param message Plain object to verify
            * @returns `null` if valid, otherwise the reason why it is not
            */
        static verify(message: { [k: string]: any }): (string|null);

        /**
            * Creates a TopicPublishStatusBodyContent message from a plain object. Also converts values to their respective internal types.
            * @param object Plain object
            * @returns TopicPublishStatusBodyContent
            */
        static fromObject(object: { [k: string]: any }): TopicPublishStatusBodyContent;

        /**
            * Creates a plain object from a TopicPublishStatusBodyContent message. Also converts values to other types if specified.
            * @param message TopicPublishStatusBodyContent
            * @param [options] Conversion options
            * @returns Plain object
            */
        static toObject(message: TopicPublishStatusBodyContent, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
            * Converts this TopicPublishStatusBodyContent to JSON.
            * @returns JSON object
            */
        toJSON(): { [k: string]: any };
}

/** Properties of a TopicPublishDescContent. */
export interface ITopicPublishDescContent {

        /** TopicPublishDescContent topic_id */
        topic_id?: (Uint8Array|null);

        /** TopicPublishDescContent topic_owner_id */
        topic_owner_id?: (Uint8Array|null);

        /** TopicPublishDescContent msg_info */
        msg_info?: (IMsgInfo|null);
}

/** Represents a TopicPublishDescContent. */
export class TopicPublishDescContent implements ITopicPublishDescContent {

        /**
            * Constructs a new TopicPublishDescContent.
            * @param [properties] Properties to set
            */
        constructor(properties?: ITopicPublishDescContent);

        /** TopicPublishDescContent topic_id. */
        topic_id: Uint8Array;

        /** TopicPublishDescContent topic_owner_id. */
        topic_owner_id: Uint8Array;

        /** TopicPublishDescContent msg_info. */
        msg_info?: (IMsgInfo|null);

        /**
            * Creates a new TopicPublishDescContent instance using the specified properties.
            * @param [properties] Properties to set
            * @returns TopicPublishDescContent instance
            */
        static create(properties?: ITopicPublishDescContent): TopicPublishDescContent;

        /**
            * Encodes the specified TopicPublishDescContent message. Does not implicitly {@link TopicPublishDescContent.verify|verify} messages.
            * @param message TopicPublishDescContent message or plain object to encode
            * @param [writer] Writer to encode to
            * @returns Writer
            */
        static encode(message: ITopicPublishDescContent, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
            * Encodes the specified TopicPublishDescContent message, length delimited. Does not implicitly {@link TopicPublishDescContent.verify|verify} messages.
            * @param message TopicPublishDescContent message or plain object to encode
            * @param [writer] Writer to encode to
            * @returns Writer
            */
        static encodeDelimited(message: ITopicPublishDescContent, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
            * Decodes a TopicPublishDescContent message from the specified reader or buffer.
            * @param reader Reader or buffer to decode from
            * @param [length] Message length if known beforehand
            * @returns TopicPublishDescContent
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */
        static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TopicPublishDescContent;

        /**
            * Decodes a TopicPublishDescContent message from the specified reader or buffer, length delimited.
            * @param reader Reader or buffer to decode from
            * @returns TopicPublishDescContent
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */
        static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): TopicPublishDescContent;

        /**
            * Verifies a TopicPublishDescContent message.
            * @param message Plain object to verify
            * @returns `null` if valid, otherwise the reason why it is not
            */
        static verify(message: { [k: string]: any }): (string|null);

        /**
            * Creates a TopicPublishDescContent message from a plain object. Also converts values to their respective internal types.
            * @param object Plain object
            * @returns TopicPublishDescContent
            */
        static fromObject(object: { [k: string]: any }): TopicPublishDescContent;

        /**
            * Creates a plain object from a TopicPublishDescContent message. Also converts values to other types if specified.
            * @param message TopicPublishDescContent
            * @param [options] Conversion options
            * @returns Plain object
            */
        static toObject(message: TopicPublishDescContent, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
            * Converts this TopicPublishDescContent to JSON.
            * @returns JSON object
            */
        toJSON(): { [k: string]: any };
}

/** Properties of a TopicSubscribeSuccessDescContent. */
export interface ITopicSubscribeSuccessDescContent {

        /** TopicSubscribeSuccessDescContent topic_id */
        topic_id?: (Uint8Array|null);

        /** TopicSubscribeSuccessDescContent topic_owner_id */
        topic_owner_id?: (Uint8Array|null);

        /** TopicSubscribeSuccessDescContent member_id */
        member_id?: (Uint8Array|null);

        /** TopicSubscribeSuccessDescContent msg_seq */
        msg_seq?: (number|Long|null);

        /** TopicSubscribeSuccessDescContent msg_obj_id */
        msg_obj_id?: (Uint8Array|null);
}

/** Represents a TopicSubscribeSuccessDescContent. */
export class TopicSubscribeSuccessDescContent implements ITopicSubscribeSuccessDescContent {

        /**
            * Constructs a new TopicSubscribeSuccessDescContent.
            * @param [properties] Properties to set
            */
        constructor(properties?: ITopicSubscribeSuccessDescContent);

        /** TopicSubscribeSuccessDescContent topic_id. */
        topic_id: Uint8Array;

        /** TopicSubscribeSuccessDescContent topic_owner_id. */
        topic_owner_id: Uint8Array;

        /** TopicSubscribeSuccessDescContent member_id. */
        member_id: Uint8Array;

        /** TopicSubscribeSuccessDescContent msg_seq. */
        msg_seq: (number|Long);

        /** TopicSubscribeSuccessDescContent msg_obj_id. */
        msg_obj_id?: (Uint8Array|null);

        /** TopicSubscribeSuccessDescContent _msg_obj_id. */
        _msg_obj_id?: "msg_obj_id";

        /**
            * Creates a new TopicSubscribeSuccessDescContent instance using the specified properties.
            * @param [properties] Properties to set
            * @returns TopicSubscribeSuccessDescContent instance
            */
        static create(properties?: ITopicSubscribeSuccessDescContent): TopicSubscribeSuccessDescContent;

        /**
            * Encodes the specified TopicSubscribeSuccessDescContent message. Does not implicitly {@link TopicSubscribeSuccessDescContent.verify|verify} messages.
            * @param message TopicSubscribeSuccessDescContent message or plain object to encode
            * @param [writer] Writer to encode to
            * @returns Writer
            */
        static encode(message: ITopicSubscribeSuccessDescContent, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
            * Encodes the specified TopicSubscribeSuccessDescContent message, length delimited. Does not implicitly {@link TopicSubscribeSuccessDescContent.verify|verify} messages.
            * @param message TopicSubscribeSuccessDescContent message or plain object to encode
            * @param [writer] Writer to encode to
            * @returns Writer
            */
        static encodeDelimited(message: ITopicSubscribeSuccessDescContent, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
            * Decodes a TopicSubscribeSuccessDescContent message from the specified reader or buffer.
            * @param reader Reader or buffer to decode from
            * @param [length] Message length if known beforehand
            * @returns TopicSubscribeSuccessDescContent
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */
        static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TopicSubscribeSuccessDescContent;

        /**
            * Decodes a TopicSubscribeSuccessDescContent message from the specified reader or buffer, length delimited.
            * @param reader Reader or buffer to decode from
            * @returns TopicSubscribeSuccessDescContent
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */
        static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): TopicSubscribeSuccessDescContent;

        /**
            * Verifies a TopicSubscribeSuccessDescContent message.
            * @param message Plain object to verify
            * @returns `null` if valid, otherwise the reason why it is not
            */
        static verify(message: { [k: string]: any }): (string|null);

        /**
            * Creates a TopicSubscribeSuccessDescContent message from a plain object. Also converts values to their respective internal types.
            * @param object Plain object
            * @returns TopicSubscribeSuccessDescContent
            */
        static fromObject(object: { [k: string]: any }): TopicSubscribeSuccessDescContent;

        /**
            * Creates a plain object from a TopicSubscribeSuccessDescContent message. Also converts values to other types if specified.
            * @param message TopicSubscribeSuccessDescContent
            * @param [options] Conversion options
            * @returns Plain object
            */
        static toObject(message: TopicSubscribeSuccessDescContent, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
            * Converts this TopicSubscribeSuccessDescContent to JSON.
            * @returns JSON object
            */
        toJSON(): { [k: string]: any };
}

/** Properties of a TopicSubscribeDescContent. */
export interface ITopicSubscribeDescContent {

        /** TopicSubscribeDescContent topic_id */
        topic_id?: (Uint8Array|null);

        /** TopicSubscribeDescContent topic_owner_id */
        topic_owner_id?: (Uint8Array|null);

        /** TopicSubscribeDescContent member_id */
        member_id?: (Uint8Array|null);

        /** TopicSubscribeDescContent msg_offset */
        msg_offset?: (number|Long|null);

        /** TopicSubscribeDescContent msg_obj_id */
        msg_obj_id?: (Uint8Array|null);
}

/** Represents a TopicSubscribeDescContent. */
export class TopicSubscribeDescContent implements ITopicSubscribeDescContent {

        /**
            * Constructs a new TopicSubscribeDescContent.
            * @param [properties] Properties to set
            */
        constructor(properties?: ITopicSubscribeDescContent);

        /** TopicSubscribeDescContent topic_id. */
        topic_id: Uint8Array;

        /** TopicSubscribeDescContent topic_owner_id. */
        topic_owner_id: Uint8Array;

        /** TopicSubscribeDescContent member_id. */
        member_id: Uint8Array;

        /** TopicSubscribeDescContent msg_offset. */
        msg_offset: (number|Long);

        /** TopicSubscribeDescContent msg_obj_id. */
        msg_obj_id?: (Uint8Array|null);

        /** TopicSubscribeDescContent _msg_obj_id. */
        _msg_obj_id?: "msg_obj_id";

        /**
            * Creates a new TopicSubscribeDescContent instance using the specified properties.
            * @param [properties] Properties to set
            * @returns TopicSubscribeDescContent instance
            */
        static create(properties?: ITopicSubscribeDescContent): TopicSubscribeDescContent;

        /**
            * Encodes the specified TopicSubscribeDescContent message. Does not implicitly {@link TopicSubscribeDescContent.verify|verify} messages.
            * @param message TopicSubscribeDescContent message or plain object to encode
            * @param [writer] Writer to encode to
            * @returns Writer
            */
        static encode(message: ITopicSubscribeDescContent, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
            * Encodes the specified TopicSubscribeDescContent message, length delimited. Does not implicitly {@link TopicSubscribeDescContent.verify|verify} messages.
            * @param message TopicSubscribeDescContent message or plain object to encode
            * @param [writer] Writer to encode to
            * @returns Writer
            */
        static encodeDelimited(message: ITopicSubscribeDescContent, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
            * Decodes a TopicSubscribeDescContent message from the specified reader or buffer.
            * @param reader Reader or buffer to decode from
            * @param [length] Message length if known beforehand
            * @returns TopicSubscribeDescContent
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */
        static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TopicSubscribeDescContent;

        /**
            * Decodes a TopicSubscribeDescContent message from the specified reader or buffer, length delimited.
            * @param reader Reader or buffer to decode from
            * @returns TopicSubscribeDescContent
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */
        static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): TopicSubscribeDescContent;

        /**
            * Verifies a TopicSubscribeDescContent message.
            * @param message Plain object to verify
            * @returns `null` if valid, otherwise the reason why it is not
            */
        static verify(message: { [k: string]: any }): (string|null);

        /**
            * Creates a TopicSubscribeDescContent message from a plain object. Also converts values to their respective internal types.
            * @param object Plain object
            * @returns TopicSubscribeDescContent
            */
        static fromObject(object: { [k: string]: any }): TopicSubscribeDescContent;

        /**
            * Creates a plain object from a TopicSubscribeDescContent message. Also converts values to other types if specified.
            * @param message TopicSubscribeDescContent
            * @param [options] Conversion options
            * @returns Plain object
            */
        static toObject(message: TopicSubscribeDescContent, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
            * Converts this TopicSubscribeDescContent to JSON.
            * @returns JSON object
            */
        toJSON(): { [k: string]: any };
}

/** Properties of a TopicUnsubscribeSuccessDescContent. */
export interface ITopicUnsubscribeSuccessDescContent {

        /** TopicUnsubscribeSuccessDescContent topic_id */
        topic_id?: (Uint8Array|null);

        /** TopicUnsubscribeSuccessDescContent topic_owner_id */
        topic_owner_id?: (Uint8Array|null);

        /** TopicUnsubscribeSuccessDescContent member_id */
        member_id?: (Uint8Array|null);

        /** TopicUnsubscribeSuccessDescContent msg_obj_id */
        msg_obj_id?: (Uint8Array|null);
}

/** Represents a TopicUnsubscribeSuccessDescContent. */
export class TopicUnsubscribeSuccessDescContent implements ITopicUnsubscribeSuccessDescContent {

        /**
            * Constructs a new TopicUnsubscribeSuccessDescContent.
            * @param [properties] Properties to set
            */
        constructor(properties?: ITopicUnsubscribeSuccessDescContent);

        /** TopicUnsubscribeSuccessDescContent topic_id. */
        topic_id: Uint8Array;

        /** TopicUnsubscribeSuccessDescContent topic_owner_id. */
        topic_owner_id: Uint8Array;

        /** TopicUnsubscribeSuccessDescContent member_id. */
        member_id: Uint8Array;

        /** TopicUnsubscribeSuccessDescContent msg_obj_id. */
        msg_obj_id?: (Uint8Array|null);

        /** TopicUnsubscribeSuccessDescContent _msg_obj_id. */
        _msg_obj_id?: "msg_obj_id";

        /**
            * Creates a new TopicUnsubscribeSuccessDescContent instance using the specified properties.
            * @param [properties] Properties to set
            * @returns TopicUnsubscribeSuccessDescContent instance
            */
        static create(properties?: ITopicUnsubscribeSuccessDescContent): TopicUnsubscribeSuccessDescContent;

        /**
            * Encodes the specified TopicUnsubscribeSuccessDescContent message. Does not implicitly {@link TopicUnsubscribeSuccessDescContent.verify|verify} messages.
            * @param message TopicUnsubscribeSuccessDescContent message or plain object to encode
            * @param [writer] Writer to encode to
            * @returns Writer
            */
        static encode(message: ITopicUnsubscribeSuccessDescContent, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
            * Encodes the specified TopicUnsubscribeSuccessDescContent message, length delimited. Does not implicitly {@link TopicUnsubscribeSuccessDescContent.verify|verify} messages.
            * @param message TopicUnsubscribeSuccessDescContent message or plain object to encode
            * @param [writer] Writer to encode to
            * @returns Writer
            */
        static encodeDelimited(message: ITopicUnsubscribeSuccessDescContent, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
            * Decodes a TopicUnsubscribeSuccessDescContent message from the specified reader or buffer.
            * @param reader Reader or buffer to decode from
            * @param [length] Message length if known beforehand
            * @returns TopicUnsubscribeSuccessDescContent
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */
        static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TopicUnsubscribeSuccessDescContent;

        /**
            * Decodes a TopicUnsubscribeSuccessDescContent message from the specified reader or buffer, length delimited.
            * @param reader Reader or buffer to decode from
            * @returns TopicUnsubscribeSuccessDescContent
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */
        static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): TopicUnsubscribeSuccessDescContent;

        /**
            * Verifies a TopicUnsubscribeSuccessDescContent message.
            * @param message Plain object to verify
            * @returns `null` if valid, otherwise the reason why it is not
            */
        static verify(message: { [k: string]: any }): (string|null);

        /**
            * Creates a TopicUnsubscribeSuccessDescContent message from a plain object. Also converts values to their respective internal types.
            * @param object Plain object
            * @returns TopicUnsubscribeSuccessDescContent
            */
        static fromObject(object: { [k: string]: any }): TopicUnsubscribeSuccessDescContent;

        /**
            * Creates a plain object from a TopicUnsubscribeSuccessDescContent message. Also converts values to other types if specified.
            * @param message TopicUnsubscribeSuccessDescContent
            * @param [options] Conversion options
            * @returns Plain object
            */
        static toObject(message: TopicUnsubscribeSuccessDescContent, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
            * Converts this TopicUnsubscribeSuccessDescContent to JSON.
            * @returns JSON object
            */
        toJSON(): { [k: string]: any };
}

/** Properties of a TopicUnsubscribeDescContent. */
export interface ITopicUnsubscribeDescContent {

        /** TopicUnsubscribeDescContent topic_id */
        topic_id?: (Uint8Array|null);

        /** TopicUnsubscribeDescContent topic_owner_id */
        topic_owner_id?: (Uint8Array|null);

        /** TopicUnsubscribeDescContent member_id */
        member_id?: (Uint8Array|null);

        /** TopicUnsubscribeDescContent msg_obj_id */
        msg_obj_id?: (Uint8Array|null);
}

/** Represents a TopicUnsubscribeDescContent. */
export class TopicUnsubscribeDescContent implements ITopicUnsubscribeDescContent {

        /**
            * Constructs a new TopicUnsubscribeDescContent.
            * @param [properties] Properties to set
            */
        constructor(properties?: ITopicUnsubscribeDescContent);

        /** TopicUnsubscribeDescContent topic_id. */
        topic_id: Uint8Array;

        /** TopicUnsubscribeDescContent topic_owner_id. */
        topic_owner_id: Uint8Array;

        /** TopicUnsubscribeDescContent member_id. */
        member_id: Uint8Array;

        /** TopicUnsubscribeDescContent msg_obj_id. */
        msg_obj_id?: (Uint8Array|null);

        /** TopicUnsubscribeDescContent _msg_obj_id. */
        _msg_obj_id?: "msg_obj_id";

        /**
            * Creates a new TopicUnsubscribeDescContent instance using the specified properties.
            * @param [properties] Properties to set
            * @returns TopicUnsubscribeDescContent instance
            */
        static create(properties?: ITopicUnsubscribeDescContent): TopicUnsubscribeDescContent;

        /**
            * Encodes the specified TopicUnsubscribeDescContent message. Does not implicitly {@link TopicUnsubscribeDescContent.verify|verify} messages.
            * @param message TopicUnsubscribeDescContent message or plain object to encode
            * @param [writer] Writer to encode to
            * @returns Writer
            */
        static encode(message: ITopicUnsubscribeDescContent, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
            * Encodes the specified TopicUnsubscribeDescContent message, length delimited. Does not implicitly {@link TopicUnsubscribeDescContent.verify|verify} messages.
            * @param message TopicUnsubscribeDescContent message or plain object to encode
            * @param [writer] Writer to encode to
            * @returns Writer
            */
        static encodeDelimited(message: ITopicUnsubscribeDescContent, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
            * Decodes a TopicUnsubscribeDescContent message from the specified reader or buffer.
            * @param reader Reader or buffer to decode from
            * @param [length] Message length if known beforehand
            * @returns TopicUnsubscribeDescContent
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */
        static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TopicUnsubscribeDescContent;

        /**
            * Decodes a TopicUnsubscribeDescContent message from the specified reader or buffer, length delimited.
            * @param reader Reader or buffer to decode from
            * @returns TopicUnsubscribeDescContent
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */
        static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): TopicUnsubscribeDescContent;

        /**
            * Verifies a TopicUnsubscribeDescContent message.
            * @param message Plain object to verify
            * @returns `null` if valid, otherwise the reason why it is not
            */
        static verify(message: { [k: string]: any }): (string|null);

        /**
            * Creates a TopicUnsubscribeDescContent message from a plain object. Also converts values to their respective internal types.
            * @param object Plain object
            * @returns TopicUnsubscribeDescContent
            */
        static fromObject(object: { [k: string]: any }): TopicUnsubscribeDescContent;

        /**
            * Creates a plain object from a TopicUnsubscribeDescContent message. Also converts values to other types if specified.
            * @param message TopicUnsubscribeDescContent
            * @param [options] Conversion options
            * @returns Plain object
            */
        static toObject(message: TopicUnsubscribeDescContent, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
            * Converts this TopicUnsubscribeDescContent to JSON.
            * @returns JSON object
            */
        toJSON(): { [k: string]: any };
}

/** Properties of a TopicDescContent. */
export interface ITopicDescContent {

        /** TopicDescContent unique_id */
        unique_id?: (Uint8Array|null);

        /** TopicDescContent user_data_id */
        user_data_id?: (Uint8Array|null);
}

/** Represents a TopicDescContent. */
export class TopicDescContent implements ITopicDescContent {

        /**
            * Constructs a new TopicDescContent.
            * @param [properties] Properties to set
            */
        constructor(properties?: ITopicDescContent);

        /** TopicDescContent unique_id. */
        unique_id: Uint8Array;

        /** TopicDescContent user_data_id. */
        user_data_id?: (Uint8Array|null);

        /** TopicDescContent _user_data_id. */
        _user_data_id?: "user_data_id";

        /**
            * Creates a new TopicDescContent instance using the specified properties.
            * @param [properties] Properties to set
            * @returns TopicDescContent instance
            */
        static create(properties?: ITopicDescContent): TopicDescContent;

        /**
            * Encodes the specified TopicDescContent message. Does not implicitly {@link TopicDescContent.verify|verify} messages.
            * @param message TopicDescContent message or plain object to encode
            * @param [writer] Writer to encode to
            * @returns Writer
            */
        static encode(message: ITopicDescContent, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
            * Encodes the specified TopicDescContent message, length delimited. Does not implicitly {@link TopicDescContent.verify|verify} messages.
            * @param message TopicDescContent message or plain object to encode
            * @param [writer] Writer to encode to
            * @returns Writer
            */
        static encodeDelimited(message: ITopicDescContent, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
            * Decodes a TopicDescContent message from the specified reader or buffer.
            * @param reader Reader or buffer to decode from
            * @param [length] Message length if known beforehand
            * @returns TopicDescContent
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */
        static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TopicDescContent;

        /**
            * Decodes a TopicDescContent message from the specified reader or buffer, length delimited.
            * @param reader Reader or buffer to decode from
            * @returns TopicDescContent
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */
        static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): TopicDescContent;

        /**
            * Verifies a TopicDescContent message.
            * @param message Plain object to verify
            * @returns `null` if valid, otherwise the reason why it is not
            */
        static verify(message: { [k: string]: any }): (string|null);

        /**
            * Creates a TopicDescContent message from a plain object. Also converts values to their respective internal types.
            * @param object Plain object
            * @returns TopicDescContent
            */
        static fromObject(object: { [k: string]: any }): TopicDescContent;

        /**
            * Creates a plain object from a TopicDescContent message. Also converts values to other types if specified.
            * @param message TopicDescContent
            * @param [options] Conversion options
            * @returns Plain object
            */
        static toObject(message: TopicDescContent, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
            * Converts this TopicDescContent to JSON.
            * @returns JSON object
            */
        toJSON(): { [k: string]: any };
}

/** Properties of a TopicBodyContent. */
export interface ITopicBodyContent {

        /** TopicBodyContent topic_publish_status_id */
        topic_publish_status_id?: (Uint8Array|null);
}

/** Represents a TopicBodyContent. */
export class TopicBodyContent implements ITopicBodyContent {

        /**
            * Constructs a new TopicBodyContent.
            * @param [properties] Properties to set
            */
        constructor(properties?: ITopicBodyContent);

        /** TopicBodyContent topic_publish_status_id. */
        topic_publish_status_id?: (Uint8Array|null);

        /** TopicBodyContent _topic_publish_status_id. */
        _topic_publish_status_id?: "topic_publish_status_id";

        /**
            * Creates a new TopicBodyContent instance using the specified properties.
            * @param [properties] Properties to set
            * @returns TopicBodyContent instance
            */
        static create(properties?: ITopicBodyContent): TopicBodyContent;

        /**
            * Encodes the specified TopicBodyContent message. Does not implicitly {@link TopicBodyContent.verify|verify} messages.
            * @param message TopicBodyContent message or plain object to encode
            * @param [writer] Writer to encode to
            * @returns Writer
            */
        static encode(message: ITopicBodyContent, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
            * Encodes the specified TopicBodyContent message, length delimited. Does not implicitly {@link TopicBodyContent.verify|verify} messages.
            * @param message TopicBodyContent message or plain object to encode
            * @param [writer] Writer to encode to
            * @returns Writer
            */
        static encodeDelimited(message: ITopicBodyContent, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
            * Decodes a TopicBodyContent message from the specified reader or buffer.
            * @param reader Reader or buffer to decode from
            * @param [length] Message length if known beforehand
            * @returns TopicBodyContent
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */
        static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TopicBodyContent;

        /**
            * Decodes a TopicBodyContent message from the specified reader or buffer, length delimited.
            * @param reader Reader or buffer to decode from
            * @returns TopicBodyContent
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */
        static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): TopicBodyContent;

        /**
            * Verifies a TopicBodyContent message.
            * @param message Plain object to verify
            * @returns `null` if valid, otherwise the reason why it is not
            */
        static verify(message: { [k: string]: any }): (string|null);

        /**
            * Creates a TopicBodyContent message from a plain object. Also converts values to their respective internal types.
            * @param object Plain object
            * @returns TopicBodyContent
            */
        static fromObject(object: { [k: string]: any }): TopicBodyContent;

        /**
            * Creates a plain object from a TopicBodyContent message. Also converts values to other types if specified.
            * @param message TopicBodyContent
            * @param [options] Conversion options
            * @returns Plain object
            */
        static toObject(message: TopicBodyContent, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
            * Converts this TopicBodyContent to JSON.
            * @returns JSON object
            */
        toJSON(): { [k: string]: any };
}

